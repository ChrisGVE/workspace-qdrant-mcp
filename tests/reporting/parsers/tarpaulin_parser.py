"""
Parser for Rust tarpaulin JSON output.

Parses cobertura.json files generated by cargo-tarpaulin to extract code coverage metrics.
"""

import json
from pathlib import Path
from typing import Any, Dict, Optional

from ..models import CoverageMetrics, FileCoverage
from .base import BaseParser


class TarpaulinParser(BaseParser):
    """
    Parser for cargo-tarpaulin JSON output.

    Parses JSON files generated by:
        cargo tarpaulin --out Json
    """

    def parse(
        self, coverage_json_path: Path, source_root: Optional[Path] = None
    ) -> CoverageMetrics:
        """
        Parse tarpaulin JSON file.

        Args:
            coverage_json_path: Path to tarpaulin JSON file
            source_root: Optional root path for source files (for relative paths)

        Returns:
            CoverageMetrics with parsed coverage data

        Raises:
            FileNotFoundError: If coverage file doesn't exist
            ValueError: If JSON is invalid or cannot be parsed
        """
        if not coverage_json_path.exists():
            raise FileNotFoundError(f"Coverage file not found: {coverage_json_path}")

        try:
            with open(coverage_json_path, "r") as f:
                data = json.load(f)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid coverage JSON: {e}") from e

        # Tarpaulin JSON format:
        # {
        #   "files": {
        #     "src/main.rs": {
        #       "covered": [1, 2, 5, 6],
        #       "uncovered": [3, 4],
        #       "functions": {
        #         "main": {
        #           "covered": [1, 2],
        #           "uncovered": []
        #         }
        #       }
        #     }
        #   }
        # }

        files_data = data.get("files", {})

        file_coverage_list = []
        total_lines = 0
        total_lines_covered = 0

        for file_path, file_data in files_data.items():
            # Make path relative to source_root if provided
            if source_root:
                try:
                    relative_path = str(Path(file_path).relative_to(source_root))
                except ValueError:
                    relative_path = file_path
            else:
                relative_path = file_path

            covered_lines = file_data.get("covered", [])
            uncovered_lines = file_data.get("uncovered", [])

            lines_covered = len(covered_lines)
            lines_total = lines_covered + len(uncovered_lines)

            if lines_total == 0:
                continue

            line_coverage_percent = (lines_covered / lines_total) * 100.0

            total_lines += lines_total
            total_lines_covered += lines_covered

            file_coverage_list.append(
                FileCoverage(
                    file_path=relative_path,
                    lines_covered=lines_covered,
                    lines_total=lines_total,
                    line_coverage_percent=line_coverage_percent,
                    uncovered_lines=sorted(uncovered_lines),
                )
            )

        # Calculate overall coverage
        overall_coverage_percent = (
            (total_lines_covered / total_lines * 100.0) if total_lines > 0 else 0.0
        )

        return CoverageMetrics(
            line_coverage_percent=overall_coverage_percent,
            lines_covered=total_lines_covered,
            lines_total=total_lines,
            file_coverage=file_coverage_list,
            coverage_tool="tarpaulin",
        )


class TarpaulinLcovParser(BaseParser):
    """
    Parser for cargo-tarpaulin LCOV output.

    Parses lcov.info files generated by:
        cargo tarpaulin --out Lcov
    """

    def parse(
        self, lcov_path: Path, source_root: Optional[Path] = None
    ) -> CoverageMetrics:
        """
        Parse tarpaulin LCOV file.

        Args:
            lcov_path: Path to lcov.info file
            source_root: Optional root path for source files (for relative paths)

        Returns:
            CoverageMetrics with parsed coverage data

        Raises:
            FileNotFoundError: If coverage file doesn't exist
            ValueError: If LCOV format is invalid
        """
        if not lcov_path.exists():
            raise FileNotFoundError(f"Coverage file not found: {lcov_path}")

        # LCOV format:
        # SF:src/main.rs
        # DA:1,1
        # DA:2,0
        # end_of_record

        file_coverage_list = []
        total_lines = 0
        total_lines_covered = 0
        total_functions = 0
        total_functions_covered = 0

        current_file = None
        current_lines_covered = 0
        current_lines_total = 0
        current_uncovered_lines = []
        current_functions_covered = 0
        current_functions_total = 0

        try:
            with open(lcov_path, "r") as f:
                for line in f:
                    line = line.strip()

                    if line.startswith("SF:"):
                        # Start of a new file
                        current_file = line[3:]

                    elif line.startswith("DA:"):
                        # Data line: line_number,execution_count
                        parts = line[3:].split(",")
                        if len(parts) == 2:
                            line_number = int(parts[0])
                            hits = int(parts[1])
                            current_lines_total += 1
                            if hits > 0:
                                current_lines_covered += 1
                            else:
                                current_uncovered_lines.append(line_number)

                    elif line.startswith("FN:"):
                        # Function definition: line_number,function_name
                        current_functions_total += 1

                    elif line.startswith("FNDA:"):
                        # Function data: execution_count,function_name
                        parts = line[5:].split(",")
                        if len(parts) == 2:
                            hits = int(parts[0])
                            if hits > 0:
                                current_functions_covered += 1

                    elif line == "end_of_record":
                        # End of current file
                        if current_file and current_lines_total > 0:
                            # Make path relative to source_root if provided
                            if source_root:
                                try:
                                    relative_path = str(
                                        Path(current_file).relative_to(source_root)
                                    )
                                except ValueError:
                                    relative_path = current_file
                            else:
                                relative_path = current_file

                            line_coverage_percent = (
                                (current_lines_covered / current_lines_total * 100.0)
                                if current_lines_total > 0
                                else 0.0
                            )

                            file_coverage_list.append(
                                FileCoverage(
                                    file_path=relative_path,
                                    lines_covered=current_lines_covered,
                                    lines_total=current_lines_total,
                                    line_coverage_percent=line_coverage_percent,
                                    uncovered_lines=sorted(current_uncovered_lines),
                                    functions_covered=current_functions_covered
                                    if current_functions_total > 0
                                    else None,
                                    functions_total=current_functions_total
                                    if current_functions_total > 0
                                    else None,
                                )
                            )

                            total_lines += current_lines_total
                            total_lines_covered += current_lines_covered
                            total_functions += current_functions_total
                            total_functions_covered += current_functions_covered

                        # Reset for next file
                        current_file = None
                        current_lines_covered = 0
                        current_lines_total = 0
                        current_uncovered_lines = []
                        current_functions_covered = 0
                        current_functions_total = 0

        except Exception as e:
            raise ValueError(f"Error parsing LCOV file: {e}") from e

        # Calculate overall coverage
        overall_coverage_percent = (
            (total_lines_covered / total_lines * 100.0) if total_lines > 0 else 0.0
        )

        function_coverage_percent = (
            (total_functions_covered / total_functions * 100.0)
            if total_functions > 0
            else None
        )

        return CoverageMetrics(
            line_coverage_percent=overall_coverage_percent,
            lines_covered=total_lines_covered,
            lines_total=total_lines,
            function_coverage_percent=function_coverage_percent,
            functions_covered=total_functions_covered if total_functions > 0 else None,
            functions_total=total_functions if total_functions > 0 else None,
            file_coverage=file_coverage_list,
            coverage_tool="tarpaulin-lcov",
        )


# Convenience functions
def parse_tarpaulin_json(
    coverage_json_path: Path, source_root: Optional[Path] = None
) -> CoverageMetrics:
    """
    Quick helper to parse tarpaulin JSON file.

    Args:
        coverage_json_path: Path to tarpaulin JSON file
        source_root: Optional root path for source files

    Returns:
        CoverageMetrics with parsed coverage data

    Example:
        >>> from tests.reporting.parsers.tarpaulin_parser import parse_tarpaulin_json
        >>> coverage = parse_tarpaulin_json(Path("cobertura.json"))
        >>> print(f"Coverage: {coverage.line_coverage_percent:.2f}%")
    """
    parser = TarpaulinParser()
    return parser.parse(coverage_json_path, source_root)


def parse_tarpaulin_lcov(
    lcov_path: Path, source_root: Optional[Path] = None
) -> CoverageMetrics:
    """
    Quick helper to parse tarpaulin LCOV file.

    Args:
        lcov_path: Path to lcov.info file
        source_root: Optional root path for source files

    Returns:
        CoverageMetrics with parsed coverage data

    Example:
        >>> from tests.reporting.parsers.tarpaulin_parser import parse_tarpaulin_lcov
        >>> coverage = parse_tarpaulin_lcov(Path("lcov.info"))
        >>> print(f"Coverage: {coverage.line_coverage_percent:.2f}%")
    """
    parser = TarpaulinLcovParser()
    return parser.parse(lcov_path, source_root)
