"""
Parser for coverage.py XML output.

Parses coverage.xml files generated by coverage.py to extract code coverage metrics.
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Optional

from ..models import CoverageMetrics, FileCoverage
from .base import BaseParser


class CoveragePyParser(BaseParser):
    """
    Parser for coverage.py XML output.

    Parses coverage.xml files generated by:
        coverage run -m pytest
        coverage xml
    """

    def parse(
        self, coverage_xml_path: Path, source_root: Optional[Path] = None
    ) -> CoverageMetrics:
        """
        Parse coverage.py XML file.

        Args:
            coverage_xml_path: Path to coverage.xml file
            source_root: Optional root path for source files (for relative paths)

        Returns:
            CoverageMetrics with parsed coverage data

        Raises:
            FileNotFoundError: If coverage file doesn't exist
            ValueError: If XML is invalid or cannot be parsed
        """
        if not coverage_xml_path.exists():
            raise FileNotFoundError(f"Coverage file not found: {coverage_xml_path}")

        try:
            tree = ET.parse(coverage_xml_path)
            root = tree.getroot()
        except ET.ParseError as e:
            raise ValueError(f"Invalid coverage XML: {e}") from e

        # Extract overall coverage from root element
        # coverage.py XML format:
        # <coverage line-rate="0.85" branch-rate="0.70" ...>
        #   <packages>
        #     <package name="src.python.workspace_qdrant_mcp">
        #       <classes>
        #         <class name="server.py" filename="src/python/workspace_qdrant_mcp/server.py">
        #           <lines>
        #             <line number="1" hits="1"/>
        #             <line number="2" hits="0"/>
        #           </lines>
        #         </class>
        #       </classes>
        #     </package>
        #   </packages>
        # </coverage>

        line_rate = float(root.get("line-rate", 0.0))
        branch_rate_str = root.get("branch-rate")
        branch_rate = float(branch_rate_str) if branch_rate_str else None

        # Parse all files
        file_coverage_list = []
        total_lines = 0
        total_lines_covered = 0
        total_branches = 0
        total_branches_covered = 0

        packages = root.find("packages")
        if packages is not None:
            for package in packages.findall("package"):
                classes = package.find("classes")
                if classes is not None:
                    for cls in classes.findall("class"):
                        file_coverage = self._parse_class(cls, source_root)
                        if file_coverage:
                            file_coverage_list.append(file_coverage)
                            total_lines += file_coverage.lines_total
                            total_lines_covered += file_coverage.lines_covered
                            if file_coverage.branches_total is not None:
                                total_branches += file_coverage.branches_total
                            if file_coverage.branches_covered is not None:
                                total_branches_covered += file_coverage.branches_covered

        # Build CoverageMetrics
        return CoverageMetrics(
            line_coverage_percent=line_rate * 100.0,
            lines_covered=total_lines_covered,
            lines_total=total_lines,
            branch_coverage_percent=branch_rate * 100.0 if branch_rate is not None else None,
            branches_covered=total_branches_covered if total_branches > 0 else None,
            branches_total=total_branches if total_branches > 0 else None,
            file_coverage=file_coverage_list,
            coverage_tool="coverage.py",
        )

    def _parse_class(
        self, class_elem: ET.Element, source_root: Optional[Path] = None
    ) -> Optional[FileCoverage]:
        """
        Parse a single class element (represents a file).

        Args:
            class_elem: XML element for class
            source_root: Optional root path for source files

        Returns:
            FileCoverage or None if invalid
        """
        filename = class_elem.get("filename")
        if not filename:
            return None

        # Make path relative to source_root if provided
        if source_root:
            try:
                file_path = str(Path(filename).relative_to(source_root))
            except ValueError:
                file_path = filename
        else:
            file_path = filename

        # Parse lines
        lines_elem = class_elem.find("lines")
        if lines_elem is None:
            return None

        lines_total = 0
        lines_covered = 0
        uncovered_lines = []

        for line in lines_elem.findall("line"):
            line_number = int(line.get("number", 0))
            hits = int(line.get("hits", 0))

            lines_total += 1
            if hits > 0:
                lines_covered += 1
            else:
                uncovered_lines.append(line_number)

        # Calculate coverage percentage
        line_coverage_percent = (
            (lines_covered / lines_total * 100.0) if lines_total > 0 else 0.0
        )

        # Parse branch coverage if available (coverage.py includes branch info in line elements)
        branches_total = 0
        branches_covered = 0
        for line in lines_elem.findall("line"):
            branch = line.get("branch")
            if branch == "true":
                # branch-rate attribute indicates coverage
                condition_coverage = line.get("condition-coverage")
                if condition_coverage:
                    # Format: "50% (1/2)"
                    try:
                        parts = condition_coverage.split("(")[1].split(")")[0].split("/")
                        covered = int(parts[0])
                        total = int(parts[1])
                        branches_covered += covered
                        branches_total += total
                    except (IndexError, ValueError):
                        pass

        return FileCoverage(
            file_path=file_path,
            lines_covered=lines_covered,
            lines_total=lines_total,
            line_coverage_percent=line_coverage_percent,
            uncovered_lines=uncovered_lines,
            branches_covered=branches_covered if branches_total > 0 else None,
            branches_total=branches_total if branches_total > 0 else None,
        )


# Convenience function for quick parsing
def parse_coverage_xml(coverage_xml_path: Path, source_root: Optional[Path] = None) -> CoverageMetrics:
    """
    Quick helper to parse coverage.py XML file.

    Args:
        coverage_xml_path: Path to coverage.xml file
        source_root: Optional root path for source files

    Returns:
        CoverageMetrics with parsed coverage data

    Example:
        >>> from tests.reporting.parsers.coverage_py_parser import parse_coverage_xml
        >>> coverage = parse_coverage_xml(Path("coverage.xml"))
        >>> print(f"Coverage: {coverage.line_coverage_percent:.2f}%")
    """
    parser = CoveragePyParser()
    return parser.parse(coverage_xml_path, source_root)
