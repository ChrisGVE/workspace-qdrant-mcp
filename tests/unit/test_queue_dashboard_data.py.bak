"""
Unit Tests for Queue Dashboard Data Preparation

Tests widget data generation, layout configuration, caching behavior,
data formatting, and integration with monitoring modules.
"""

import asyncio
import json
from datetime import datetime, timezone, timedelta
from typing import Dict, Any
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from src.python.common.core.queue_dashboard_data import (
    DashboardWidget,
    DashboardLayout,
    QueueDashboardDataProvider,
    WidgetType
)
from src.python.common.core.queue_statistics import QueueStatistics
from src.python.common.core.queue_health import HealthStatus, QueueHealthStatus, HealthIndicator
from src.python.common.core.error_statistics import ErrorSummary


class TestDashboardWidget:
    """Tests for DashboardWidget dataclass."""

    def test_widget_creation(self):
        """Test creating a dashboard widget."""
        widget = DashboardWidget(
            widget_id="test_widget",
            widget_type=WidgetType.GAUGE,
            title="Test Widget",
            data={"value": 42},
            config={"show_percentage": True},
            position=(0, 0, 4, 2),
            refresh_interval=30
        )

        assert widget.widget_id == "test_widget"
        assert widget.widget_type == WidgetType.GAUGE
        assert widget.title == "Test Widget"
        assert widget.data == {"value": 42}
        assert widget.config == {"show_percentage": True}
        assert widget.position == (0, 0, 4, 2)
        assert widget.refresh_interval == 30

    def test_widget_to_dict(self):
        """Test converting widget to dictionary."""
        widget = DashboardWidget(
            widget_id="test_widget",
            widget_type=WidgetType.LINE_CHART,
            title="Test Chart",
            data={"series": []},
            position=(0, 0, 6, 4)
        )

        result = widget.to_dict()

        assert result["widget_id"] == "test_widget"
        assert result["widget_type"] == "line_chart"
        assert result["title"] == "Test Chart"
        assert result["data"] == {"series": []}
        assert result["position"] == {"x": 0, "y": 0, "width": 6, "height": 4}
        assert result["refresh_interval"] == 30

    def test_widget_without_position(self):
        """Test widget without position."""
        widget = DashboardWidget(
            widget_id="test_widget",
            widget_type=WidgetType.STATUS_CARD,
            title="Test Card",
            data={"value": 100}
        )

        result = widget.to_dict()
        assert result["position"] is None


class TestDashboardLayout:
    """Tests for DashboardLayout dataclass."""

    def test_layout_creation(self):
        """Test creating dashboard layout."""
        widgets = [
            DashboardWidget("w1", WidgetType.GAUGE, "Widget 1", {}),
            DashboardWidget("w2", WidgetType.LINE_CHART, "Widget 2", {})
        ]

        layout = DashboardLayout(
            widgets=widgets,
            refresh_interval=60,
            layout_config={"columns": 12},
            preset_name="test"
        )

        assert len(layout.widgets) == 2
        assert layout.refresh_interval == 60
        assert layout.layout_config == {"columns": 12}
        assert layout.preset_name == "test"

    def test_layout_to_dict(self):
        """Test converting layout to dictionary."""
        widgets = [
            DashboardWidget("w1", WidgetType.GAUGE, "Widget 1", {"value": 50})
        ]

        layout = DashboardLayout(
            widgets=widgets,
            refresh_interval=30,
            layout_config={"columns": 12},
            preset_name="overview"
        )

        result = layout.to_dict()

        assert len(result["widgets"]) == 1
        assert result["widgets"][0]["widget_id"] == "w1"
        assert result["refresh_interval"] == 30
        assert result["layout_config"] == {"columns": 12}
        assert result["preset_name"] == "overview"


class TestQueueDashboardDataProvider:
    """Tests for QueueDashboardDataProvider class."""

    @pytest.fixture
    async def provider(self):
        """Create a dashboard data provider for testing."""
        provider = QueueDashboardDataProvider(
            db_path=":memory:",
            cache_ttl_seconds=5,
            enable_trend_analysis=False,  # Disable for simpler testing
            enable_bottleneck_detection=False
        )
        await provider.initialize()
        yield provider
        await provider.close()

    @pytest.fixture
    def mock_stats(self):
        """Create mock queue statistics."""
        return QueueStatistics(
            queue_size=150,
            processing_rate=25.5,
            success_rate=96.8,
            failure_rate=3.2,
            avg_processing_time=125.0,
            items_added_rate=30.0,
            items_removed_rate=25.0,
            priority_distribution={"high": 10, "normal": 140},
            retry_count=5,
            error_count=8,
            timestamp=datetime.now(timezone.utc)
        )

    @pytest.fixture
    def mock_health_status(self):
        """Create mock health status."""
        indicators = [
            HealthIndicator(
                name="queue_backlog",
                status=HealthStatus.HEALTHY,
                value=150,
                threshold=1000,
                message="Queue backlog normal",
                score=100.0
            )
        ]

        return QueueHealthStatus(
            overall_status=HealthStatus.HEALTHY,
            indicators=indicators,
            score=95.0,
            recommendations=["Queue operating normally"],
            timestamp=datetime.now(timezone.utc)
        )

    @pytest.mark.asyncio
    async def test_provider_initialization(self, provider):
        """Test provider initialization."""
        assert provider._initialized
        assert provider.stats_collector is not None
        assert provider.performance_collector is not None
        assert provider.health_calculator is not None
        assert provider.backpressure_detector is not None
        assert provider.error_stats_collector is not None

    @pytest.mark.asyncio
    async def test_get_overview_widgets(self, provider, mock_stats, mock_health_status):
        """Test getting overview status card widgets."""
        # Mock the stats collector
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)

        widgets = await provider.get_overview_widgets()

        assert len(widgets) == 4
        assert all(isinstance(w, DashboardWidget) for w in widgets)
        assert all(w.widget_type == WidgetType.STATUS_CARD for w in widgets)

        # Check widget IDs
        widget_ids = [w.widget_id for w in widgets]
        assert "queue_size_card" in widget_ids
        assert "processing_rate_card" in widget_ids
        assert "error_rate_card" in widget_ids
        assert "success_rate_card" in widget_ids

    @pytest.mark.asyncio
    async def test_get_health_status_widget(self, provider, mock_health_status):
        """Test getting health status gauge widget."""
        # Mock the health calculator
        provider.health_calculator.calculate_health = AsyncMock(return_value=mock_health_status)

        widget = await provider.get_health_status_widget()

        assert widget.widget_id == "health_status"
        assert widget.widget_type == WidgetType.GAUGE
        assert widget.title == "Queue Health"
        assert "value" in widget.data
        assert widget.data["value"] == 95.0
        assert widget.data["status"] == "healthy"
        assert widget.data["color"] == "green"

    @pytest.mark.asyncio
    async def test_get_realtime_metrics(self, provider, mock_stats, mock_health_status):
        """Test getting real-time metrics."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)
        provider.health_calculator.calculate_health = AsyncMock(return_value=mock_health_status)

        metrics = await provider.get_realtime_metrics()

        assert "timestamp" in metrics
        assert metrics["queue_size"] == 150
        assert metrics["processing_rate"] == 25.5
        assert metrics["error_rate"] == 3.2
        assert metrics["success_rate"] == 96.8
        assert metrics["health_score"] == 95.0
        assert metrics["health_status"] == "healthy"

    @pytest.mark.asyncio
    async def test_widget_data_caching(self, provider, mock_stats):
        """Test widget data caching behavior."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)

        # First call should generate widget
        widget1 = await provider.get_widget_data("queue_size_card", use_cache=True)
        assert provider.stats_collector.get_current_statistics.call_count == 1

        # Second call should use cache
        widget2 = await provider.get_widget_data("queue_size_card", use_cache=True)
        assert provider.stats_collector.get_current_statistics.call_count == 1
        assert widget1.data["value"] == widget2.data["value"]

        # Wait for cache to expire
        await asyncio.sleep(6)  # cache_ttl_seconds = 5

        # Third call should regenerate
        widget3 = await provider.get_widget_data("queue_size_card", use_cache=True)
        assert provider.stats_collector.get_current_statistics.call_count == 2

    @pytest.mark.asyncio
    async def test_widget_cache_bypass(self, provider, mock_stats):
        """Test bypassing widget cache."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)

        # First call with cache
        await provider.get_widget_data("queue_size_card", use_cache=True)
        assert provider.stats_collector.get_current_statistics.call_count == 1

        # Second call without cache should regenerate
        await provider.get_widget_data("queue_size_card", use_cache=False)
        assert provider.stats_collector.get_current_statistics.call_count == 2

    @pytest.mark.asyncio
    async def test_get_dashboard_layout_overview(self, provider, mock_stats, mock_health_status):
        """Test getting overview dashboard layout."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)
        provider.health_calculator.calculate_health = AsyncMock(return_value=mock_health_status)

        layout = await provider.get_dashboard_layout(preset="overview")

        assert layout.preset_name == "overview"
        assert len(layout.widgets) > 0
        assert layout.refresh_interval == 30
        assert "columns" in layout.layout_config
        assert layout.layout_config["columns"] == 12

        # Check that widgets have positions
        positioned_widgets = [w for w in layout.widgets if w.position is not None]
        assert len(positioned_widgets) > 0

    @pytest.mark.asyncio
    async def test_get_dashboard_layout_performance(self, provider, mock_stats):
        """Test getting performance dashboard layout."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)
        provider.performance_collector.get_latency_metrics = AsyncMock(
            return_value=MagicMock(avg_latency_ms=50.0)
        )

        layout = await provider.get_dashboard_layout(preset="performance")

        assert layout.preset_name == "performance"
        assert len(layout.widgets) > 0

    @pytest.mark.asyncio
    async def test_get_dashboard_layout_errors(self, provider, mock_stats):
        """Test getting errors dashboard layout."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)
        provider.error_stats_collector.get_error_summary = AsyncMock(
            return_value=ErrorSummary(
                total_errors=10,
                category_stats={},
                severity_counts={},
                recent_errors_count=5,
                oldest_error_age_hours=24.0,
                error_rate_per_hour=0.4
            )
        )
        provider.error_stats_collector.get_recent_errors = AsyncMock(return_value=[])

        layout = await provider.get_dashboard_layout(preset="errors")

        assert layout.preset_name == "errors"
        assert len(layout.widgets) > 0

    @pytest.mark.asyncio
    async def test_invalid_dashboard_preset(self, provider):
        """Test requesting invalid dashboard preset."""
        with pytest.raises(ValueError, match="Unknown dashboard preset"):
            await provider.get_dashboard_layout(preset="invalid_preset")

    @pytest.mark.asyncio
    async def test_export_dashboard_config(self, provider, mock_stats, mock_health_status):
        """Test exporting dashboard configuration."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)
        provider.health_calculator.calculate_health = AsyncMock(return_value=mock_health_status)

        json_config = await provider.export_dashboard_config(format='json', preset="overview")

        # Parse JSON to verify structure
        config = json.loads(json_config)

        assert "dashboard_version" in config
        assert "export_timestamp" in config
        assert "preset" in config
        assert "layout" in config
        assert config["preset"] == "overview"
        assert "widgets" in config["layout"]

    @pytest.mark.asyncio
    async def test_export_invalid_format(self, provider):
        """Test exporting with invalid format."""
        with pytest.raises(ValueError, match="Unsupported format"):
            await provider.export_dashboard_config(format='xml')

    @pytest.mark.asyncio
    async def test_unknown_widget_id(self, provider):
        """Test requesting unknown widget ID."""
        with pytest.raises(ValueError, match="Unknown widget_id"):
            await provider.get_widget_data("nonexistent_widget")

    @pytest.mark.asyncio
    async def test_format_timestamp(self, provider):
        """Test timestamp formatting."""
        dt = datetime(2025, 10, 3, 12, 30, 45, tzinfo=timezone.utc)
        formatted = provider._format_timestamp(dt)

        assert formatted == "2025-10-03T12:30:45+00:00"

    @pytest.mark.asyncio
    async def test_format_number(self, provider):
        """Test number formatting with precision."""
        assert provider._format_number(123.456789, 0) == 123
        assert provider._format_number(123.456789, 1) == 123.5
        assert provider._format_number(123.456789, 2) == 123.46
        assert provider._format_number(123.456789, 3) == 123.457

    @pytest.mark.asyncio
    async def test_get_queue_size_color(self, provider):
        """Test queue size color coding."""
        assert provider._get_queue_size_color(500) == "green"
        assert provider._get_queue_size_color(3000) == "yellow"
        assert provider._get_queue_size_color(7000) == "orange"
        assert provider._get_queue_size_color(15000) == "red"

    @pytest.mark.asyncio
    async def test_get_error_rate_color(self, provider):
        """Test error rate color coding."""
        assert provider._get_error_rate_color(0.5) == "green"
        assert provider._get_error_rate_color(3.0) == "yellow"
        assert provider._get_error_rate_color(7.0) == "orange"
        assert provider._get_error_rate_color(15.0) == "red"

    @pytest.mark.asyncio
    async def test_get_success_rate_color(self, provider):
        """Test success rate color coding."""
        assert provider._get_success_rate_color(98.0) == "green"
        assert provider._get_success_rate_color(92.0) == "yellow"
        assert provider._get_success_rate_color(85.0) == "orange"
        assert provider._get_success_rate_color(70.0) == "red"

    @pytest.mark.asyncio
    async def test_queue_size_card_data(self, provider, mock_stats):
        """Test queue size card data structure."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)

        widget = await provider._get_queue_size_card()

        assert widget.widget_type == WidgetType.STATUS_CARD
        assert widget.title == "Queue Size"
        assert "value" in widget.data
        assert "formatted_value" in widget.data
        assert "trend" in widget.data
        assert "sparkline" in widget.data
        assert "timestamp" in widget.data
        assert "color" in widget.data

    @pytest.mark.asyncio
    async def test_processing_rate_card_data(self, provider, mock_stats):
        """Test processing rate card data structure."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)

        widget = await provider._get_processing_rate_card()

        assert widget.widget_type == WidgetType.STATUS_CARD
        assert widget.title == "Processing Rate"
        assert "value" in widget.data
        assert "formatted_value" in widget.data
        assert "items/min" in widget.data["formatted_value"]

    @pytest.mark.asyncio
    async def test_error_rate_card_data(self, provider, mock_stats):
        """Test error rate card data structure."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)

        widget = await provider._get_error_rate_card()

        assert widget.widget_type == WidgetType.STATUS_CARD
        assert widget.title == "Error Rate"
        assert "value" in widget.data
        assert "formatted_value" in widget.data
        assert "%" in widget.data["formatted_value"]

    @pytest.mark.asyncio
    async def test_line_chart_structure(self, provider, mock_stats):
        """Test line chart widget data structure."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)

        widget = await provider._get_queue_size_chart()

        assert widget.widget_type == WidgetType.LINE_CHART
        assert "series" in widget.data
        assert isinstance(widget.data["series"], list)
        assert "x_axis" in widget.data
        assert "y_axis" in widget.data

    @pytest.mark.asyncio
    async def test_table_widget_structure(self, provider):
        """Test table widget data structure."""
        provider.error_stats_collector.get_recent_errors = AsyncMock(return_value=[
            {
                "timestamp": datetime.now(timezone.utc),
                "severity": "error",
                "category": "parsing",
                "message": "Test error",
                "file_path": "/test/file.py"
            }
        ])

        widget = await provider._get_recent_errors_table()

        assert widget.widget_type == WidgetType.TABLE
        assert "columns" in widget.data
        assert "rows" in widget.data
        assert isinstance(widget.data["columns"], list)
        assert isinstance(widget.data["rows"], list)

    @pytest.mark.asyncio
    async def test_heatmap_widget_structure(self, provider):
        """Test heatmap widget data structure."""
        widget = await provider._get_processing_heatmap()

        assert widget.widget_type == WidgetType.HEATMAP
        assert "x_axis" in widget.data
        assert "y_axis" in widget.data
        assert "data" in widget.data
        assert "color_scale" in widget.data

    @pytest.mark.asyncio
    async def test_no_data_edge_case(self, provider):
        """Test handling of missing/empty data."""
        # Mock empty statistics
        empty_stats = QueueStatistics(
            queue_size=0,
            processing_rate=0.0,
            success_rate=0.0,
            failure_rate=0.0,
            avg_processing_time=0.0,
            items_added_rate=0.0,
            items_removed_rate=0.0,
            priority_distribution={},
            retry_count=0,
            error_count=0,
            timestamp=datetime.now(timezone.utc)
        )

        provider.stats_collector.get_current_statistics = AsyncMock(return_value=empty_stats)

        # Should not raise errors
        widget = await provider._get_queue_size_card()
        assert widget.data["value"] == 0

    @pytest.mark.asyncio
    async def test_concurrent_widget_requests(self, provider, mock_stats):
        """Test concurrent widget data requests."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)

        # Request multiple widgets concurrently
        tasks = [
            provider.get_widget_data("queue_size_card"),
            provider.get_widget_data("processing_rate_card"),
            provider.get_widget_data("error_rate_card")
        ]

        widgets = await asyncio.gather(*tasks)

        assert len(widgets) == 3
        assert all(isinstance(w, DashboardWidget) for w in widgets)

    @pytest.mark.asyncio
    async def test_widget_config_options(self, provider, mock_stats):
        """Test widget configuration options."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)

        widget = await provider._get_queue_size_card()

        assert "config" in widget.to_dict()
        assert isinstance(widget.config, dict)

    @pytest.mark.asyncio
    async def test_responsive_layout_config(self, provider, mock_stats, mock_health_status):
        """Test responsive layout configuration."""
        provider.stats_collector.get_current_statistics = AsyncMock(return_value=mock_stats)
        provider.health_calculator.calculate_health = AsyncMock(return_value=mock_health_status)

        layout = await provider.get_dashboard_layout(preset="overview")

        assert "breakpoints" in layout.layout_config
        breakpoints = layout.layout_config["breakpoints"]
        assert "lg" in breakpoints
        assert "md" in breakpoints
        assert "sm" in breakpoints
        assert "xs" in breakpoints


class TestWidgetIntegration:
    """Integration tests for widget data with monitoring modules."""

    @pytest.mark.asyncio
    async def test_performance_chart_integration(self):
        """Test performance chart integration with performance collector."""
        provider = QueueDashboardDataProvider(
            db_path=":memory:",
            enable_trend_analysis=False,
            enable_bottleneck_detection=False
        )
        await provider.initialize()

        try:
            # Mock performance collector
            provider.performance_collector.get_latency_metrics = AsyncMock(
                return_value=MagicMock(
                    avg_latency_ms=75.0,
                    min_latency_ms=10.0,
                    max_latency_ms=200.0
                )
            )

            widget = await provider._get_latency_chart()

            assert widget.widget_type == WidgetType.LINE_CHART
            assert "series" in widget.data

        finally:
            await provider.close()

    @pytest.mark.asyncio
    async def test_error_table_integration(self):
        """Test error table integration with error stats collector."""
        provider = QueueDashboardDataProvider(
            db_path=":memory:",
            enable_trend_analysis=False,
            enable_bottleneck_detection=False
        )
        await provider.initialize()

        try:
            # Mock error stats collector
            provider.error_stats_collector.get_recent_errors = AsyncMock(return_value=[
                {
                    "timestamp": datetime.now(timezone.utc),
                    "severity": "error",
                    "category": "parsing",
                    "message": "Failed to parse document",
                    "file_path": "/path/to/file.txt"
                }
            ])

            widget = await provider._get_recent_errors_table()

            assert widget.widget_type == WidgetType.TABLE
            assert len(widget.data["rows"]) == 1

        finally:
            await provider.close()
