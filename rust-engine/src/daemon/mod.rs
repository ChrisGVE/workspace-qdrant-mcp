//! Core daemon implementation for workspace document processing

pub mod core;
pub mod state;
pub mod processing;
pub mod watcher;

use crate::config::DaemonConfig;
use crate::error::{DaemonError, DaemonResult};
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{info, warn};\n\n/// Main daemon coordinator\npub struct WorkspaceDaemon {\n    config: DaemonConfig,\n    state: Arc<RwLock<state::DaemonState>>,\n    processing: Arc<processing::DocumentProcessor>,\n    watcher: Option<Arc<watcher::FileWatcher>>,\n}\n\nimpl WorkspaceDaemon {\n    /// Create a new daemon instance\n    pub async fn new(config: DaemonConfig) -> DaemonResult<Self> {\n        // Validate configuration\n        config.validate()?;\n        \n        info!(\"Initializing Workspace Daemon with config: {:?}\", config);\n        \n        // Initialize state management\n        let state = Arc::new(RwLock::new(\n            state::DaemonState::new(&config.database).await?\n        ));\n        \n        // Initialize document processor\n        let processing = Arc::new(\n            processing::DocumentProcessor::new(&config.processing, &config.qdrant).await?\n        );\n        \n        // Initialize file watcher if enabled\n        let watcher = if config.file_watcher.enabled {\n            Some(Arc::new(\n                watcher::FileWatcher::new(&config.file_watcher, Arc::clone(&processing)).await?\n            ))\n        } else {\n            None\n        };\n        \n        Ok(Self {\n            config,\n            state,\n            processing,\n            watcher,\n        })\n    }\n    \n    /// Start all daemon services\n    pub async fn start(&mut self) -> DaemonResult<()> {\n        info!(\"Starting daemon services\");\n        \n        // Start file watcher if enabled\n        if let Some(ref watcher) = self.watcher {\n            watcher.start().await?;\n            info!(\"File watcher started\");\n        }\n        \n        info!(\"All daemon services started successfully\");\n        Ok(())\n    }\n    \n    /// Stop all daemon services\n    pub async fn stop(&mut self) -> DaemonResult<()> {\n        info!(\"Stopping daemon services\");\n        \n        // Stop file watcher\n        if let Some(ref watcher) = self.watcher {\n            watcher.stop().await?;\n            info!(\"File watcher stopped\");\n        }\n        \n        info!(\"All daemon services stopped\");\n        Ok(())\n    }\n    \n    /// Get daemon configuration\n    pub fn config(&self) -> &DaemonConfig {\n        &self.config\n    }\n    \n    /// Get daemon state (read-only)\n    pub async fn state(&self) -> tokio::sync::RwLockReadGuard<state::DaemonState> {\n        self.state.read().await\n    }\n    \n    /// Get daemon state (read-write)\n    pub async fn state_mut(&self) -> tokio::sync::RwLockWriteGuard<state::DaemonState> {\n        self.state.write().await\n    }\n    \n    /// Get document processor\n    pub fn processor(&self) -> &Arc<processing::DocumentProcessor> {\n        &self.processing\n    }\n    \n    /// Get file watcher\n    pub fn watcher(&self) -> Option<&Arc<watcher::FileWatcher>> {\n        self.watcher.as_ref()\n    }\n}"