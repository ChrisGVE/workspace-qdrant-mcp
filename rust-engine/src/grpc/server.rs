//! Main gRPC server implementation with all service registrations

use crate::daemon::WorkspaceDaemon;\nuse crate::error::DaemonError;\nuse crate::grpc::services::{\n    DocumentProcessorImpl,\n    SearchServiceImpl,\n    MemoryServiceImpl,\n    SystemServiceImpl,\n};\nuse crate::proto::{\n    document_processor_server::DocumentProcessorServer,\n    search_service_server::SearchServiceServer,\n    memory_service_server::MemoryServiceServer,\n    system_service_server::SystemServiceServer,\n};\n\nuse anyhow::Result;\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse tokio::signal;\nuse tonic::transport::Server;\nuse tracing::{error, info, warn};\n\n/// Main gRPC server coordinating all daemon services\npub struct GrpcServer {\n    daemon: Arc<WorkspaceDaemon>,\n    address: SocketAddr,\n}\n\nimpl GrpcServer {\n    /// Create a new gRPC server instance\n    pub fn new(daemon: WorkspaceDaemon, address: SocketAddr) -> Self {\n        Self {\n            daemon: Arc::new(daemon),\n            address,\n        }\n    }\n\n    /// Start the gRPC server in foreground mode\n    pub async fn serve(self) -> Result<()> {\n        info!(\"Starting gRPC server on {}\", self.address);\n\n        let server = self.build_server().await?;\n\n        // Graceful shutdown\n        let shutdown_signal = async {\n            signal::ctrl_c()\n                .await\n                .expect(\"Failed to install CTRL+C signal handler\");\n            info!(\"Received shutdown signal, gracefully shutting down...\");\n        };\n\n        server\n            .serve_with_shutdown(self.address, shutdown_signal)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"gRPC server error: {}\", e))?;\n\n        info!(\"gRPC server shutdown complete\");\n        Ok(())\n    }\n\n    /// Start the gRPC server in daemon mode\n    pub async fn serve_daemon(self) -> Result<()> {\n        info!(\"Starting gRPC server in daemon mode on {}\", self.address);\n\n        let server = self.build_server().await?;\n\n        server\n            .serve(self.address)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"gRPC server error: {}\", e))?;\n\n        Ok(())\n    }\n\n    /// Build the complete gRPC server with all services\n    async fn build_server(self) -> Result<tonic::transport::server::Router> {\n        let reflection_service = tonic_reflection::server::Builder::configure()\n            .register_encoded_file_descriptor_set(include_bytes!(concat!(env!(\"OUT_DIR\"), \"/workspace_daemon_descriptor.bin\")))\n            .build()\n            .map_err(|e| anyhow::anyhow!(\"Failed to build reflection service: {}\", e))?;\n\n        // Create service implementations\n        let document_processor = DocumentProcessorImpl::new(Arc::clone(&self.daemon));\n        let search_service = SearchServiceImpl::new(Arc::clone(&self.daemon));\n        let memory_service = MemoryServiceImpl::new(Arc::clone(&self.daemon));\n        let system_service = SystemServiceImpl::new(Arc::clone(&self.daemon));\n\n        let server = Server::builder()\n            // Add compression support\n            .accept_compressed(tonic::codec::CompressionEncoding::Gzip)\n            .send_compressed(tonic::codec::CompressionEncoding::Gzip)\n            // Set message size limits (16MB)\n            .max_decoding_message_size(16 * 1024 * 1024)\n            .max_encoding_message_size(16 * 1024 * 1024)\n            // Add connection timeout\n            .timeout(std::time::Duration::from_secs(30))\n            // Register all services\n            .add_service(DocumentProcessorServer::new(document_processor))\n            .add_service(SearchServiceServer::new(search_service))\n            .add_service(MemoryServiceServer::new(memory_service))\n            .add_service(SystemServiceServer::new(system_service))\n            // Add reflection for debugging\n            .add_service(reflection_service);\n\n        Ok(server)\n    }\n}"