//! gRPC middleware for connection management, metrics, and security

use std::time::{Duration, Instant};\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, info, warn};\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse dashmap::DashMap;\nuse parking_lot::RwLock;\n\n/// Connection tracking and management\n#[derive(Debug)]\npub struct ConnectionManager {\n    /// Active connections count\n    active_connections: AtomicU64,\n    \n    /// Maximum allowed connections\n    max_connections: u64,\n    \n    /// Connection metadata by client ID\n    connections: Arc<DashMap<String, ConnectionInfo>>,\n    \n    /// Rate limiting state\n    rate_limiter: Arc<RwLock<RateLimiter>>,\n}\n\n#[derive(Debug, Clone)]\npub struct ConnectionInfo {\n    pub client_id: String,\n    pub connected_at: Instant,\n    pub last_activity: Instant,\n    pub request_count: AtomicU64,\n    pub bytes_sent: AtomicU64,\n    pub bytes_received: AtomicU64,\n}\n\n#[derive(Debug)]\npub struct RateLimiter {\n    /// Requests per second limit per client\n    requests_per_second: u32,\n    \n    /// Client request tracking\n    client_requests: DashMap<String, Vec<Instant>>,\n    \n    /// Cleanup interval\n    last_cleanup: Instant,\n}\n\nimpl ConnectionManager {\n    pub fn new(max_connections: u64, requests_per_second: u32) -> Self {\n        Self {\n            active_connections: AtomicU64::new(0),\n            max_connections,\n            connections: Arc::new(DashMap::new()),\n            rate_limiter: Arc::new(RwLock::new(RateLimiter {\n                requests_per_second,\n                client_requests: DashMap::new(),\n                last_cleanup: Instant::now(),\n            })),\n        }\n    }\n    \n    /// Register a new connection\n    pub fn register_connection(&self, client_id: String) -> Result<(), Status> {\n        let current_connections = self.active_connections.load(Ordering::SeqCst);\n        \n        if current_connections >= self.max_connections {\n            warn!(\"Connection limit reached: {}/{}\", current_connections, self.max_connections);\n            return Err(Status::resource_exhausted(\"Connection limit reached\"));\n        }\n        \n        let connection_info = ConnectionInfo {\n            client_id: client_id.clone(),\n            connected_at: Instant::now(),\n            last_activity: Instant::now(),\n            request_count: AtomicU64::new(0),\n            bytes_sent: AtomicU64::new(0),\n            bytes_received: AtomicU64::new(0),\n        };\n        \n        self.connections.insert(client_id.clone(), connection_info);\n        self.active_connections.fetch_add(1, Ordering::SeqCst);\n        \n        info!(\"Connection registered: {} (total: {})\", client_id, current_connections + 1);\n        Ok(())\n    }\n    \n    /// Unregister a connection\n    pub fn unregister_connection(&self, client_id: &str) {\n        if self.connections.remove(client_id).is_some() {\n            let remaining = self.active_connections.fetch_sub(1, Ordering::SeqCst) - 1;\n            info!(\"Connection unregistered: {} (remaining: {})\", client_id, remaining);\n        }\n        \n        // Clean up rate limiter tracking\n        self.rate_limiter.read().client_requests.remove(client_id);\n    }\n    \n    /// Check if request is rate limited\n    pub fn check_rate_limit(&self, client_id: &str) -> Result<(), Status> {\n        let mut rate_limiter = self.rate_limiter.write();\n        \n        // Cleanup old entries periodically\n        let now = Instant::now();\n        if now.duration_since(rate_limiter.last_cleanup) > Duration::from_secs(60) {\n            self.cleanup_rate_limiter(&mut rate_limiter, now);\n            rate_limiter.last_cleanup = now;\n        }\n        \n        // Get or create client request history\n        let mut requests = rate_limiter.client_requests\n            .entry(client_id.to_string())\n            .or_insert_with(Vec::new)\n            .clone();\n        \n        // Remove requests older than 1 second\n        requests.retain(|&timestamp| now.duration_since(timestamp) < Duration::from_secs(1));\n        \n        // Check if rate limit exceeded\n        if requests.len() >= rate_limiter.requests_per_second as usize {\n            warn!(\"Rate limit exceeded for client: {}\", client_id);\n            return Err(Status::resource_exhausted(\"Rate limit exceeded\"));\n        }\n        \n        // Add current request\n        requests.push(now);\n        rate_limiter.client_requests.insert(client_id.to_string(), requests);\n        \n        Ok(())\n    }\n    \n    /// Update connection activity\n    pub fn update_activity(&self, client_id: &str, bytes_sent: u64, bytes_received: u64) {\n        if let Some(mut connection) = self.connections.get_mut(client_id) {\n            connection.last_activity = Instant::now();\n            connection.request_count.fetch_add(1, Ordering::SeqCst);\n            connection.bytes_sent.fetch_add(bytes_sent, Ordering::SeqCst);\n            connection.bytes_received.fetch_add(bytes_received, Ordering::SeqCst);\n        }\n    }\n    \n    /// Get connection statistics\n    pub fn get_stats(&self) -> ConnectionStats {\n        let active_count = self.active_connections.load(Ordering::SeqCst);\n        let total_requests: u64 = self.connections\n            .iter()\n            .map(|entry| entry.request_count.load(Ordering::SeqCst))\n            .sum();\n        let total_bytes_sent: u64 = self.connections\n            .iter()\n            .map(|entry| entry.bytes_sent.load(Ordering::SeqCst))\n            .sum();\n        let total_bytes_received: u64 = self.connections\n            .iter()\n            .map(|entry| entry.bytes_received.load(Ordering::SeqCst))\n            .sum();\n            \n        ConnectionStats {\n            active_connections: active_count,\n            max_connections: self.max_connections,\n            total_requests,\n            total_bytes_sent,\n            total_bytes_received,\n        }\n    }\n    \n    /// Cleanup expired connections\n    pub fn cleanup_expired_connections(&self, timeout: Duration) {\n        let now = Instant::now();\n        let mut expired_clients = Vec::new();\n        \n        for entry in self.connections.iter() {\n            if now.duration_since(entry.last_activity) > timeout {\n                expired_clients.push(entry.client_id.clone());\n            }\n        }\n        \n        for client_id in expired_clients {\n            self.unregister_connection(&client_id);\n            warn!(\"Expired connection cleaned up: {}\", client_id);\n        }\n    }\n    \n    fn cleanup_rate_limiter(&self, rate_limiter: &mut RateLimiter, now: Instant) {\n        let cutoff = now - Duration::from_secs(60);\n        \n        // Remove old client tracking data\n        rate_limiter.client_requests.retain(|_client_id, requests| {\n            requests.retain(|&timestamp| timestamp > cutoff);\n            !requests.is_empty()\n        });\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct ConnectionStats {\n    pub active_connections: u64,\n    pub max_connections: u64,\n    pub total_requests: u64,\n    pub total_bytes_sent: u64,\n    pub total_bytes_received: u64,\n}\n\n/// Connection pool for outbound connections (to Qdrant, etc.)\n#[derive(Debug)]\npub struct ConnectionPool<T> {\n    pool: deadpool::managed::Pool<T>,\n    config: PoolConfig,\n}\n\n#[derive(Debug, Clone)]\npub struct PoolConfig {\n    pub max_size: usize,\n    pub min_idle: Option<usize>,\n    pub max_lifetime: Option<Duration>,\n    pub idle_timeout: Option<Duration>,\n    pub connection_timeout: Duration,\n}\n\nimpl Default for PoolConfig {\n    fn default() -> Self {\n        Self {\n            max_size: 10,\n            min_idle: Some(2),\n            max_lifetime: Some(Duration::from_secs(3600)), // 1 hour\n            idle_timeout: Some(Duration::from_secs(600)),   // 10 minutes\n            connection_timeout: Duration::from_secs(30),\n        }\n    }\n}\n\n/// Middleware interceptor for connection management\n#[derive(Debug, Clone)]\npub struct ConnectionInterceptor {\n    connection_manager: Arc<ConnectionManager>,\n}\n\nimpl ConnectionInterceptor {\n    pub fn new(connection_manager: Arc<ConnectionManager>) -> Self {\n        Self { connection_manager }\n    }\n    \n    /// Intercept incoming requests\n    pub fn intercept<T>(&self, request: Request<T>) -> Result<Request<T>, Status> {\n        // Extract client ID from metadata\n        let client_id = request\n            .metadata()\n            .get(\"client-id\")\n            .and_then(|value| value.to_str().ok())\n            .unwrap_or(\"unknown\")\n            .to_string();\n        \n        // Check rate limiting\n        self.connection_manager.check_rate_limit(&client_id)?;\n        \n        // Update activity (approximate request size)\n        let request_size = std::mem::size_of_val(&request) as u64;\n        self.connection_manager.update_activity(&client_id, 0, request_size);\n        \n        Ok(request)\n    }\n    \n    /// Intercept outgoing responses\n    pub fn intercept_response<T>(&self, response: Response<T>, client_id: &str) -> Response<T> {\n        // Update activity (approximate response size)\n        let response_size = std::mem::size_of_val(&response) as u64;\n        self.connection_manager.update_activity(client_id, response_size, 0);\n        \n        response\n    }\n}\n\n/// Retry configuration for failed connections\n#[derive(Debug, Clone)]\npub struct RetryConfig {\n    pub max_retries: u32,\n    pub initial_delay: Duration,\n    pub max_delay: Duration,\n    pub backoff_multiplier: f64,\n}\n\nimpl Default for RetryConfig {\n    fn default() -> Self {\n        Self {\n            max_retries: 3,\n            initial_delay: Duration::from_millis(100),\n            max_delay: Duration::from_secs(30),\n            backoff_multiplier: 2.0,\n        }\n    }\n}\n\n/// Retry wrapper for gRPC operations\npub async fn with_retry<F, T, E>(\n    operation: F,\n    config: &RetryConfig,\n) -> Result<T, E>\nwhere\n    F: Fn() -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<T, E>> + Send>>,\n    E: std::fmt::Debug,\n{\n    let mut delay = config.initial_delay;\n    \n    for attempt in 1..=config.max_retries {\n        match operation().await {\n            Ok(result) => return Ok(result),\n            Err(err) if attempt == config.max_retries => {\n                debug!(\"Operation failed after {} attempts: {:?}\", config.max_retries, err);\n                return Err(err);\n            },\n            Err(err) => {\n                debug!(\"Operation failed (attempt {}/{}): {:?}\", attempt, config.max_retries, err);\n                tokio::time::sleep(delay).await;\n                \n                // Exponential backoff with jitter\n                delay = std::cmp::min(\n                    Duration::from_millis(\n                        (delay.as_millis() as f64 * config.backoff_multiplier) as u64\n                    ),\n                    config.max_delay,\n                );\n            }\n        }\n    }\n    \n    unreachable!()\n}"