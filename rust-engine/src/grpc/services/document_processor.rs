//! Document processing gRPC service implementation

use crate::daemon::WorkspaceDaemon;\nuse crate::proto::{\n    document_processor_server::DocumentProcessor,\n    ProcessDocumentRequest, ProcessDocumentResponse,\n    ProcessingStatusRequest, ProcessingStatusResponse,\n    CancelProcessingRequest,\n};\nuse std::sync::Arc;\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, error, info};\n\n/// Document processor service implementation\n#[derive(Debug)]\npub struct DocumentProcessorImpl {\n    daemon: Arc<WorkspaceDaemon>,\n}\n\nimpl DocumentProcessorImpl {\n    pub fn new(daemon: Arc<WorkspaceDaemon>) -> Self {\n        Self { daemon }\n    }\n}\n\n#[tonic::async_trait]\nimpl DocumentProcessor for DocumentProcessorImpl {\n    async fn process_document(\n        &self,\n        request: Request<ProcessDocumentRequest>,\n    ) -> Result<Response<ProcessDocumentResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Processing document: {:?}\", req.file_path);\n        \n        // TODO: Implement actual document processing\n        // This is a placeholder implementation\n        let response = ProcessDocumentResponse {\n            document_id: uuid::Uuid::new_v4().to_string(),\n            status: crate::proto::ProcessingStatus::Completed as i32,\n            error_message: String::new(),\n            chunks_created: 1,\n            extracted_metadata: std::collections::HashMap::new(),\n            processed_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n        \n        Ok(Response::new(response))\n    }\n    \n    type ProcessDocumentsStream = tokio_stream::wrappers::ReceiverStream<Result<ProcessDocumentResponse, Status>>;\n    \n    async fn process_documents(\n        &self,\n        request: Request<tonic::Streaming<ProcessDocumentRequest>>,\n    ) -> Result<Response<Self::ProcessDocumentsStream>, Status> {\n        let mut stream = request.into_inner();\n        let (tx, rx) = tokio::sync::mpsc::channel(128);\n        \n        // Spawn task to process the stream\n        tokio::spawn(async move {\n            while let Some(req) = stream.message().await.transpose() {\n                match req {\n                    Ok(req) => {\n                        debug!(\"Processing document in stream: {:?}\", req.file_path);\n                        \n                        // TODO: Implement actual processing\n                        let response = ProcessDocumentResponse {\n                            document_id: uuid::Uuid::new_v4().to_string(),\n                            status: crate::proto::ProcessingStatus::Completed as i32,\n                            error_message: String::new(),\n                            chunks_created: 1,\n                            extracted_metadata: std::collections::HashMap::new(),\n                            processed_at: Some(prost_types::Timestamp {\n                                seconds: chrono::Utc::now().timestamp(),\n                                nanos: 0,\n                            }),\n                        };\n                        \n                        if tx.send(Ok(response)).await.is_err() {\n                            break;\n                        }\n                    },\n                    Err(e) => {\n                        let _ = tx.send(Err(e)).await;\n                        break;\n                    }\n                }\n            }\n        });\n        \n        Ok(Response::new(tokio_stream::wrappers::ReceiverStream::new(rx)))\n    }\n    \n    async fn get_processing_status(\n        &self,\n        request: Request<ProcessingStatusRequest>,\n    ) -> Result<Response<ProcessingStatusResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Getting processing status for: {}\", req.operation_id);\n        \n        // TODO: Implement actual status tracking\n        let response = ProcessingStatusResponse {\n            operation_id: req.operation_id,\n            status: crate::proto::ProcessingStatus::Completed as i32,\n            total_documents: 1,\n            processed_documents: 1,\n            failed_documents: 0,\n            error_messages: vec![],\n            started_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp() - 60,\n                nanos: 0,\n            }),\n            updated_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n        \n        Ok(Response::new(response))\n    }\n    \n    async fn cancel_processing(\n        &self,\n        request: Request<CancelProcessingRequest>,\n    ) -> Result<Response<()>, Status> {\n        let req = request.into_inner();\n        info!(\"Cancelling processing operation: {}\", req.operation_id);\n        \n        // TODO: Implement actual cancellation logic\n        \n        Ok(Response::new(()))\n    }\n}"