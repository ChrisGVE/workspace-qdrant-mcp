//! Configuration management for the Workspace Qdrant Daemon

use crate::error::DaemonResult;
use serde::{Deserialize, Serialize};
use std::path::Path;\n\n/// Main daemon configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DaemonConfig {\n    /// Server configuration\n    pub server: ServerConfig,\n    \n    /// Database configuration\n    pub database: DatabaseConfig,\n    \n    /// Qdrant configuration\n    pub qdrant: QdrantConfig,\n    \n    /// Document processing configuration\n    pub processing: ProcessingConfig,\n    \n    /// File watching configuration\n    pub file_watcher: FileWatcherConfig,\n    \n    /// Metrics configuration\n    pub metrics: MetricsConfig,\n    \n    /// Logging configuration\n    pub logging: LoggingConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServerConfig {\n    /// gRPC server host\n    pub host: String,\n    \n    /// gRPC server port\n    pub port: u16,\n    \n    /// Maximum number of concurrent connections\n    pub max_connections: usize,\n    \n    /// Connection timeout in seconds\n    pub connection_timeout_secs: u64,\n    \n    /// Request timeout in seconds\n    pub request_timeout_secs: u64,\n    \n    /// Enable TLS (for future use)\n    pub enable_tls: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DatabaseConfig {\n    /// SQLite database file path\n    pub sqlite_path: String,\n    \n    /// Maximum number of database connections\n    pub max_connections: u32,\n    \n    /// Connection timeout in seconds\n    pub connection_timeout_secs: u64,\n    \n    /// Enable WAL mode for better concurrency\n    pub enable_wal: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct QdrantConfig {\n    /// Qdrant server URL\n    pub url: String,\n    \n    /// Qdrant API key (optional)\n    pub api_key: Option<String>,\n    \n    /// Connection timeout in seconds\n    pub timeout_secs: u64,\n    \n    /// Maximum number of retries\n    pub max_retries: u32,\n    \n    /// Default collection configuration\n    pub default_collection: CollectionConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CollectionConfig {\n    /// Vector size for embeddings\n    pub vector_size: usize,\n    \n    /// Distance metric (Cosine, Euclidean, Dot)\n    pub distance_metric: String,\n    \n    /// Enable payload indexing\n    pub enable_indexing: bool,\n    \n    /// Replication factor\n    pub replication_factor: u32,\n    \n    /// Number of shards\n    pub shard_number: u32,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProcessingConfig {\n    /// Maximum number of concurrent processing tasks\n    pub max_concurrent_tasks: usize,\n    \n    /// Default chunk size for documents\n    pub default_chunk_size: usize,\n    \n    /// Default chunk overlap\n    pub default_chunk_overlap: usize,\n    \n    /// Maximum file size to process (in bytes)\n    pub max_file_size_bytes: u64,\n    \n    /// Supported file extensions\n    pub supported_extensions: Vec<String>,\n    \n    /// Enable LSP integration\n    pub enable_lsp: bool,\n    \n    /// LSP server timeout in seconds\n    pub lsp_timeout_secs: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileWatcherConfig {\n    /// Enable file watching\n    pub enabled: bool,\n    \n    /// Debounce delay in milliseconds\n    pub debounce_ms: u64,\n    \n    /// Maximum number of watched directories\n    pub max_watched_dirs: usize,\n    \n    /// Patterns to ignore\n    pub ignore_patterns: Vec<String>,\n    \n    /// Enable recursive watching\n    pub recursive: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsConfig {\n    /// Enable metrics collection\n    pub enabled: bool,\n    \n    /// Metrics collection interval in seconds\n    pub collection_interval_secs: u64,\n    \n    /// Metrics retention period in days\n    pub retention_days: u32,\n    \n    /// Enable Prometheus metrics export\n    pub enable_prometheus: bool,\n    \n    /// Prometheus metrics port\n    pub prometheus_port: u16,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LoggingConfig {\n    /// Log level (trace, debug, info, warn, error)\n    pub level: String,\n    \n    /// Log file path (optional)\n    pub file_path: Option<String>,\n    \n    /// Enable JSON logging\n    pub json_format: bool,\n    \n    /// Maximum log file size in MB\n    pub max_file_size_mb: u64,\n    \n    /// Maximum number of log files to keep\n    pub max_files: u32,\n}\n\nimpl Default for DaemonConfig {\n    fn default() -> Self {\n        Self {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50051,\n                max_connections: 1000,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 300,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: \"./workspace_daemon.db\".to_string(),\n                max_connections: 10,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: CollectionConfig {\n                    vector_size: 384, // sentence-transformers/all-MiniLM-L6-v2\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 4,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 100 * 1024 * 1024, // 100MB\n                supported_extensions: vec![\n                    \"rs\".to_string(),\n                    \"py\".to_string(),\n                    \"js\".to_string(),\n                    \"ts\".to_string(),\n                    \"md\".to_string(),\n                    \"txt\".to_string(),\n                    \"pdf\".to_string(),\n                    \"html\".to_string(),\n                    \"json\".to_string(),\n                    \"xml\".to_string(),\n                ],\n                enable_lsp: true,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: true,\n                debounce_ms: 500,\n                max_watched_dirs: 100,\n                ignore_patterns: vec![\n                    \"target/**\".to_string(),\n                    \"node_modules/**\".to_string(),\n                    \".git/**\".to_string(),\n                    \"*.tmp\".to_string(),\n                    \"*.log\".to_string(),\n                ],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: true,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: true,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: Some(\"./workspace_daemon.log\".to_string()),\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n}\n\nimpl DaemonConfig {\n    /// Load configuration from file or use defaults\n    pub fn load(config_path: Option<&Path>) -> DaemonResult<Self> {\n        match config_path {\n            Some(path) => {\n                let content = std::fs::read_to_string(path)?;\n                let config: DaemonConfig = serde_yaml::from_str(&content)\n                    .map_err(|e| crate::error::DaemonError::Config(\n                        config::ConfigError::Message(format!(\"Invalid YAML: {}\", e))\n                    ))?;\n                Ok(config)\n            },\n            None => {\n                // Try to load from environment variables\n                Self::from_env()\n            }\n        }\n    }\n    \n    /// Load configuration from environment variables\n    fn from_env() -> DaemonResult<Self> {\n        let mut config = Self::default();\n        \n        // Override with environment variables if present\n        if let Ok(url) = std::env::var(\"QDRANT_URL\") {\n            config.qdrant.url = url;\n        }\n        \n        if let Ok(api_key) = std::env::var(\"QDRANT_API_KEY\") {\n            config.qdrant.api_key = Some(api_key);\n        }\n        \n        if let Ok(host) = std::env::var(\"DAEMON_HOST\") {\n            config.server.host = host;\n        }\n        \n        if let Ok(port) = std::env::var(\"DAEMON_PORT\") {\n            config.server.port = port.parse()\n                .map_err(|e| crate::error::DaemonError::Config(\n                    config::ConfigError::Message(format!(\"Invalid port: {}\", e))\n                ))?;\n        }\n        \n        if let Ok(db_path) = std::env::var(\"DAEMON_DB_PATH\") {\n            config.database.sqlite_path = db_path;\n        }\n        \n        Ok(config)\n    }\n    \n    /// Save configuration to file\n    pub fn save(&self, path: &Path) -> DaemonResult<()> {\n        let content = serde_yaml::to_string(self)\n            .map_err(|e| crate::error::DaemonError::Config(\n                config::ConfigError::Message(format!(\"Serialization error: {}\", e))\n            ))?;\n        std::fs::write(path, content)?;\n        Ok(())\n    }\n    \n    /// Validate configuration\n    pub fn validate(&self) -> DaemonResult<()> {\n        // Validate server configuration\n        if self.server.port == 0 {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Server port cannot be 0\".to_string())\n            ));\n        }\n        \n        // Validate Qdrant URL\n        if self.qdrant.url.is_empty() {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Qdrant URL cannot be empty\".to_string())\n            ));\n        }\n        \n        // Validate database path\n        if self.database.sqlite_path.is_empty() {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Database path cannot be empty\".to_string())\n            ));\n        }\n        \n        // Validate processing configuration\n        if self.processing.default_chunk_size == 0 {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Chunk size must be greater than 0\".to_string())\n            ));\n        }\n        \n        Ok(())\n    }\n}"