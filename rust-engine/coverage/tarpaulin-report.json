{"files":[{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","benches","processing_benchmarks.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse std::time::Duration;\n\n/// Sample benchmark for document processing performance\nfn benchmark_document_processing(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"document_processing\");\n    group.measurement_time(Duration::from_secs(10));\n\n    group.bench_function(\"small_document\", |b| {\n        let content = \"Hello world! \".repeat(100);\n        b.iter(|| {\n            // Simulate document processing\n            black_box(content.len())\n        });\n    });\n\n    group.bench_function(\"large_document\", |b| {\n        let content = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. \".repeat(1000);\n        b.iter(|| {\n            // Simulate large document processing\n            black_box(content.len())\n        });\n    });\n\n    group.finish();\n}\n\n/// Benchmark for search operations\nfn benchmark_search_operations(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"search_operations\");\n\n    group.bench_function(\"vector_search\", |b| {\n        let query_vector = vec![0.1f32; 384]; // Typical embedding dimension\n        b.iter(|| {\n            // Simulate vector similarity calculation\n            let sum: f32 = black_box(query_vector.iter().sum());\n            black_box(sum)\n        });\n    });\n\n    group.bench_function(\"hybrid_search\", |b| {\n        let dense_scores = vec![0.8, 0.7, 0.6, 0.5, 0.4];\n        let sparse_scores = vec![0.9, 0.6, 0.8, 0.3, 0.7];\n\n        b.iter(|| {\n            // Simulate reciprocal rank fusion\n            let mut combined_scores = Vec::new();\n            for (i, (&dense, &sparse)) in dense_scores.iter().zip(sparse_scores.iter()).enumerate() {\n                let rrf_score = 1.0 / (60.0 + i as f32 + 1.0) + 1.0 / (60.0 + i as f32 + 1.0);\n                combined_scores.push(black_box(dense + sparse + rrf_score));\n            }\n            black_box(combined_scores)\n        });\n    });\n\n    group.finish();\n}\n\n/// Benchmark for concurrent operations\nfn benchmark_concurrent_processing(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"concurrent_processing\");\n\n    group.bench_function(\"parallel_document_processing\", |b| {\n        let documents: Vec<String> = (0..100).map(|i| format!(\"Document {}\", i)).collect();\n\n        b.iter(|| {\n            use std::thread;\n            let handles: Vec<_> = documents\n                .chunks(10)\n                .map(|chunk| {\n                    let chunk = chunk.to_vec();\n                    thread::spawn(move || {\n                        chunk.iter().map(|doc| black_box(doc.len())).sum::<usize>()\n                    })\n                })\n                .collect();\n\n            let results: Vec<_> = handles.into_iter().map(|h| h.join().unwrap()).collect();\n            black_box(results)\n        });\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    benchmark_document_processing,\n    benchmark_search_operations,\n    benchmark_concurrent_processing\n);\ncriterion_main!(benches);","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","build.rs"],"content":"use std::env;\nuse std::path::PathBuf;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let out_dir = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n\n    tonic_build::configure()\n        .build_server(true)\n        .build_client(true)\n        .file_descriptor_set_path(out_dir.join(\"workspace_daemon_descriptor.bin\"))\n        .compile_protos(\n            &[\"proto/workspace_daemon.proto\"],\n            &[\"proto\"],\n        )?;\n\n    // Rerun if proto files change\n    println!(\"cargo:rerun-if-changed=proto/workspace_daemon.proto\");\n\n    Ok(())\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","config.rs"],"content":"//! Configuration management for the Workspace Qdrant Daemon\n\nuse crate::error::DaemonResult;\nuse serde::{Deserialize, Serialize};\nuse std::path::Path;\n\n/// Main daemon configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DaemonConfig {\n    /// Server configuration\n    pub server: ServerConfig,\n\n    /// Database configuration\n    pub database: DatabaseConfig,\n\n    /// Qdrant configuration\n    pub qdrant: QdrantConfig,\n\n    /// Document processing configuration\n    pub processing: ProcessingConfig,\n\n    /// File watching configuration\n    pub file_watcher: FileWatcherConfig,\n\n    /// Metrics configuration\n    pub metrics: MetricsConfig,\n\n    /// Logging configuration\n    pub logging: LoggingConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServerConfig {\n    /// gRPC server host\n    pub host: String,\n\n    /// gRPC server port\n    pub port: u16,\n\n    /// Maximum number of concurrent connections\n    pub max_connections: usize,\n\n    /// Connection timeout in seconds\n    pub connection_timeout_secs: u64,\n\n    /// Request timeout in seconds\n    pub request_timeout_secs: u64,\n\n    /// Enable TLS (for future use)\n    pub enable_tls: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DatabaseConfig {\n    /// SQLite database file path\n    pub sqlite_path: String,\n\n    /// Maximum number of database connections\n    pub max_connections: u32,\n\n    /// Connection timeout in seconds\n    pub connection_timeout_secs: u64,\n\n    /// Enable WAL mode for better concurrency\n    pub enable_wal: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct QdrantConfig {\n    /// Qdrant server URL\n    pub url: String,\n\n    /// Qdrant API key (optional)\n    pub api_key: Option<String>,\n\n    /// Connection timeout in seconds\n    pub timeout_secs: u64,\n\n    /// Maximum number of retries\n    pub max_retries: u32,\n\n    /// Default collection configuration\n    pub default_collection: CollectionConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CollectionConfig {\n    /// Vector size for embeddings\n    pub vector_size: usize,\n\n    /// Distance metric (Cosine, Euclidean, Dot)\n    pub distance_metric: String,\n\n    /// Enable payload indexing\n    pub enable_indexing: bool,\n\n    /// Replication factor\n    pub replication_factor: u32,\n\n    /// Number of shards\n    pub shard_number: u32,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProcessingConfig {\n    /// Maximum number of concurrent processing tasks\n    pub max_concurrent_tasks: usize,\n\n    /// Default chunk size for documents\n    pub default_chunk_size: usize,\n\n    /// Default chunk overlap\n    pub default_chunk_overlap: usize,\n\n    /// Maximum file size to process (in bytes)\n    pub max_file_size_bytes: u64,\n\n    /// Supported file extensions\n    pub supported_extensions: Vec<String>,\n\n    /// Enable LSP integration\n    pub enable_lsp: bool,\n\n    /// LSP server timeout in seconds\n    pub lsp_timeout_secs: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileWatcherConfig {\n    /// Enable file watching\n    pub enabled: bool,\n\n    /// Debounce delay in milliseconds\n    pub debounce_ms: u64,\n\n    /// Maximum number of watched directories\n    pub max_watched_dirs: usize,\n\n    /// Patterns to ignore\n    pub ignore_patterns: Vec<String>,\n\n    /// Enable recursive watching\n    pub recursive: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsConfig {\n    /// Enable metrics collection\n    pub enabled: bool,\n\n    /// Metrics collection interval in seconds\n    pub collection_interval_secs: u64,\n\n    /// Metrics retention period in days\n    pub retention_days: u32,\n\n    /// Enable Prometheus metrics export\n    pub enable_prometheus: bool,\n\n    /// Prometheus metrics port\n    pub prometheus_port: u16,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LoggingConfig {\n    /// Log level (trace, debug, info, warn, error)\n    pub level: String,\n\n    /// Log file path (optional)\n    pub file_path: Option<String>,\n\n    /// Enable JSON logging\n    pub json_format: bool,\n\n    /// Maximum log file size in MB\n    pub max_file_size_mb: u64,\n\n    /// Maximum number of log files to keep\n    pub max_files: u32,\n}\n\nimpl Default for DaemonConfig {\n    fn default() -> Self {\n        Self {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50051,\n                max_connections: 1000,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 300,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: \"./workspace_daemon.db\".to_string(),\n                max_connections: 10,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: CollectionConfig {\n                    vector_size: 384, // sentence-transformers/all-MiniLM-L6-v2\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 4,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 100 * 1024 * 1024, // 100MB\n                supported_extensions: vec![\n                    \"rs\".to_string(),\n                    \"py\".to_string(),\n                    \"js\".to_string(),\n                    \"ts\".to_string(),\n                    \"md\".to_string(),\n                    \"txt\".to_string(),\n                    \"pdf\".to_string(),\n                    \"html\".to_string(),\n                    \"json\".to_string(),\n                    \"xml\".to_string(),\n                ],\n                enable_lsp: true,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: true,\n                debounce_ms: 500,\n                max_watched_dirs: 100,\n                ignore_patterns: vec![\n                    \"target/**\".to_string(),\n                    \"node_modules/**\".to_string(),\n                    \".git/**\".to_string(),\n                    \"*.tmp\".to_string(),\n                    \"*.log\".to_string(),\n                ],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: true,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: true,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: Some(\"./workspace_daemon.log\".to_string()),\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n}\n\nimpl DaemonConfig {\n    /// Load configuration from file or use defaults\n    pub fn load(config_path: Option<&Path>) -> DaemonResult<Self> {\n        match config_path {\n            Some(path) => {\n                let content = std::fs::read_to_string(path)?;\n                let config: DaemonConfig = serde_yaml::from_str(&content)\n                    .map_err(|e| crate::error::DaemonError::Config(\n                        config::ConfigError::Message(format!(\"Invalid YAML: {}\", e))\n                    ))?;\n                Ok(config)\n            },\n            None => {\n                // Try to load from environment variables\n                Self::from_env()\n            }\n        }\n    }\n\n    /// Load configuration from environment variables\n    fn from_env() -> DaemonResult<Self> {\n        let mut config = Self::default();\n\n        // Override with environment variables if present\n        if let Ok(url) = std::env::var(\"QDRANT_URL\") {\n            config.qdrant.url = url;\n        }\n\n        if let Ok(api_key) = std::env::var(\"QDRANT_API_KEY\") {\n            config.qdrant.api_key = Some(api_key);\n        }\n\n        if let Ok(host) = std::env::var(\"DAEMON_HOST\") {\n            config.server.host = host;\n        }\n\n        if let Ok(port) = std::env::var(\"DAEMON_PORT\") {\n            config.server.port = port.parse()\n                .map_err(|e| crate::error::DaemonError::Config(\n                    config::ConfigError::Message(format!(\"Invalid port: {}\", e))\n                ))?;\n        }\n\n        if let Ok(db_path) = std::env::var(\"DAEMON_DB_PATH\") {\n            config.database.sqlite_path = db_path;\n        }\n\n        Ok(config)\n    }\n\n    /// Save configuration to file\n    pub fn save(&self, path: &Path) -> DaemonResult<()> {\n        let content = serde_yaml::to_string(self)\n            .map_err(|e| crate::error::DaemonError::Config(\n                config::ConfigError::Message(format!(\"Serialization error: {}\", e))\n            ))?;\n        std::fs::write(path, content)?;\n        Ok(())\n    }\n\n    /// Validate configuration\n    pub fn validate(&self) -> DaemonResult<()> {\n        // Validate server configuration\n        if self.server.port == 0 {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Server port cannot be 0\".to_string())\n            ));\n        }\n\n        // Validate Qdrant URL\n        if self.qdrant.url.is_empty() {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Qdrant URL cannot be empty\".to_string())\n            ));\n        }\n\n        // Validate database path\n        if self.database.sqlite_path.is_empty() {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Database path cannot be empty\".to_string())\n            ));\n        }\n\n        // Validate processing configuration\n        if self.processing.default_chunk_size == 0 {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Chunk size must be greater than 0\".to_string())\n            ));\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::env;\n    use tempfile::tempdir;\n    use std::fs::File;\n    use std::io::Write;\n\n    #[test]\n    fn test_daemon_config_default() {\n        let config = DaemonConfig::default();\n\n        // Test server defaults\n        assert_eq!(config.server.host, \"127.0.0.1\");\n        assert_eq!(config.server.port, 50051);\n        assert_eq!(config.server.max_connections, 1000);\n        assert_eq!(config.server.connection_timeout_secs, 30);\n        assert_eq!(config.server.request_timeout_secs, 300);\n        assert!(!config.server.enable_tls);\n\n        // Test database defaults\n        assert_eq!(config.database.sqlite_path, \"./workspace_daemon.db\");\n        assert_eq!(config.database.max_connections, 10);\n        assert_eq!(config.database.connection_timeout_secs, 30);\n        assert!(config.database.enable_wal);\n\n        // Test qdrant defaults\n        assert_eq!(config.qdrant.url, \"http://localhost:6333\");\n        assert!(config.qdrant.api_key.is_none());\n        assert_eq!(config.qdrant.timeout_secs, 30);\n        assert_eq!(config.qdrant.max_retries, 3);\n        assert_eq!(config.qdrant.default_collection.vector_size, 384);\n        assert_eq!(config.qdrant.default_collection.distance_metric, \"Cosine\");\n        assert!(config.qdrant.default_collection.enable_indexing);\n        assert_eq!(config.qdrant.default_collection.replication_factor, 1);\n        assert_eq!(config.qdrant.default_collection.shard_number, 1);\n\n        // Test processing defaults\n        assert_eq!(config.processing.max_concurrent_tasks, 4);\n        assert_eq!(config.processing.default_chunk_size, 1000);\n        assert_eq!(config.processing.default_chunk_overlap, 200);\n        assert_eq!(config.processing.max_file_size_bytes, 100 * 1024 * 1024);\n        assert!(config.processing.supported_extensions.contains(&\"rs\".to_string()));\n        assert!(config.processing.supported_extensions.contains(&\"py\".to_string()));\n        assert!(config.processing.enable_lsp);\n        assert_eq!(config.processing.lsp_timeout_secs, 10);\n\n        // Test file watcher defaults\n        assert!(config.file_watcher.enabled);\n        assert_eq!(config.file_watcher.debounce_ms, 500);\n        assert_eq!(config.file_watcher.max_watched_dirs, 100);\n        assert!(config.file_watcher.ignore_patterns.contains(&\"target/**\".to_string()));\n        assert!(config.file_watcher.ignore_patterns.contains(&\"node_modules/**\".to_string()));\n        assert!(config.file_watcher.recursive);\n\n        // Test metrics defaults\n        assert!(config.metrics.enabled);\n        assert_eq!(config.metrics.collection_interval_secs, 60);\n        assert_eq!(config.metrics.retention_days, 30);\n        assert!(config.metrics.enable_prometheus);\n        assert_eq!(config.metrics.prometheus_port, 9090);\n\n        // Test logging defaults\n        assert_eq!(config.logging.level, \"info\");\n        assert_eq!(config.logging.file_path, Some(\"./workspace_daemon.log\".to_string()));\n        assert!(!config.logging.json_format);\n        assert_eq!(config.logging.max_file_size_mb, 100);\n        assert_eq!(config.logging.max_files, 5);\n    }\n\n    #[test]\n    fn test_daemon_config_debug_clone() {\n        let config = DaemonConfig::default();\n        let cloned = config.clone();\n\n        assert_eq!(config.server.host, cloned.server.host);\n        assert_eq!(config.qdrant.url, cloned.qdrant.url);\n\n        // Test debug format\n        let debug_str = format!(\"{:?}\", config);\n        assert!(debug_str.contains(\"DaemonConfig\"));\n        assert!(debug_str.contains(\"ServerConfig\"));\n    }\n\n    #[test]\n    fn test_load_config_from_file() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"config.yaml\");\n        let mut file = File::create(&file_path).unwrap();\n\n        writeln!(file, r#\"\nserver:\n  host: \"0.0.0.0\"\n  port: 8080\n  max_connections: 500\n  connection_timeout_secs: 60\n  request_timeout_secs: 600\n  enable_tls: true\nqdrant:\n  url: \"http://remote-qdrant:6333\"\n  api_key: \"test-key\"\n  timeout_secs: 45\n  max_retries: 5\n  default_collection:\n    vector_size: 512\n    distance_metric: \"Euclidean\"\n    enable_indexing: false\n    replication_factor: 2\n    shard_number: 3\ndatabase:\n  sqlite_path: \"/custom/path.db\"\n  max_connections: 20\n  connection_timeout_secs: 45\n  enable_wal: false\nprocessing:\n  max_concurrent_tasks: 8\n  default_chunk_size: 2000\n  default_chunk_overlap: 400\n  max_file_size_bytes: 200000000\n  supported_extensions: [\"rs\", \"py\"]\n  enable_lsp: false\n  lsp_timeout_secs: 20\nfile_watcher:\n  enabled: false\n  debounce_ms: 1000\n  max_watched_dirs: 50\n  ignore_patterns: [\"*.log\"]\n  recursive: false\nmetrics:\n  enabled: false\n  collection_interval_secs: 120\n  retention_days: 60\n  enable_prometheus: false\n  prometheus_port: 9091\nlogging:\n  level: \"debug\"\n  file_path: \"/custom/log.log\"\n  json_format: true\n  max_file_size_mb: 200\n  max_files: 10\n\"#).unwrap();\n\n        let config = DaemonConfig::load(Some(&file_path)).unwrap();\n\n        assert_eq!(config.server.host, \"0.0.0.0\");\n        assert_eq!(config.server.port, 8080);\n        assert_eq!(config.server.max_connections, 500);\n        assert_eq!(config.server.connection_timeout_secs, 60);\n        assert_eq!(config.server.request_timeout_secs, 600);\n        assert!(config.server.enable_tls);\n\n        assert_eq!(config.qdrant.url, \"http://remote-qdrant:6333\");\n        assert_eq!(config.qdrant.api_key, Some(\"test-key\".to_string()));\n        assert_eq!(config.qdrant.timeout_secs, 45);\n        assert_eq!(config.qdrant.max_retries, 5);\n        assert_eq!(config.qdrant.default_collection.vector_size, 512);\n        assert_eq!(config.qdrant.default_collection.distance_metric, \"Euclidean\");\n        assert!(!config.qdrant.default_collection.enable_indexing);\n        assert_eq!(config.qdrant.default_collection.replication_factor, 2);\n        assert_eq!(config.qdrant.default_collection.shard_number, 3);\n\n        assert_eq!(config.database.sqlite_path, \"/custom/path.db\");\n        assert_eq!(config.database.max_connections, 20);\n        assert_eq!(config.database.connection_timeout_secs, 45);\n        assert!(!config.database.enable_wal);\n\n        assert_eq!(config.processing.max_concurrent_tasks, 8);\n        assert_eq!(config.processing.default_chunk_size, 2000);\n        assert_eq!(config.processing.default_chunk_overlap, 400);\n        assert_eq!(config.processing.max_file_size_bytes, 200000000);\n        assert_eq!(config.processing.supported_extensions, vec![\"rs\", \"py\"]);\n        assert!(!config.processing.enable_lsp);\n        assert_eq!(config.processing.lsp_timeout_secs, 20);\n\n        assert!(!config.file_watcher.enabled);\n        assert_eq!(config.file_watcher.debounce_ms, 1000);\n        assert_eq!(config.file_watcher.max_watched_dirs, 50);\n        assert_eq!(config.file_watcher.ignore_patterns, vec![\"*.log\"]);\n        assert!(!config.file_watcher.recursive);\n\n        assert!(!config.metrics.enabled);\n        assert_eq!(config.metrics.collection_interval_secs, 120);\n        assert_eq!(config.metrics.retention_days, 60);\n        assert!(!config.metrics.enable_prometheus);\n        assert_eq!(config.metrics.prometheus_port, 9091);\n\n        assert_eq!(config.logging.level, \"debug\");\n        assert_eq!(config.logging.file_path, Some(\"/custom/log.log\".to_string()));\n        assert!(config.logging.json_format);\n        assert_eq!(config.logging.max_file_size_mb, 200);\n        assert_eq!(config.logging.max_files, 10);\n    }\n\n    #[test]\n    fn test_load_config_no_file() {\n        let config = DaemonConfig::load(None).unwrap();\n        // Should load defaults when no file is provided\n        assert_eq!(config.server.host, \"127.0.0.1\");\n        assert_eq!(config.server.port, 50051);\n    }\n\n    #[test]\n    fn test_load_config_invalid_file() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"invalid.yaml\");\n        let mut file = File::create(&file_path).unwrap();\n        writeln!(file, \"invalid: yaml: content: [\").unwrap();\n\n        let result = DaemonConfig::load(Some(&file_path));\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Config(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected Config error\");\n        }\n    }\n\n    #[test]\n    fn test_load_config_nonexistent_file() {\n        let nonexistent_path = Path::new(\"/nonexistent/config.yaml\");\n        let result = DaemonConfig::load(Some(nonexistent_path));\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Io(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected IO error\");\n        }\n    }\n\n    #[test]\n    fn test_from_env() {\n        // Save original env vars\n        let original_qdrant_url = env::var(\"QDRANT_URL\").ok();\n        let original_qdrant_api_key = env::var(\"QDRANT_API_KEY\").ok();\n        let original_daemon_host = env::var(\"DAEMON_HOST\").ok();\n        let original_daemon_port = env::var(\"DAEMON_PORT\").ok();\n        let original_daemon_db_path = env::var(\"DAEMON_DB_PATH\").ok();\n\n        // Set test env vars\n        env::set_var(\"QDRANT_URL\", \"http://test-qdrant:6333\");\n        env::set_var(\"QDRANT_API_KEY\", \"test-api-key\");\n        env::set_var(\"DAEMON_HOST\", \"0.0.0.0\");\n        env::set_var(\"DAEMON_PORT\", \"8080\");\n        env::set_var(\"DAEMON_DB_PATH\", \"/test/db.sqlite\");\n\n        let config = DaemonConfig::from_env().unwrap();\n\n        assert_eq!(config.qdrant.url, \"http://test-qdrant:6333\");\n        assert_eq!(config.qdrant.api_key, Some(\"test-api-key\".to_string()));\n        assert_eq!(config.server.host, \"0.0.0.0\");\n        assert_eq!(config.server.port, 8080);\n        assert_eq!(config.database.sqlite_path, \"/test/db.sqlite\");\n\n        // Restore original env vars\n        match original_qdrant_url {\n            Some(val) => env::set_var(\"QDRANT_URL\", val),\n            None => env::remove_var(\"QDRANT_URL\"),\n        }\n        match original_qdrant_api_key {\n            Some(val) => env::set_var(\"QDRANT_API_KEY\", val),\n            None => env::remove_var(\"QDRANT_API_KEY\"),\n        }\n        match original_daemon_host {\n            Some(val) => env::set_var(\"DAEMON_HOST\", val),\n            None => env::remove_var(\"DAEMON_HOST\"),\n        }\n        match original_daemon_port {\n            Some(val) => env::set_var(\"DAEMON_PORT\", val),\n            None => env::remove_var(\"DAEMON_PORT\"),\n        }\n        match original_daemon_db_path {\n            Some(val) => env::set_var(\"DAEMON_DB_PATH\", val),\n            None => env::remove_var(\"DAEMON_DB_PATH\"),\n        }\n    }\n\n    #[test]\n    fn test_env_port_parsing_error() {\n        // Test the port parsing logic directly\n        let invalid_port_str = \"invalid_port\";\n        let parse_result: Result<u16, _> = invalid_port_str.parse();\n        assert!(parse_result.is_err());\n\n        // Test that we can create the expected error type\n        let daemon_error = crate::error::DaemonError::Config(\n            config::ConfigError::Message(format!(\"Invalid port: {}\", parse_result.unwrap_err()))\n        );\n\n        match daemon_error {\n            crate::error::DaemonError::Config(_) => {\n                // Expected error type - test passes\n            },\n            _ => panic!(\"Expected Config error for invalid port\"),\n        }\n\n        // Test the error message formatting\n        let error_msg = format!(\"{}\", daemon_error);\n        assert!(error_msg.contains(\"Configuration error\"));\n        assert!(error_msg.contains(\"Invalid port\"));\n    }\n\n    #[test]\n    fn test_save_config() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"output.yaml\");\n\n        let config = DaemonConfig::default();\n        config.save(&file_path).unwrap();\n\n        // Verify file was created and can be read back\n        assert!(file_path.exists());\n        let loaded_config = DaemonConfig::load(Some(&file_path)).unwrap();\n\n        assert_eq!(config.server.host, loaded_config.server.host);\n        assert_eq!(config.server.port, loaded_config.server.port);\n        assert_eq!(config.qdrant.url, loaded_config.qdrant.url);\n    }\n\n    #[test]\n    fn test_validate_config_valid() {\n        let config = DaemonConfig::default();\n        assert!(config.validate().is_ok());\n    }\n\n    #[test]\n    fn test_validate_config_invalid_port() {\n        let mut config = DaemonConfig::default();\n        config.server.port = 0;\n\n        let result = config.validate();\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Config(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected Config error for invalid port\");\n        }\n    }\n\n    #[test]\n    fn test_validate_config_empty_qdrant_url() {\n        let mut config = DaemonConfig::default();\n        config.qdrant.url = String::new();\n\n        let result = config.validate();\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Config(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected Config error for empty Qdrant URL\");\n        }\n    }\n\n    #[test]\n    fn test_validate_config_empty_database_path() {\n        let mut config = DaemonConfig::default();\n        config.database.sqlite_path = String::new();\n\n        let result = config.validate();\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Config(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected Config error for empty database path\");\n        }\n    }\n\n    #[test]\n    fn test_validate_config_zero_chunk_size() {\n        let mut config = DaemonConfig::default();\n        config.processing.default_chunk_size = 0;\n\n        let result = config.validate();\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Config(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected Config error for zero chunk size\");\n        }\n    }\n\n    #[test]\n    fn test_serialization_roundtrip() {\n        let config = DaemonConfig::default();\n\n        // Test YAML serialization\n        let yaml_str = serde_yaml::to_string(&config).unwrap();\n        let deserialized: DaemonConfig = serde_yaml::from_str(&yaml_str).unwrap();\n\n        assert_eq!(config.server.host, deserialized.server.host);\n        assert_eq!(config.server.port, deserialized.server.port);\n        assert_eq!(config.qdrant.url, deserialized.qdrant.url);\n\n        // Test JSON serialization\n        let json_str = serde_json::to_string(&config).unwrap();\n        let deserialized: DaemonConfig = serde_json::from_str(&json_str).unwrap();\n\n        assert_eq!(config.server.host, deserialized.server.host);\n        assert_eq!(config.qdrant.url, deserialized.qdrant.url);\n    }\n\n    #[test]\n    fn test_config_structs_are_send_sync() {\n        fn assert_send_sync<T: Send + Sync>() {}\n\n        assert_send_sync::<DaemonConfig>();\n        assert_send_sync::<ServerConfig>();\n        assert_send_sync::<DatabaseConfig>();\n        assert_send_sync::<QdrantConfig>();\n        assert_send_sync::<CollectionConfig>();\n        assert_send_sync::<ProcessingConfig>();\n        assert_send_sync::<FileWatcherConfig>();\n        assert_send_sync::<MetricsConfig>();\n        assert_send_sync::<LoggingConfig>();\n    }\n\n    #[test]\n    fn test_collection_config_standalone() {\n        let collection_config = CollectionConfig {\n            vector_size: 768,\n            distance_metric: \"Dot\".to_string(),\n            enable_indexing: false,\n            replication_factor: 3,\n            shard_number: 2,\n        };\n\n        let debug_str = format!(\"{:?}\", collection_config);\n        assert!(debug_str.contains(\"CollectionConfig\"));\n        assert!(debug_str.contains(\"768\"));\n        assert!(debug_str.contains(\"Dot\"));\n\n        let cloned = collection_config.clone();\n        assert_eq!(collection_config.vector_size, cloned.vector_size);\n        assert_eq!(collection_config.distance_metric, cloned.distance_metric);\n    }\n\n    #[test]\n    fn test_config_with_serde_defaults() {\n        // Test that all config structs can be created with minimal YAML\n        // This tests basic serialization/deserialization\n        let minimal_yaml = r#\"\nserver:\n  host: \"custom-host\"\n  port: 9999\n  max_connections: 500\n  connection_timeout_secs: 30\n  request_timeout_secs: 300\n  enable_tls: false\nqdrant:\n  url: \"http://custom-qdrant:6333\"\n  api_key: null\n  timeout_secs: 30\n  max_retries: 3\n  default_collection:\n    vector_size: 384\n    distance_metric: \"Cosine\"\n    enable_indexing: true\n    replication_factor: 1\n    shard_number: 1\ndatabase:\n  sqlite_path: \"./workspace_daemon.db\"\n  max_connections: 10\n  connection_timeout_secs: 30\n  enable_wal: true\nprocessing:\n  max_concurrent_tasks: 4\n  default_chunk_size: 1000\n  default_chunk_overlap: 200\n  max_file_size_bytes: 104857600\n  supported_extensions: [\"rs\", \"py\"]\n  enable_lsp: true\n  lsp_timeout_secs: 10\nfile_watcher:\n  enabled: true\n  debounce_ms: 500\n  max_watched_dirs: 100\n  ignore_patterns: [\"target/**\"]\n  recursive: true\nmetrics:\n  enabled: true\n  collection_interval_secs: 60\n  retention_days: 30\n  enable_prometheus: true\n  prometheus_port: 9090\nlogging:\n  level: \"info\"\n  file_path: \"./workspace_daemon.log\"\n  json_format: false\n  max_file_size_mb: 100\n  max_files: 5\n\"#;\n\n        let config: DaemonConfig = serde_yaml::from_str(minimal_yaml).unwrap();\n\n        // Custom fields should be set\n        assert_eq!(config.server.host, \"custom-host\");\n        assert_eq!(config.server.port, 9999);\n        assert_eq!(config.qdrant.url, \"http://custom-qdrant:6333\");\n    }\n}","traces":[{"line":183,"address":[],"length":0,"stats":{"Line":11}},{"line":185,"address":[],"length":0,"stats":{"Line":22}},{"line":193,"address":[],"length":0,"stats":{"Line":22}},{"line":199,"address":[],"length":0,"stats":{"Line":22}},{"line":212,"address":[],"length":0,"stats":{"Line":22}},{"line":232,"address":[],"length":0,"stats":{"Line":22}},{"line":245,"address":[],"length":0,"stats":{"Line":22}},{"line":252,"address":[],"length":0,"stats":{"Line":11}},{"line":265,"address":[],"length":0,"stats":{"Line":5}},{"line":266,"address":[],"length":0,"stats":{"Line":5}},{"line":267,"address":[],"length":0,"stats":{"Line":4}},{"line":268,"address":[],"length":0,"stats":{"Line":12}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":4}},{"line":287,"address":[],"length":0,"stats":{"Line":3}},{"line":291,"address":[],"length":0,"stats":{"Line":4}},{"line":295,"address":[],"length":0,"stats":{"Line":3}},{"line":299,"address":[],"length":0,"stats":{"Line":3}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":3}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":315,"address":[],"length":0,"stats":{"Line":3}},{"line":316,"address":[],"length":0,"stats":{"Line":1}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":1}},{"line":324,"address":[],"length":0,"stats":{"Line":102}},{"line":326,"address":[],"length":0,"stats":{"Line":102}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":1}},{"line":334,"address":[],"length":0,"stats":{"Line":2}},{"line":335,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":342,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":1}},{"line":349,"address":[],"length":0,"stats":{"Line":1}}],"covered":36,"coverable":39},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","daemon","core.rs"],"content":"//! Core daemon functionality\n\nuse crate::error::{DaemonError, DaemonResult};\nuse tracing::{info, debug};\n\n/// Core daemon utilities\n#[derive(Debug)]\npub struct DaemonCore;\n\nimpl DaemonCore {\n    /// Initialize daemon core\n    pub fn new() -> Self {\n        info!(\"Initializing daemon core\");\n        Self\n    }\n\n    /// Get system information\n    pub fn get_system_info() -> DaemonResult<SystemInfo> {\n        Ok(SystemInfo {\n            cpu_count: num_cpus::get(),\n            memory_total: Self::get_total_memory(),\n            hostname: hostname::get()\n                .map_err(|e| DaemonError::System { message: format!(\"Failed to get hostname: {}\", e) })?\n                .to_string_lossy()\n                .to_string(),\n        })\n    }\n\n    /// Get total system memory (placeholder implementation)\n    fn get_total_memory() -> u64 {\n        // TODO: Implement actual memory detection\n        8 * 1024 * 1024 * 1024 // 8GB placeholder\n    }\n}\n\n/// System information\n#[derive(Debug, Clone)]\npub struct SystemInfo {\n    pub cpu_count: usize,\n    pub memory_total: u64,\n    pub hostname: String,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_daemon_core_new() {\n        let core = DaemonCore::new();\n        // Just ensure we can create an instance\n        let debug_str = format!(\"{:?}\", core);\n        assert!(!debug_str.is_empty());\n    }\n\n    #[test]\n    fn test_get_system_info() {\n        let system_info = DaemonCore::get_system_info().unwrap();\n\n        // CPU count should be at least 1\n        assert!(system_info.cpu_count > 0);\n\n        // Memory should be the placeholder value\n        assert_eq!(system_info.memory_total, 8 * 1024 * 1024 * 1024);\n\n        // Hostname should not be empty\n        assert!(!system_info.hostname.is_empty());\n\n        // Test debug formatting\n        let debug_str = format!(\"{:?}\", system_info);\n        assert!(debug_str.contains(\"SystemInfo\"));\n        assert!(debug_str.contains(&system_info.hostname));\n    }\n\n    #[test]\n    fn test_get_total_memory() {\n        let memory = DaemonCore::get_total_memory();\n        assert_eq!(memory, 8 * 1024 * 1024 * 1024); // 8GB placeholder\n    }\n\n    #[test]\n    fn test_system_info_clone() {\n        let original = SystemInfo {\n            cpu_count: 4,\n            memory_total: 1024,\n            hostname: \"test-host\".to_string(),\n        };\n\n        let cloned = original.clone();\n        assert_eq!(original.cpu_count, cloned.cpu_count);\n        assert_eq!(original.memory_total, cloned.memory_total);\n        assert_eq!(original.hostname, cloned.hostname);\n    }\n\n    #[test]\n    fn test_system_info_debug() {\n        let info = SystemInfo {\n            cpu_count: 8,\n            memory_total: 16 * 1024 * 1024 * 1024,\n            hostname: \"debug-test\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", info);\n        assert!(debug_str.contains(\"SystemInfo\"));\n        assert!(debug_str.contains(\"8\"));\n        assert!(debug_str.contains(\"debug-test\"));\n    }\n\n    #[test]\n    fn test_daemon_core_is_unit_struct() {\n        let core1 = DaemonCore::new();\n        let core2 = DaemonCore::new();\n\n        // Both instances should have the same size (unit struct)\n        assert_eq!(\n            std::mem::size_of_val(&core1),\n            std::mem::size_of_val(&core2)\n        );\n        assert_eq!(std::mem::size_of::<DaemonCore>(), 0);\n    }\n}","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":3}},{"line":13,"address":[],"length":0,"stats":{"Line":3}},{"line":14,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}}],"covered":11,"coverable":11},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","daemon","mod.rs"],"content":"//! Core daemon implementation for workspace document processing\n\npub mod core;\npub mod state;\npub mod processing;\npub mod watcher;\n\nuse crate::config::DaemonConfig;\nuse crate::error::{DaemonError, DaemonResult};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{info, warn};\n\n/// Main daemon coordinator\n#[derive(Debug, Clone)]\npub struct WorkspaceDaemon {\n    config: DaemonConfig,\n    state: Arc<RwLock<state::DaemonState>>,\n    processing: Arc<processing::DocumentProcessor>,\n    watcher: Option<Arc<watcher::FileWatcher>>,\n}\n\nimpl WorkspaceDaemon {\n    /// Create a new daemon instance\n    pub async fn new(config: DaemonConfig) -> DaemonResult<Self> {\n        // Validate configuration\n        config.validate()?;\n\n        info!(\"Initializing Workspace Daemon with config: {:?}\", config);\n\n        // Initialize state management\n        let state = Arc::new(RwLock::new(\n            state::DaemonState::new(&config.database).await?\n        ));\n\n        // Initialize document processor\n        let processing = Arc::new(\n            processing::DocumentProcessor::new(&config.processing, &config.qdrant).await?\n        );\n\n        // Initialize file watcher if enabled\n        let watcher = if config.file_watcher.enabled {\n            Some(Arc::new(\n                watcher::FileWatcher::new(&config.file_watcher, Arc::clone(&processing)).await?\n            ))\n        } else {\n            None\n        };\n\n        Ok(Self {\n            config,\n            state,\n            processing,\n            watcher,\n        })\n    }\n\n    /// Start all daemon services\n    pub async fn start(&mut self) -> DaemonResult<()> {\n        info!(\"Starting daemon services\");\n\n        // Start file watcher if enabled\n        if let Some(ref watcher) = self.watcher {\n            watcher.start().await?;\n            info!(\"File watcher started\");\n        }\n\n        info!(\"All daemon services started successfully\");\n        Ok(())\n    }\n\n    /// Stop all daemon services\n    pub async fn stop(&mut self) -> DaemonResult<()> {\n        info!(\"Stopping daemon services\");\n\n        // Stop file watcher\n        if let Some(ref watcher) = self.watcher {\n            watcher.stop().await?;\n            info!(\"File watcher stopped\");\n        }\n\n        info!(\"All daemon services stopped\");\n        Ok(())\n    }\n\n    /// Get daemon configuration\n    pub fn config(&self) -> &DaemonConfig {\n        &self.config\n    }\n\n    /// Get daemon state (read-only)\n    pub async fn state(&self) -> tokio::sync::RwLockReadGuard<state::DaemonState> {\n        self.state.read().await\n    }\n\n    /// Get daemon state (read-write)\n    pub async fn state_mut(&self) -> tokio::sync::RwLockWriteGuard<state::DaemonState> {\n        self.state.write().await\n    }\n\n    /// Get document processor\n    pub fn processor(&self) -> &Arc<processing::DocumentProcessor> {\n        &self.processing\n    }\n\n    /// Get file watcher\n    pub fn watcher(&self) -> Option<&Arc<watcher::FileWatcher>> {\n        self.watcher.as_ref()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use tempfile::TempDir;\n    use tokio_test;\n    use std::path::PathBuf;\n    use uuid::Uuid;\n\n    fn create_test_config() -> DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\".to_string();\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50051,\n                max_connections: 1000,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 300,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path,\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: crate::config::CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 4,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 100,\n                max_file_size_bytes: 1000000,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 100,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: crate::config::MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: crate::config::LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    fn create_test_config_with_watcher() -> DaemonConfig {\n        let mut config = create_test_config();\n        config.file_watcher.enabled = true;\n        config\n    }\n\n    #[tokio::test]\n    async fn test_workspace_daemon_new_success() {\n        let config = create_test_config();\n        let result = WorkspaceDaemon::new(config).await;\n\n        assert!(result.is_ok());\n        let daemon = result.unwrap();\n        assert_eq!(daemon.config().database.max_connections, 5);\n        assert_eq!(daemon.config().qdrant.url, \"http://localhost:6333\");\n        assert!(daemon.watcher().is_none());\n    }\n\n    #[tokio::test]\n    async fn test_workspace_daemon_new_with_watcher() {\n        let config = create_test_config_with_watcher();\n        let result = WorkspaceDaemon::new(config).await;\n\n        assert!(result.is_ok());\n        let daemon = result.unwrap();\n        assert!(daemon.watcher().is_some());\n    }\n\n    #[tokio::test]\n    async fn test_workspace_daemon_debug_format() {\n        let config = create_test_config();\n        let daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        let debug_str = format!(\"{:?}\", daemon);\n        assert!(debug_str.contains(\"WorkspaceDaemon\"));\n    }\n\n    #[tokio::test]\n    async fn test_daemon_config_access() {\n        let config = create_test_config();\n        let original_max_connections = config.database.max_connections;\n        let daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        assert_eq!(daemon.config().database.max_connections, original_max_connections);\n    }\n\n    #[tokio::test]\n    async fn test_daemon_state_access() {\n        let config = create_test_config();\n        let daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        let state = daemon.state().await;\n        // Test that we can access state\n        drop(state);\n\n        let state_mut = daemon.state_mut().await;\n        // Test that we can access mutable state\n        drop(state_mut);\n    }\n\n    #[tokio::test]\n    async fn test_daemon_processor_access() {\n        let config = create_test_config();\n        let daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        let processor1 = daemon.processor();\n        let processor2 = daemon.processor();\n        assert!(Arc::ptr_eq(&processor1, &processor2)); // Should be same Arc\n    }\n\n    #[tokio::test]\n    async fn test_daemon_start_stop_cycle() {\n        let config = create_test_config();\n        let mut daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        // Test start\n        let start_result = daemon.start().await;\n        assert!(start_result.is_ok());\n\n        // Test stop\n        let stop_result = daemon.stop().await;\n        assert!(stop_result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_daemon_start_stop_with_watcher() {\n        let config = create_test_config_with_watcher();\n        let mut daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        // Test start with watcher\n        let start_result = daemon.start().await;\n        assert!(start_result.is_ok());\n\n        // Test stop with watcher\n        let stop_result = daemon.stop().await;\n        assert!(stop_result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_daemon_start_disabled_watcher() {\n        let config = create_test_config(); // watcher disabled\n        let mut daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        let start_result = daemon.start().await;\n        assert!(start_result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_daemon_multiple_start_stop_cycles() {\n        let config = create_test_config();\n        let mut daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        // Multiple start/stop cycles\n        for _ in 0..3 {\n            assert!(daemon.start().await.is_ok());\n            assert!(daemon.stop().await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_daemon_watcher_option_handling() {\n        // Test with watcher disabled\n        let config_disabled = create_test_config();\n        let daemon_disabled = WorkspaceDaemon::new(config_disabled).await.unwrap();\n        assert!(daemon_disabled.watcher().is_none());\n\n        // Test with watcher enabled\n        let config_enabled = create_test_config_with_watcher();\n        let daemon_enabled = WorkspaceDaemon::new(config_enabled).await.unwrap();\n        assert!(daemon_enabled.watcher().is_some());\n    }\n\n    #[tokio::test]\n    async fn test_daemon_concurrent_state_access() {\n        let config = create_test_config();\n        let daemon = Arc::new(WorkspaceDaemon::new(config).await.unwrap());\n\n        let daemon1 = Arc::clone(&daemon);\n        let daemon2 = Arc::clone(&daemon);\n\n        let handle1 = tokio::spawn(async move {\n            let _state = daemon1.state().await;\n            tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;\n        });\n\n        let handle2 = tokio::spawn(async move {\n            let _state = daemon2.state().await;\n            tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;\n        });\n\n        let (r1, r2) = tokio::join!(handle1, handle2);\n        assert!(r1.is_ok());\n        assert!(r2.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_daemon_processor_arc_sharing() {\n        let config = create_test_config();\n        let daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        let processor1 = daemon.processor();\n        let processor2 = daemon.processor();\n\n        // Both should point to the same Arc<DocumentProcessor>\n        assert!(Arc::ptr_eq(processor1, processor2));\n    }\n\n    #[tokio::test]\n    async fn test_daemon_error_handling_invalid_config() {\n        let mut config = create_test_config();\n\n        // Make config invalid by setting empty URL\n        config.qdrant.url = String::new();\n\n        let result = WorkspaceDaemon::new(config).await;\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_daemon_struct_send_sync() {\n        fn assert_send<T: Send>() {}\n        fn assert_sync<T: Sync>() {}\n\n        assert_send::<WorkspaceDaemon>();\n        assert_sync::<WorkspaceDaemon>();\n    }\n}","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":194}},{"line":27,"address":[],"length":0,"stats":{"Line":195}},{"line":29,"address":[],"length":0,"stats":{"Line":96}},{"line":32,"address":[],"length":0,"stats":{"Line":96}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":96}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":12}},{"line":47,"address":[],"length":0,"stats":{"Line":93}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":7}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":73,"address":[],"length":0,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":5}},{"line":87,"address":[],"length":0,"stats":{"Line":21}},{"line":88,"address":[],"length":0,"stats":{"Line":21}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":8}}],"covered":28,"coverable":32},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","daemon","processing.rs"],"content":"//! Document processing engine\n\nuse crate::config::{ProcessingConfig, QdrantConfig};\nuse crate::error::{DaemonError, DaemonResult};\nuse std::sync::Arc;\nuse tokio::sync::Semaphore;\nuse tracing::{info, debug};\n\n/// Document processor\n#[derive(Debug)]\npub struct DocumentProcessor {\n    config: ProcessingConfig,\n    qdrant_config: QdrantConfig,\n    semaphore: Arc<Semaphore>,\n}\n\nimpl DocumentProcessor {\n    /// Create a new document processor\n    pub async fn new(config: &ProcessingConfig, qdrant_config: &QdrantConfig) -> DaemonResult<Self> {\n        info!(\"Initializing document processor with max concurrent tasks: {}\", config.max_concurrent_tasks);\n\n        let semaphore = Arc::new(Semaphore::new(config.max_concurrent_tasks));\n\n        Ok(Self {\n            config: config.clone(),\n            qdrant_config: qdrant_config.clone(),\n            semaphore,\n        })\n    }\n\n    /// Process a single document\n    pub async fn process_document(&self, file_path: &str) -> DaemonResult<String> {\n        let _permit = self.semaphore.acquire().await\n            .map_err(|e| DaemonError::Internal { message: format!(\"Semaphore error: {}\", e) })?;\n\n        debug!(\"Processing document: {}\", file_path);\n\n        // TODO: Implement actual document processing\n        // This is a placeholder\n        tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n\n        Ok(uuid::Uuid::new_v4().to_string())\n    }\n\n    /// Get processing configuration\n    pub fn config(&self) -> &ProcessingConfig {\n        &self.config\n    }\n\n    /// Create a test instance for testing purposes\n    #[cfg(any(test, feature = \"test-utils\"))]\n    pub fn test_instance() -> Self {\n        let config = ProcessingConfig {\n            max_concurrent_tasks: 2,\n            default_chunk_size: 1000,\n            default_chunk_overlap: 200,\n            max_file_size_bytes: 1024 * 1024,\n            supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n            enable_lsp: false,\n            lsp_timeout_secs: 10,\n        };\n\n        let qdrant_config = QdrantConfig {\n            url: \"http://localhost:6333\".to_string(),\n            api_key: None,\n            timeout_secs: 30,\n            max_retries: 3,\n            default_collection: crate::config::CollectionConfig {\n                vector_size: 384,\n                distance_metric: \"Cosine\".to_string(),\n                enable_indexing: true,\n                replication_factor: 1,\n                shard_number: 1,\n            },\n        };\n\n        let semaphore = Arc::new(Semaphore::new(config.max_concurrent_tasks));\n\n        Self {\n            config,\n            qdrant_config,\n            semaphore,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{ProcessingConfig, QdrantConfig, CollectionConfig};\n    use std::sync::Arc;\n    use tracing_subscriber;\n\n    fn create_test_processing_config() -> ProcessingConfig {\n        ProcessingConfig {\n            max_concurrent_tasks: 2,\n            default_chunk_size: 1000,\n            default_chunk_overlap: 200,\n            max_file_size_bytes: 1024 * 1024,\n            supported_extensions: vec![\"rs\".to_string(), \"py\".to_string()],\n            enable_lsp: true,\n            lsp_timeout_secs: 10,\n        }\n    }\n\n    fn create_test_qdrant_config() -> QdrantConfig {\n        QdrantConfig {\n            url: \"http://localhost:6333\".to_string(),\n            api_key: None,\n            timeout_secs: 30,\n            max_retries: 3,\n            default_collection: CollectionConfig {\n                vector_size: 384,\n                distance_metric: \"Cosine\".to_string(),\n                enable_indexing: true,\n                replication_factor: 1,\n                shard_number: 1,\n            },\n        }\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_new() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        // Test that the processor was created successfully\n        assert_eq!(processor.config().max_concurrent_tasks, 2);\n        assert_eq!(processor.config().default_chunk_size, 1000);\n        assert_eq!(processor.config().default_chunk_overlap, 200);\n        assert_eq!(processor.config().max_file_size_bytes, 1024 * 1024);\n        assert!(processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 10);\n\n        // Test debug formatting\n        let debug_str = format!(\"{:?}\", processor);\n        assert!(debug_str.contains(\"DocumentProcessor\"));\n    }\n\n    #[tokio::test]\n    async fn test_process_document() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        let result = processor.process_document(\"test_file.rs\").await.unwrap();\n\n        // Should return a UUID string\n        assert_eq!(result.len(), 36); // UUID v4 string length\n        assert!(result.contains('-'));\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_processing() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .unwrap(),\n        );\n\n        let mut handles = vec![];\n\n        // Spawn multiple concurrent tasks\n        for i in 0..4 {\n            let processor_clone = Arc::clone(&processor);\n            let handle = tokio::spawn(async move {\n                processor_clone\n                    .process_document(&format!(\"test_file_{}.rs\", i))\n                    .await\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all tasks to complete\n        let results: Vec<_> = futures_util::future::join_all(handles).await;\n\n        // All tasks should complete successfully\n        for result in results {\n            let task_result = result.unwrap();\n            assert!(task_result.is_ok());\n            let uuid_str = task_result.unwrap();\n            assert_eq!(uuid_str.len(), 36);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_config_access() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        let config = processor.config();\n        assert_eq!(config.max_concurrent_tasks, 2);\n        assert_eq!(config.default_chunk_size, 1000);\n        assert_eq!(config.supported_extensions, vec![\"rs\", \"py\"]);\n    }\n\n    #[tokio::test]\n    async fn test_semaphore_limits() {\n        let mut processing_config = create_test_processing_config();\n        processing_config.max_concurrent_tasks = 1; // Allow only 1 concurrent task\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .unwrap(),\n        );\n\n        let start_time = std::time::Instant::now();\n\n        let processor1 = Arc::clone(&processor);\n        let processor2 = Arc::clone(&processor);\n\n        let handle1 = tokio::spawn(async move {\n            processor1.process_document(\"test1.rs\").await\n        });\n\n        let handle2 = tokio::spawn(async move {\n            processor2.process_document(\"test2.rs\").await\n        });\n\n        let (result1, result2) = tokio::join!(handle1, handle2);\n\n        // Both should succeed\n        assert!(result1.unwrap().is_ok());\n        assert!(result2.unwrap().is_ok());\n\n        // Should take at least 200ms due to semaphore limiting concurrency\n        let elapsed = start_time.elapsed();\n        assert!(elapsed >= std::time::Duration::from_millis(150));\n    }\n\n    #[tokio::test]\n    async fn test_processor_with_different_configs() {\n        let mut config1 = create_test_processing_config();\n        config1.max_concurrent_tasks = 1;\n        config1.default_chunk_size = 500;\n\n        let mut config2 = create_test_processing_config();\n        config2.max_concurrent_tasks = 5;\n        config2.default_chunk_size = 2000;\n\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor1 = DocumentProcessor::new(&config1, &qdrant_config)\n            .await\n            .unwrap();\n        let processor2 = DocumentProcessor::new(&config2, &qdrant_config)\n            .await\n            .unwrap();\n\n        assert_eq!(processor1.config().max_concurrent_tasks, 1);\n        assert_eq!(processor1.config().default_chunk_size, 500);\n\n        assert_eq!(processor2.config().max_concurrent_tasks, 5);\n        assert_eq!(processor2.config().default_chunk_size, 2000);\n    }\n\n    #[tokio::test]\n    async fn test_various_file_extensions() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        let test_files = vec![\n            \"test.rs\",\n            \"script.py\",\n            \"document.md\",\n            \"data.json\",\n            \"page.html\",\n        ];\n\n        for file in test_files {\n            let result = processor.process_document(file).await;\n            assert!(result.is_ok(), \"Failed to process file: {}\", file);\n            let uuid_str = result.unwrap();\n            assert_eq!(uuid_str.len(), 36);\n        }\n    }\n\n    #[test]\n    fn test_instance_creation() {\n        let processor = DocumentProcessor::test_instance();\n\n        // Test that test_instance creates processor with expected config\n        assert_eq!(processor.config().max_concurrent_tasks, 2);\n        assert_eq!(processor.config().default_chunk_size, 1000);\n        assert_eq!(processor.config().default_chunk_overlap, 200);\n        assert_eq!(processor.config().max_file_size_bytes, 1024 * 1024);\n        assert_eq!(processor.config().supported_extensions, vec![\"txt\", \"md\"]);\n        assert!(!processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 10);\n\n        // Test that qdrant_config is properly set\n        assert_eq!(processor.qdrant_config.url, \"http://localhost:6333\");\n        assert_eq!(processor.qdrant_config.api_key, None);\n        assert_eq!(processor.qdrant_config.timeout_secs, 30);\n        assert_eq!(processor.qdrant_config.max_retries, 3);\n        assert_eq!(processor.qdrant_config.default_collection.vector_size, 384);\n        assert_eq!(processor.qdrant_config.default_collection.distance_metric, \"Cosine\");\n        assert!(processor.qdrant_config.default_collection.enable_indexing);\n        assert_eq!(processor.qdrant_config.default_collection.replication_factor, 1);\n        assert_eq!(processor.qdrant_config.default_collection.shard_number, 1);\n    }\n\n    #[tokio::test]\n    async fn test_semaphore_error_handling() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        // Close the semaphore to force an error condition\n        processor.semaphore.close();\n\n        let result = processor.process_document(\"test_file.rs\").await;\n        assert!(result.is_err());\n\n        match result {\n            Err(DaemonError::Internal { message }) => {\n                assert!(message.contains(\"Semaphore error\"));\n            }\n            _ => panic!(\"Expected Internal error with semaphore message\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_process_document_uuid_generation() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        // Process multiple documents and ensure UUIDs are unique\n        let mut uuids = std::collections::HashSet::new();\n\n        for i in 0..10 {\n            let result = processor.process_document(&format!(\"test_{}.rs\", i)).await.unwrap();\n            assert_eq!(result.len(), 36);\n            assert!(result.contains('-'));\n\n            // Parse as UUID to ensure validity\n            let uuid = uuid::Uuid::parse_str(&result).unwrap();\n            assert_eq!(uuid.get_version_num(), 4); // UUID v4\n\n            // Ensure uniqueness\n            assert!(uuids.insert(result), \"UUID should be unique\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_processor_configuration_variants() {\n        // Test with minimal configuration\n        let minimal_config = ProcessingConfig {\n            max_concurrent_tasks: 1,\n            default_chunk_size: 100,\n            default_chunk_overlap: 0,\n            max_file_size_bytes: 1024,\n            supported_extensions: vec![],\n            enable_lsp: false,\n            lsp_timeout_secs: 1,\n        };\n\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&minimal_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        assert_eq!(processor.config().max_concurrent_tasks, 1);\n        assert_eq!(processor.config().default_chunk_size, 100);\n        assert_eq!(processor.config().default_chunk_overlap, 0);\n        assert_eq!(processor.config().max_file_size_bytes, 1024);\n        assert!(processor.config().supported_extensions.is_empty());\n        assert!(!processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 1);\n\n        // Test processing with minimal config\n        let result = processor.process_document(\"minimal_test.txt\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_processor_configuration_maximal() {\n        // Test with maximal configuration\n        let maximal_config = ProcessingConfig {\n            max_concurrent_tasks: 100,\n            default_chunk_size: 10000,\n            default_chunk_overlap: 2000,\n            max_file_size_bytes: 100 * 1024 * 1024, // 100MB\n            supported_extensions: vec![\n                \"rs\".to_string(), \"py\".to_string(), \"js\".to_string(),\n                \"ts\".to_string(), \"java\".to_string(), \"cpp\".to_string(),\n                \"c\".to_string(), \"h\".to_string(), \"hpp\".to_string(),\n                \"md\".to_string(), \"txt\".to_string(), \"json\".to_string(),\n            ],\n            enable_lsp: true,\n            lsp_timeout_secs: 60,\n        };\n\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&maximal_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        assert_eq!(processor.config().max_concurrent_tasks, 100);\n        assert_eq!(processor.config().default_chunk_size, 10000);\n        assert_eq!(processor.config().default_chunk_overlap, 2000);\n        assert_eq!(processor.config().max_file_size_bytes, 100 * 1024 * 1024);\n        assert_eq!(processor.config().supported_extensions.len(), 12);\n        assert!(processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 60);\n\n        // Test processing with maximal config\n        let result = processor.process_document(\"maximal_test.cpp\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_qdrant_config_variants() {\n        let processing_config = create_test_processing_config();\n\n        // Test with API key\n        let qdrant_with_key = QdrantConfig {\n            url: \"https://cloud.qdrant.io\".to_string(),\n            api_key: Some(\"test-api-key\".to_string()),\n            timeout_secs: 60,\n            max_retries: 5,\n            default_collection: CollectionConfig {\n                vector_size: 768,\n                distance_metric: \"Dot\".to_string(),\n                enable_indexing: false,\n                replication_factor: 2,\n                shard_number: 4,\n            },\n        };\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_with_key)\n            .await\n            .unwrap();\n\n        assert_eq!(processor.qdrant_config.url, \"https://cloud.qdrant.io\");\n        assert_eq!(processor.qdrant_config.api_key, Some(\"test-api-key\".to_string()));\n        assert_eq!(processor.qdrant_config.timeout_secs, 60);\n        assert_eq!(processor.qdrant_config.max_retries, 5);\n        assert_eq!(processor.qdrant_config.default_collection.vector_size, 768);\n        assert_eq!(processor.qdrant_config.default_collection.distance_metric, \"Dot\");\n        assert!(!processor.qdrant_config.default_collection.enable_indexing);\n        assert_eq!(processor.qdrant_config.default_collection.replication_factor, 2);\n        assert_eq!(processor.qdrant_config.default_collection.shard_number, 4);\n    }\n\n    #[tokio::test]\n    async fn test_debug_implementation() {\n        let processor = DocumentProcessor::test_instance();\n\n        let debug_str = format!(\"{:?}\", processor);\n        assert!(debug_str.contains(\"DocumentProcessor\"));\n        assert!(debug_str.contains(\"config\"));\n        assert!(debug_str.contains(\"qdrant_config\"));\n        assert!(debug_str.contains(\"semaphore\"));\n    }\n\n    #[tokio::test]\n    async fn test_empty_file_path() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        let result = processor.process_document(\"\").await;\n        assert!(result.is_ok()); // Should handle empty path gracefully\n        let uuid_str = result.unwrap();\n        assert_eq!(uuid_str.len(), 36);\n    }\n\n    #[tokio::test]\n    async fn test_very_long_file_path() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        // Create a very long file path\n        let long_path = \"a\".repeat(1000) + \".rs\";\n        let result = processor.process_document(&long_path).await;\n        assert!(result.is_ok()); // Should handle long paths gracefully\n        let uuid_str = result.unwrap();\n        assert_eq!(uuid_str.len(), 36);\n    }\n\n    #[tokio::test]\n    async fn test_special_characters_in_file_path() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        let special_paths = vec![\n            \"file with spaces.rs\",\n            \"file-with-dashes.py\",\n            \"file_with_underscores.md\",\n            \"file.with.dots.txt\",\n            \"file@with#special$chars%.json\",\n            \"file(with)parentheses.rs\",\n            \"file[with]brackets.py\",\n            \"file{with}braces.md\",\n        ];\n\n        for path in special_paths {\n            let result = processor.process_document(path).await;\n            assert!(result.is_ok(), \"Failed to process file: {}\", path);\n            let uuid_str = result.unwrap();\n            assert_eq!(uuid_str.len(), 36);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_unicode_file_paths() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        let unicode_paths = vec![\n            \"файл.rs\", // Russian\n            \"文件.py\", // Chinese\n            \"ファイル.md\", // Japanese\n            \"파일.txt\", // Korean\n            \"αρχείο.json\", // Greek\n            \"फ़ाइल.rs\", // Hindi\n            \"🚀rocket.py\", // Emoji\n        ];\n\n        for path in unicode_paths {\n            let result = processor.process_document(path).await;\n            assert!(result.is_ok(), \"Failed to process unicode file: {}\", path);\n            let uuid_str = result.unwrap();\n            assert_eq!(uuid_str.len(), 36);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_debug_logging_coverage() {\n        // This test ensures the debug! logging line is executed\n        // Initialize tracing subscriber to capture debug logs\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::DEBUG)\n            .try_init();\n\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        // This call will trigger the debug! statement on line 36\n        let result = processor.process_document(\"debug_test.rs\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_info_logging_coverage() {\n        // This test ensures the info! logging line is executed\n        // Initialize tracing subscriber to capture info logs\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::INFO)\n            .try_init();\n\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        // This call will trigger the info! statement on line 20\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        assert_eq!(processor.config().max_concurrent_tasks, 2);\n    }\n\n    #[tokio::test]\n    async fn test_complete_processing_pipeline() {\n        // Comprehensive test that exercises the complete processing pipeline\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        // Test processor creation (covers info! logging)\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .unwrap();\n\n        // Test configuration access\n        let config = processor.config();\n        assert!(config.enable_lsp);\n        assert_eq!(config.supported_extensions, vec![\"rs\", \"py\"]);\n\n        // Test document processing with various scenarios\n        let test_scenarios = vec![\n            (\"simple.rs\", \"Simple Rust file\"),\n            (\"\", \"Empty path\"),\n            (\"very/deep/nested/path/file.py\", \"Deeply nested path\"),\n            (\"file with spaces.md\", \"Path with spaces\"),\n            (\"αβγ.txt\", \"Unicode filename\"),\n        ];\n\n        for (path, description) in test_scenarios {\n            let result = processor.process_document(path).await;\n            assert!(result.is_ok(), \"Failed to process {}: {}\", description, path);\n\n            let uuid_str = result.unwrap();\n            assert_eq!(uuid_str.len(), 36, \"Invalid UUID length for {}\", description);\n\n            // Verify it's a valid UUID v4\n            let uuid = uuid::Uuid::parse_str(&uuid_str)\n                .expect(&format!(\"Invalid UUID format for {}\", description));\n            assert_eq!(uuid.get_version_num(), 4, \"Expected UUID v4 for {}\", description);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_processor_struct_fields() {\n        // Test to ensure all struct fields are properly initialized and accessible\n        let processor = DocumentProcessor::test_instance();\n\n        // Test config field\n        assert_eq!(processor.config.max_concurrent_tasks, 2);\n        assert_eq!(processor.config.default_chunk_size, 1000);\n        assert_eq!(processor.config.default_chunk_overlap, 200);\n        assert_eq!(processor.config.max_file_size_bytes, 1024 * 1024);\n        assert_eq!(processor.config.supported_extensions, vec![\"txt\", \"md\"]);\n        assert!(!processor.config.enable_lsp);\n        assert_eq!(processor.config.lsp_timeout_secs, 10);\n\n        // Test qdrant_config field\n        assert_eq!(processor.qdrant_config.url, \"http://localhost:6333\");\n        assert_eq!(processor.qdrant_config.api_key, None);\n        assert_eq!(processor.qdrant_config.timeout_secs, 30);\n        assert_eq!(processor.qdrant_config.max_retries, 3);\n        assert_eq!(processor.qdrant_config.default_collection.vector_size, 384);\n        assert_eq!(processor.qdrant_config.default_collection.distance_metric, \"Cosine\");\n        assert!(processor.qdrant_config.default_collection.enable_indexing);\n        assert_eq!(processor.qdrant_config.default_collection.replication_factor, 1);\n        assert_eq!(processor.qdrant_config.default_collection.shard_number, 1);\n\n        // Test semaphore field by verifying it works\n        let permit = processor.semaphore.acquire().await.unwrap();\n        drop(permit); // Release permit\n    }\n}","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":232}},{"line":20,"address":[],"length":0,"stats":{"Line":116}},{"line":22,"address":[],"length":0,"stats":{"Line":464}},{"line":24,"address":[],"length":0,"stats":{"Line":116}},{"line":25,"address":[],"length":0,"stats":{"Line":348}},{"line":26,"address":[],"length":0,"stats":{"Line":232}},{"line":27,"address":[],"length":0,"stats":{"Line":116}},{"line":32,"address":[],"length":0,"stats":{"Line":96}},{"line":33,"address":[],"length":0,"stats":{"Line":95}},{"line":34,"address":[],"length":0,"stats":{"Line":52}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":47}},{"line":46,"address":[],"length":0,"stats":{"Line":35}},{"line":47,"address":[],"length":0,"stats":{"Line":35}},{"line":52,"address":[],"length":0,"stats":{"Line":43}},{"line":57,"address":[],"length":0,"stats":{"Line":86}},{"line":58,"address":[],"length":0,"stats":{"Line":172}},{"line":64,"address":[],"length":0,"stats":{"Line":129}},{"line":68,"address":[],"length":0,"stats":{"Line":43}},{"line":77,"address":[],"length":0,"stats":{"Line":172}}],"covered":19,"coverable":20},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","daemon","state.rs"],"content":"//! Daemon state management using SQLite\n\nuse crate::config::DatabaseConfig;\nuse crate::error::{DaemonError, DaemonResult};\nuse sqlx::SqlitePool;\nuse tracing::{info, debug};\n\n/// Daemon state manager\n#[derive(Debug)]\npub struct DaemonState {\n    pool: SqlitePool,\n}\n\nimpl DaemonState {\n    /// Create a new state manager\n    pub async fn new(config: &DatabaseConfig) -> DaemonResult<Self> {\n        info!(\"Initializing database at: {}\", config.sqlite_path);\n\n        let pool = SqlitePool::connect(&config.sqlite_path).await?;\n\n        // Run migrations\n        Self::run_migrations(&pool).await?;\n\n        Ok(Self { pool })\n    }\n\n    /// Run database migrations\n    async fn run_migrations(pool: &SqlitePool) -> DaemonResult<()> {\n        debug!(\"Running database migrations\");\n\n        // Create projects table\n        sqlx::query(r#\"\n            CREATE TABLE IF NOT EXISTS projects (\n                id TEXT PRIMARY KEY,\n                name TEXT NOT NULL,\n                root_path TEXT NOT NULL UNIQUE,\n                git_repository TEXT,\n                git_branch TEXT,\n                metadata TEXT, -- JSON\n                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n            )\n        \"#)\n        .execute(pool)\n        .await?;\n\n        // Create collections table\n        sqlx::query(r#\"\n            CREATE TABLE IF NOT EXISTS collections (\n                id TEXT PRIMARY KEY,\n                name TEXT NOT NULL,\n                project_id TEXT NOT NULL,\n                config TEXT, -- JSON\n                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (project_id) REFERENCES projects (id),\n                UNIQUE (name, project_id)\n            )\n        \"#)\n        .execute(pool)\n        .await?;\n\n        // Create processing_operations table\n        sqlx::query(r#\"\n            CREATE TABLE IF NOT EXISTS processing_operations (\n                id TEXT PRIMARY KEY,\n                project_id TEXT,\n                status TEXT NOT NULL,\n                total_documents INTEGER DEFAULT 0,\n                processed_documents INTEGER DEFAULT 0,\n                failed_documents INTEGER DEFAULT 0,\n                error_messages TEXT, -- JSON array\n                started_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (project_id) REFERENCES projects (id)\n            )\n        \"#)\n        .execute(pool)\n        .await?;\n\n        info!(\"Database migrations completed\");\n        Ok(())\n    }\n\n    /// Get the connection pool\n    pub fn pool(&self) -> &SqlitePool {\n        &self.pool\n    }\n\n    /// Health check\n    pub async fn health_check(&self) -> DaemonResult<()> {\n        sqlx::query(\"SELECT 1\")\n            .execute(&self.pool)\n            .await?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use sqlx::Row;\n    use tokio::time::{timeout, Duration};\n\n    fn create_test_db_config() -> DatabaseConfig {\n        DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 1,\n            connection_timeout_secs: 5,\n            enable_wal: false,\n        }\n    }\n\n    fn create_test_db_config_with_wal() -> DatabaseConfig {\n        DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 5,\n            connection_timeout_secs: 10,\n            enable_wal: true,\n        }\n    }\n\n    #[tokio::test]\n    async fn test_daemon_state_new_basic() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Test that the state was created successfully\n        assert!(!state.pool().is_closed());\n\n        // Test debug formatting\n        let debug_str = format!(\"{:?}\", state);\n        assert!(debug_str.contains(\"DaemonState\"));\n    }\n\n    #[tokio::test]\n    async fn test_daemon_state_new_with_wal() {\n        let config = create_test_db_config_with_wal();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        assert!(!state.pool().is_closed());\n        state.health_check().await.unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_daemon_state_new_custom_config() {\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 3,\n            connection_timeout_secs: 15,\n            enable_wal: false,\n        };\n\n        let state = DaemonState::new(&config).await.unwrap();\n        assert!(!state.pool().is_closed());\n\n        // Verify logging by checking info! logs are called during initialization\n        // This tests the logging paths in the new() method\n    }\n\n    #[tokio::test]\n    async fn test_health_check_success() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Health check should pass\n        let result = state.health_check().await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_health_check_multiple_calls() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Multiple health checks should all pass\n        for _ in 0..5 {\n            state.health_check().await.unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_pool_access() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Pool should be accessible\n        let pool = state.pool();\n        assert!(!pool.is_closed());\n\n        // Test that we can use the pool reference\n        sqlx::query(\"SELECT 1\")\n            .execute(pool)\n            .await\n            .unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_migrations_create_all_tables() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Verify all tables were created by querying them\n        let projects_result = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' AND name='projects'\")\n            .fetch_optional(state.pool())\n            .await\n            .unwrap();\n        assert!(projects_result.is_some());\n\n        let collections_result = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' AND name='collections'\")\n            .fetch_optional(state.pool())\n            .await\n            .unwrap();\n        assert!(collections_result.is_some());\n\n        let processing_ops_result = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' AND name='processing_operations'\")\n            .fetch_optional(state.pool())\n            .await\n            .unwrap();\n        assert!(processing_ops_result.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_migrations_table_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Test projects table schema\n        let projects_schema = sqlx::query(\"PRAGMA table_info(projects)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n        assert!(!projects_schema.is_empty());\n\n        // Verify expected columns exist\n        let column_names: Vec<String> = projects_schema\n            .iter()\n            .map(|row| row.get::<String, _>(\"name\"))\n            .collect();\n        assert!(column_names.contains(&\"id\".to_string()));\n        assert!(column_names.contains(&\"name\".to_string()));\n        assert!(column_names.contains(&\"root_path\".to_string()));\n        assert!(column_names.contains(&\"git_repository\".to_string()));\n        assert!(column_names.contains(&\"metadata\".to_string()));\n        assert!(column_names.contains(&\"created_at\".to_string()));\n        assert!(column_names.contains(&\"updated_at\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_migrations_collections_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Test collections table schema\n        let collections_schema = sqlx::query(\"PRAGMA table_info(collections)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n        assert!(!collections_schema.is_empty());\n\n        let column_names: Vec<String> = collections_schema\n            .iter()\n            .map(|row| row.get::<String, _>(\"name\"))\n            .collect();\n        assert!(column_names.contains(&\"id\".to_string()));\n        assert!(column_names.contains(&\"name\".to_string()));\n        assert!(column_names.contains(&\"project_id\".to_string()));\n        assert!(column_names.contains(&\"config\".to_string()));\n        assert!(column_names.contains(&\"created_at\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_migrations_processing_operations_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Test processing_operations table schema\n        let processing_ops_schema = sqlx::query(\"PRAGMA table_info(processing_operations)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n        assert!(!processing_ops_schema.is_empty());\n\n        let column_names: Vec<String> = processing_ops_schema\n            .iter()\n            .map(|row| row.get::<String, _>(\"name\"))\n            .collect();\n        assert!(column_names.contains(&\"id\".to_string()));\n        assert!(column_names.contains(&\"project_id\".to_string()));\n        assert!(column_names.contains(&\"status\".to_string()));\n        assert!(column_names.contains(&\"total_documents\".to_string()));\n        assert!(column_names.contains(&\"processed_documents\".to_string()));\n        assert!(column_names.contains(&\"failed_documents\".to_string()));\n        assert!(column_names.contains(&\"error_messages\".to_string()));\n        assert!(column_names.contains(&\"started_at\".to_string()));\n        assert!(column_names.contains(&\"updated_at\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_migrations_foreign_keys() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Enable foreign key constraints\n        sqlx::query(\"PRAGMA foreign_keys = ON\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        // Test that foreign key constraints work\n        // First, insert a project\n        sqlx::query(\"INSERT INTO projects (id, name, root_path) VALUES ('test-project', 'Test Project', '/test')\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        // Then, insert a collection referencing the project\n        let result = sqlx::query(\"INSERT INTO collections (id, name, project_id) VALUES ('test-collection', 'Test Collection', 'test-project')\")\n            .execute(state.pool())\n            .await;\n        assert!(result.is_ok());\n\n        // Try inserting a collection with invalid project_id (should fail)\n        let invalid_result = sqlx::query(\"INSERT INTO collections (id, name, project_id) VALUES ('invalid-collection', 'Invalid Collection', 'nonexistent-project')\")\n            .execute(state.pool())\n            .await;\n        assert!(invalid_result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_migrations_unique_constraints() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Test unique constraint on projects.root_path\n        sqlx::query(\"INSERT INTO projects (id, name, root_path) VALUES ('project1', 'Project 1', '/same/path')\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        // Second insert with same root_path should fail\n        let duplicate_result = sqlx::query(\"INSERT INTO projects (id, name, root_path) VALUES ('project2', 'Project 2', '/same/path')\")\n            .execute(state.pool())\n            .await;\n        assert!(duplicate_result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_migrations_default_values() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Insert minimal data to test defaults\n        sqlx::query(\"INSERT INTO projects (id, name, root_path) VALUES ('minimal-project', 'Minimal Project', '/minimal')\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        // Verify default values are set\n        let row = sqlx::query(\"SELECT created_at, updated_at FROM projects WHERE id = 'minimal-project'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n\n        let created_at: String = row.get(\"created_at\");\n        let updated_at: String = row.get(\"updated_at\");\n        assert!(!created_at.is_empty());\n        assert!(!updated_at.is_empty());\n\n        // Test processing_operations defaults\n        sqlx::query(\"INSERT INTO processing_operations (id, status) VALUES ('test-op', 'running')\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        let op_row = sqlx::query(\"SELECT total_documents, processed_documents, failed_documents, started_at FROM processing_operations WHERE id = 'test-op'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n\n        let total_docs: i64 = op_row.get(\"total_documents\");\n        let processed_docs: i64 = op_row.get(\"processed_documents\");\n        let failed_docs: i64 = op_row.get(\"failed_documents\");\n        let started_at: String = op_row.get(\"started_at\");\n\n        assert_eq!(total_docs, 0);\n        assert_eq!(processed_docs, 0);\n        assert_eq!(failed_docs, 0);\n        assert!(!started_at.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_invalid_database_path() {\n        let config = DatabaseConfig {\n            sqlite_path: \"/invalid/path/db.sqlite\".to_string(),\n            max_connections: 1,\n            connection_timeout_secs: 5,\n            enable_wal: false,\n        };\n\n        let result = DaemonState::new(&config).await;\n        assert!(result.is_err());\n\n        // Verify it's a database error\n        match result {\n            Err(DaemonError::Database(_)) => {},\n            _ => panic!(\"Expected Database error for invalid path\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_run_migrations_directly() {\n        let config = create_test_db_config();\n        let pool = SqlitePool::connect(&config.sqlite_path).await.unwrap();\n\n        // Test migrations run successfully\n        let result = DaemonState::run_migrations(&pool).await;\n        assert!(result.is_ok());\n\n        // Test running migrations again (should be idempotent)\n        let result2 = DaemonState::run_migrations(&pool).await;\n        assert!(result2.is_ok());\n\n        // Verify tables exist after direct migration call\n        let tables = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\")\n            .fetch_all(&pool)\n            .await\n            .unwrap();\n\n        let table_names: Vec<String> = tables.iter().map(|row| row.get::<String, _>(\"name\")).collect();\n        assert!(table_names.contains(&\"projects\".to_string()));\n        assert!(table_names.contains(&\"collections\".to_string()));\n        assert!(table_names.contains(&\"processing_operations\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_run_migrations_logging() {\n        let config = create_test_db_config();\n        let pool = SqlitePool::connect(&config.sqlite_path).await.unwrap();\n\n        // This test ensures the debug! logging paths are covered\n        let result = DaemonState::run_migrations(&pool).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_database_config_variations() {\n        // Test various database configurations\n        let configs = vec![\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 1,\n                connection_timeout_secs: 5,\n                enable_wal: false,\n            },\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 10,\n                enable_wal: true,\n            },\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 10,\n                connection_timeout_secs: 30,\n                enable_wal: false,\n            },\n        ];\n\n        for config in configs {\n            let state = DaemonState::new(&config).await.unwrap();\n            state.health_check().await.unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_multiple_state_instances() {\n        let config1 = create_test_db_config();\n        let config2 = create_test_db_config();\n\n        let state1 = DaemonState::new(&config1).await.unwrap();\n        let state2 = DaemonState::new(&config2).await.unwrap();\n\n        // Both should be functional\n        state1.health_check().await.unwrap();\n        state2.health_check().await.unwrap();\n\n        // Test cross-state operations\n        assert!(!state1.pool().is_closed());\n        assert!(!state2.pool().is_closed());\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_health_checks() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Run multiple health checks concurrently\n        let futures = (0..10).map(|_| state.health_check()).collect::<Vec<_>>();\n        let results = futures_util::future::try_join_all(futures).await;\n        assert!(results.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_database_operations_after_init() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Test basic database operations work after initialization\n        let result = sqlx::query(\"INSERT INTO projects (id, name, root_path) VALUES ('test', 'Test Project', '/test/path')\")\n            .execute(state.pool())\n            .await;\n        assert!(result.is_ok());\n\n        let count: (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM projects\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n        assert_eq!(count.0, 1);\n    }\n\n    #[tokio::test]\n    async fn test_pool_state_after_operations() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Perform several database operations\n        for i in 0..5 {\n            sqlx::query(&format!(\"INSERT INTO projects (id, name, root_path) VALUES ('project{}', 'Project {}', '/path/{}')\", i, i, i))\n                .execute(state.pool())\n                .await\n                .unwrap();\n        }\n\n        // Pool should still be healthy\n        state.health_check().await.unwrap();\n        assert!(!state.pool().is_closed());\n    }\n\n    #[tokio::test]\n    async fn test_state_debug_formatting() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Test comprehensive debug formatting\n        let debug_str = format!(\"{:?}\", state);\n        assert!(debug_str.contains(\"DaemonState\"));\n        assert!(!debug_str.is_empty());\n\n        // Debug should not expose sensitive information\n        assert!(!debug_str.contains(\"password\"));\n        assert!(!debug_str.contains(\"secret\"));\n    }\n\n    #[tokio::test]\n    async fn test_health_check_error_recovery() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Verify health check works initially\n        state.health_check().await.unwrap();\n\n        // Pool should remain functional\n        assert!(!state.pool().is_closed());\n\n        // Multiple health checks should continue to work\n        for _ in 0..3 {\n            state.health_check().await.unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_database_config_edge_cases() {\n        // Test various edge case configurations\n        let edge_configs = vec![\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 1,  // Minimum connections\n                connection_timeout_secs: 1,  // Short timeout\n                enable_wal: false,\n            },\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 100,  // High connections\n                connection_timeout_secs: 300,  // Long timeout\n                enable_wal: true,\n            },\n        ];\n\n        for config in edge_configs {\n            let state = DaemonState::new(&config).await.unwrap();\n            state.health_check().await.unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_migration_logging_paths() {\n        let config = create_test_db_config();\n\n        // Create state to trigger migration logging\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Verify the state is functional (ensures logging didn't break anything)\n        state.health_check().await.unwrap();\n\n        // Test that pool is accessible after logging\n        let pool = state.pool();\n        assert!(!pool.is_closed());\n    }\n\n    #[tokio::test]\n    async fn test_error_handling_coverage() {\n        // Test various error scenarios to improve coverage\n\n        // Test with completely invalid path format\n        let bad_config = DatabaseConfig {\n            sqlite_path: \"invalid://path\".to_string(),\n            max_connections: 1,\n            connection_timeout_secs: 5,\n            enable_wal: false,\n        };\n\n        let result = DaemonState::new(&bad_config).await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_all_code_paths_covered() {\n        // This test aims to hit any remaining uncovered code paths\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Test all public methods\n        let pool_ref = state.pool();\n        assert!(!pool_ref.is_closed());\n\n        // Test health check multiple times\n        state.health_check().await.unwrap();\n        state.health_check().await.unwrap();\n\n        // Test debug formatting\n        let _debug = format!(\"{:?}\", state);\n\n        // Test with timeout to ensure async paths are covered\n        let health_result = timeout(Duration::from_secs(5), state.health_check()).await;\n        assert!(health_result.is_ok());\n        assert!(health_result.unwrap().is_ok());\n    }\n}","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":250}},{"line":17,"address":[],"length":0,"stats":{"Line":125}},{"line":19,"address":[],"length":0,"stats":{"Line":375}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":123}},{"line":28,"address":[],"length":0,"stats":{"Line":252}},{"line":29,"address":[],"length":0,"stats":{"Line":126}},{"line":44,"address":[],"length":0,"stats":{"Line":252}},{"line":45,"address":[],"length":0,"stats":{"Line":126}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":126}},{"line":85,"address":[],"length":0,"stats":{"Line":33}},{"line":86,"address":[],"length":0,"stats":{"Line":33}},{"line":90,"address":[],"length":0,"stats":{"Line":66}},{"line":91,"address":[],"length":0,"stats":{"Line":99}},{"line":92,"address":[],"length":0,"stats":{"Line":66}},{"line":93,"address":[],"length":0,"stats":{"Line":33}},{"line":94,"address":[],"length":0,"stats":{"Line":33}}],"covered":16,"coverable":19},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","daemon","watcher.rs"],"content":"//! File system watcher for automatic document processing\n\nuse crate::config::FileWatcherConfig;\nuse crate::daemon::processing::DocumentProcessor;\nuse crate::error::{DaemonError, DaemonResult};\nuse notify::{RecommendedWatcher, RecursiveMode, Event};\nuse std::sync::Arc;\nuse std::path::Path;\nuse tokio::sync::{mpsc, Mutex};\nuse tracing::{info, debug, warn, error};\n\n/// File watcher\n#[derive(Debug)]\npub struct FileWatcher {\n    config: FileWatcherConfig,\n    processor: Arc<DocumentProcessor>,\n    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n}\n\nimpl FileWatcher {\n    /// Create a new file watcher\n    pub async fn new(config: &FileWatcherConfig, processor: Arc<DocumentProcessor>) -> DaemonResult<Self> {\n        info!(\"Initializing file watcher (enabled: {})\", config.enabled);\n\n        Ok(Self {\n            config: config.clone(),\n            processor,\n            watcher: Arc::new(Mutex::new(None)),\n        })\n    }\n\n    /// Start watching for file changes\n    pub async fn start(&self) -> DaemonResult<()> {\n        if !self.config.enabled {\n            info!(\"File watcher is disabled\");\n            return Ok(());\n        }\n\n        info!(\"Starting file watcher\");\n\n        // TODO: Implement actual file watching\n        // This is a placeholder implementation\n\n        Ok(())\n    }\n\n    /// Stop watching for file changes\n    pub async fn stop(&self) -> DaemonResult<()> {\n        info!(\"Stopping file watcher\");\n\n        // TODO: Implement actual stop logic\n\n        Ok(())\n    }\n\n    /// Add a directory to watch\n    pub async fn watch_directory<P: AsRef<Path>>(&mut self, path: P) -> DaemonResult<()> {\n        let path = path.as_ref();\n        info!(\"Adding directory to watch: {}\", path.display());\n\n        // TODO: Implement actual directory watching\n\n        Ok(())\n    }\n\n    /// Remove a directory from watching\n    pub async fn unwatch_directory<P: AsRef<Path>>(&mut self, path: P) -> DaemonResult<()> {\n        let path = path.as_ref();\n        info!(\"Removing directory from watch: {}\", path.display());\n\n        // TODO: Implement actual directory unwatching\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{FileWatcherConfig, ProcessingConfig, QdrantConfig};\n    use tempfile::TempDir;\n    use std::path::PathBuf;\n    use std::sync::Arc;\n    use tokio_test;\n\n    fn create_test_config(enabled: bool) -> FileWatcherConfig {\n        FileWatcherConfig {\n            enabled,\n            debounce_ms: 100,\n            max_watched_dirs: 10,\n            ignore_patterns: vec![\"*.tmp\".to_string(), \"*.log\".to_string()],\n            recursive: true,\n        }\n    }\n\n    fn create_test_processor() -> Arc<DocumentProcessor> {\n        // Use test instance for reliable testing\n        Arc::new(DocumentProcessor::test_instance())\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_new_enabled() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let result = FileWatcher::new(&config, processor).await;\n        assert!(result.is_ok());\n\n        let watcher = result.unwrap();\n        assert_eq!(watcher.config.enabled, true);\n        assert_eq!(watcher.config.debounce_ms, 100);\n        assert_eq!(watcher.config.max_watched_dirs, 10);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_new_disabled() {\n        let config = create_test_config(false);\n        let processor = create_test_processor();\n\n        let result = FileWatcher::new(&config, processor).await;\n        assert!(result.is_ok());\n\n        let watcher = result.unwrap();\n        assert_eq!(watcher.config.enabled, false);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_debug_format() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n        let debug_str = format!(\"{:?}\", watcher);\n\n        assert!(debug_str.contains(\"FileWatcher\"));\n        assert!(debug_str.contains(\"config\"));\n        assert!(debug_str.contains(\"processor\"));\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_start_enabled() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n        let result = watcher.start().await;\n\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_start_disabled() {\n        let config = create_test_config(false);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n        let result = watcher.start().await;\n\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_stop() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // Start then stop\n        assert!(watcher.start().await.is_ok());\n        assert!(watcher.stop().await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_watch_directory() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        let temp_dir = TempDir::new().unwrap();\n        let result = watcher.watch_directory(temp_dir.path()).await;\n\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_watch_directory_string_path() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        let result = watcher.watch_directory(\"/tmp\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_unwatch_directory() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        let temp_dir = TempDir::new().unwrap();\n\n        // Watch then unwatch\n        assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n        assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_unwatch_directory_string_path() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        let result = watcher.unwatch_directory(\"/tmp\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_multiple_directories() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        let temp_dir1 = TempDir::new().unwrap();\n        let temp_dir2 = TempDir::new().unwrap();\n\n        // Watch multiple directories\n        assert!(watcher.watch_directory(temp_dir1.path()).await.is_ok());\n        assert!(watcher.watch_directory(temp_dir2.path()).await.is_ok());\n\n        // Unwatch them\n        assert!(watcher.unwatch_directory(temp_dir1.path()).await.is_ok());\n        assert!(watcher.unwatch_directory(temp_dir2.path()).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_start_stop_multiple_times() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // Multiple start/stop cycles\n        for _ in 0..3 {\n            assert!(watcher.start().await.is_ok());\n            assert!(watcher.stop().await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_config_clone() {\n        let config = create_test_config(true);\n        let config_clone = config.clone();\n\n        assert_eq!(config.enabled, config_clone.enabled);\n        assert_eq!(config.debounce_ms, config_clone.debounce_ms);\n        assert_eq!(config.max_watched_dirs, config_clone.max_watched_dirs);\n        assert_eq!(config.ignore_patterns, config_clone.ignore_patterns);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_processor_arc_sharing() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let processor_clone = Arc::clone(&processor);\n\n        let watcher = FileWatcher::new(&config, processor_clone).await.unwrap();\n\n        // Test that the processor Arc is properly shared\n        assert!(Arc::strong_count(&processor) >= 2);\n    }\n\n    #[test]\n    fn test_file_watcher_send_sync() {\n        fn assert_send<T: Send>() {}\n        fn assert_sync<T: Sync>() {}\n\n        assert_send::<FileWatcher>();\n        assert_sync::<FileWatcher>();\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_with_ignore_patterns() {\n        let mut config = create_test_config(true);\n        config.ignore_patterns = vec![\n            \"*.tmp\".to_string(),\n            \"*.log\".to_string(),\n            \"target/*\".to_string(),\n        ];\n\n        let processor = create_test_processor();\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        assert_eq!(watcher.config.ignore_patterns.len(), 3);\n        assert!(watcher.config.ignore_patterns.contains(&\"*.tmp\".to_string()));\n        assert!(watcher.config.ignore_patterns.contains(&\"*.log\".to_string()));\n        assert!(watcher.config.ignore_patterns.contains(&\"target/*\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_with_custom_debounce() {\n        let mut config = create_test_config(true);\n        config.debounce_ms = 1000;\n\n        let processor = create_test_processor();\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        assert_eq!(watcher.config.debounce_ms, 1000);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_with_edge_case_configs() {\n        // Test with zero debounce\n        let mut config = create_test_config(true);\n        config.debounce_ms = 0;\n        config.max_watched_dirs = 0;\n\n        let processor = create_test_processor();\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        assert_eq!(watcher.config.debounce_ms, 0);\n        assert_eq!(watcher.config.max_watched_dirs, 0);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_with_maximal_config() {\n        let mut config = create_test_config(true);\n        config.debounce_ms = u64::MAX;\n        config.max_watched_dirs = usize::MAX;\n        config.ignore_patterns = vec![\n            \"*.tmp\".to_string(),\n            \"*.log\".to_string(),\n            \"target/**\".to_string(),\n            \"node_modules/**\".to_string(),\n            \".git/**\".to_string(),\n            \"*.backup\".to_string(),\n            \"*.swp\".to_string(),\n            \"*~\".to_string(),\n        ];\n        config.recursive = true;\n\n        let processor = create_test_processor();\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        assert_eq!(watcher.config.debounce_ms, u64::MAX);\n        assert_eq!(watcher.config.max_watched_dirs, usize::MAX);\n        assert_eq!(watcher.config.ignore_patterns.len(), 8);\n        assert!(watcher.config.recursive);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_watcher_field_initialization() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // Verify the watcher field is properly initialized as None\n        let watcher_guard = watcher.watcher.lock().await;\n        assert!(watcher_guard.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_processor_field_access() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let processor_weak_count = Arc::weak_count(&processor);\n\n        let watcher = FileWatcher::new(&config, processor.clone()).await.unwrap();\n\n        // Verify processor is properly stored and accessible\n        assert!(Arc::ptr_eq(&watcher.processor, &processor));\n        assert!(Arc::weak_count(&processor) >= processor_weak_count);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_config_field_values() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // Verify all config fields are properly cloned and stored\n        assert_eq!(watcher.config.enabled, config.enabled);\n        assert_eq!(watcher.config.debounce_ms, config.debounce_ms);\n        assert_eq!(watcher.config.max_watched_dirs, config.max_watched_dirs);\n        assert_eq!(watcher.config.ignore_patterns, config.ignore_patterns);\n        assert_eq!(watcher.config.recursive, config.recursive);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_logging_levels() {\n        // Test that logging statements are executed by configuring tracing\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::DEBUG)\n            .try_init();\n\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        // This will trigger the info! logging on line 23\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // This will trigger the info! logging on line 39\n        assert!(watcher.start().await.is_ok());\n\n        // This will trigger the info! logging on line 49\n        assert!(watcher.stop().await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_disabled_logging() {\n        // Test the disabled path logging\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::INFO)\n            .try_init();\n\n        let config = create_test_config(false); // disabled\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // This will trigger the \"File watcher is disabled\" info! logging on line 35\n        assert!(watcher.start().await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_watch_directory_logging() {\n        // Test directory watching logging\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::INFO)\n            .try_init();\n\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        let temp_dir = TempDir::new().unwrap();\n\n        // This will trigger the info! logging on line 59\n        assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_unwatch_directory_logging() {\n        // Test directory unwatching logging\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::INFO)\n            .try_init();\n\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        let temp_dir = TempDir::new().unwrap();\n\n        // This will trigger the info! logging on line 69\n        assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_path_as_ref_implementations() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        let temp_dir = TempDir::new().unwrap();\n        let path_buf = temp_dir.path().to_path_buf();\n        let path_str = temp_dir.path().to_str().unwrap();\n\n        // Test different AsRef<Path> implementations\n        assert!(watcher.watch_directory(&path_buf).await.is_ok());\n        assert!(watcher.watch_directory(path_str).await.is_ok());\n        assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n\n        assert!(watcher.unwatch_directory(&path_buf).await.is_ok());\n        assert!(watcher.unwatch_directory(path_str).await.is_ok());\n        assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_complex_paths() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // Test complex path scenarios\n        let complex_paths = vec![\n            \"/tmp\",\n            \"/tmp/subdir\",\n            \"./relative/path\",\n            \"../parent/path\",\n            \"/path/with spaces/dir\",\n            \"/path/with-dashes/dir\",\n            \"/path/with_underscores/dir\",\n            \"/path/with.dots/dir\",\n        ];\n\n        for path in complex_paths {\n            assert!(watcher.watch_directory(path).await.is_ok());\n            assert!(watcher.unwatch_directory(path).await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_unicode_paths() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        let unicode_paths = vec![\n            \"/tmp/русский\",     // Russian\n            \"/tmp/中文\",         // Chinese\n            \"/tmp/日本語\",       // Japanese\n            \"/tmp/한국어\",       // Korean\n            \"/tmp/ελληνικά\",    // Greek\n            \"/tmp/हिन्दी\",      // Hindi\n            \"/tmp/🚀rocket\",     // Emoji\n        ];\n\n        for path in unicode_paths {\n            assert!(watcher.watch_directory(path).await.is_ok());\n            assert!(watcher.unwatch_directory(path).await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_empty_path() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // Test empty path\n        assert!(watcher.watch_directory(\"\").await.is_ok());\n        assert!(watcher.unwatch_directory(\"\").await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_very_long_path() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // Test very long path\n        let long_path = format!(\"/tmp/{}\", \"a\".repeat(1000));\n        assert!(watcher.watch_directory(&long_path).await.is_ok());\n        assert!(watcher.unwatch_directory(&long_path).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_rapid_operations() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // Test rapid start/stop operations\n        for _ in 0..10 {\n            assert!(watcher.start().await.is_ok());\n            assert!(watcher.stop().await.is_ok());\n        }\n\n        // Test rapid watch/unwatch operations\n        let temp_dir = TempDir::new().unwrap();\n        for _ in 0..10 {\n            assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n            assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_concurrent_operations() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let watcher = Arc::new(Mutex::new(\n            FileWatcher::new(&config, processor).await.unwrap()\n        ));\n\n        let mut handles = vec![];\n\n        // Spawn concurrent start/stop operations\n        for i in 0..5 {\n            let watcher_clone = Arc::clone(&watcher);\n            let handle = tokio::spawn(async move {\n                let watcher = watcher_clone.lock().await;\n                if i % 2 == 0 {\n                    watcher.start().await\n                } else {\n                    watcher.stop().await\n                }\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all operations to complete\n        let results = futures_util::future::join_all(handles).await;\n\n        // All operations should succeed\n        for result in results {\n            assert!(result.unwrap().is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_concurrent_directory_operations() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let watcher = Arc::new(Mutex::new(\n            FileWatcher::new(&config, processor).await.unwrap()\n        ));\n\n        let temp_dirs: Vec<_> = (0..5).map(|_| TempDir::new().unwrap()).collect();\n        let mut handles = vec![];\n\n        // Spawn concurrent watch operations\n        for (i, temp_dir) in temp_dirs.iter().enumerate() {\n            let watcher_clone = Arc::clone(&watcher);\n            let path = temp_dir.path().to_path_buf();\n            let handle = tokio::spawn(async move {\n                let mut watcher = watcher_clone.lock().await;\n                if i % 2 == 0 {\n                    watcher.watch_directory(&path).await\n                } else {\n                    watcher.unwatch_directory(&path).await\n                }\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all operations to complete\n        let results = futures_util::future::join_all(handles).await;\n\n        // All operations should succeed\n        for result in results {\n            assert!(result.unwrap().is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_stress_test() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // Stress test with many operations\n        let temp_dirs: Vec<_> = (0..50).map(|_| TempDir::new().unwrap()).collect();\n\n        // Watch all directories\n        for temp_dir in &temp_dirs {\n            assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n        }\n\n        // Multiple start/stop cycles\n        for _ in 0..20 {\n            assert!(watcher.start().await.is_ok());\n            assert!(watcher.stop().await.is_ok());\n        }\n\n        // Unwatch all directories\n        for temp_dir in &temp_dirs {\n            assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_all_config_combinations() {\n        let processor = create_test_processor();\n\n        // Test all boolean combinations\n        let config_combinations = vec![\n            (true, true),   // enabled, recursive\n            (true, false),  // enabled, not recursive\n            (false, true),  // disabled, recursive\n            (false, false), // disabled, not recursive\n        ];\n\n        for (enabled, recursive) in config_combinations {\n            let mut config = create_test_config(enabled);\n            config.recursive = recursive;\n\n            let watcher = FileWatcher::new(&config, processor.clone()).await.unwrap();\n\n            assert_eq!(watcher.config.enabled, enabled);\n            assert_eq!(watcher.config.recursive, recursive);\n\n            // Test that all operations work regardless of config\n            assert!(watcher.start().await.is_ok());\n            assert!(watcher.stop().await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_config_boundary_values() {\n        let processor = create_test_processor();\n\n        // Test boundary values for numeric fields\n        let boundary_configs = vec![\n            (0, 0),                    // minimum values\n            (1, 1),                    // just above minimum\n            (u64::MAX, usize::MAX),    // maximum values\n            (1000, 100),               // typical values\n        ];\n\n        for (debounce_ms, max_watched_dirs) in boundary_configs {\n            let mut config = create_test_config(true);\n            config.debounce_ms = debounce_ms;\n            config.max_watched_dirs = max_watched_dirs;\n\n            let watcher = FileWatcher::new(&config, processor.clone()).await.unwrap();\n\n            assert_eq!(watcher.config.debounce_ms, debounce_ms);\n            assert_eq!(watcher.config.max_watched_dirs, max_watched_dirs);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_ignore_patterns_variations() {\n        let processor = create_test_processor();\n\n        let pattern_variations = vec![\n            vec![], // empty patterns\n            vec![\"*.tmp\".to_string()], // single pattern\n            vec![\"*.tmp\".to_string(), \"*.log\".to_string()], // multiple patterns\n            vec![\n                \"*.tmp\".to_string(),\n                \"*.log\".to_string(),\n                \"target/**\".to_string(),\n                \"node_modules/**\".to_string(),\n                \".git/**\".to_string(),\n                \"*.backup\".to_string(),\n                \"*.swp\".to_string(),\n                \"*~\".to_string(),\n                \"*.cache\".to_string(),\n                \".DS_Store\".to_string(),\n            ], // many patterns\n        ];\n\n        for patterns in pattern_variations {\n            let mut config = create_test_config(true);\n            config.ignore_patterns = patterns.clone();\n\n            let watcher = FileWatcher::new(&config, processor.clone()).await.unwrap();\n\n            assert_eq!(watcher.config.ignore_patterns, patterns);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_comprehensive_api_coverage() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        // Test the complete API surface\n        let temp_dir = TempDir::new().unwrap();\n\n        // Test all public methods in sequence\n        assert!(watcher.start().await.is_ok());\n        assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n        assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n        assert!(watcher.stop().await.is_ok());\n\n        // Test methods multiple times to ensure state consistency\n        for _ in 0..3 {\n            assert!(watcher.start().await.is_ok());\n            assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n            assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n            assert!(watcher.stop().await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_memory_safety() {\n        // Test that dropping components doesn't cause issues\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        {\n            let watcher = FileWatcher::new(&config, processor.clone()).await.unwrap();\n            assert!(watcher.start().await.is_ok());\n            // watcher is dropped here\n        }\n\n        // Processor should still be valid\n        assert_eq!(processor.config().max_concurrent_tasks, 2);\n\n        // Create another watcher with the same processor\n        let mut watcher2 = FileWatcher::new(&config, processor).await.unwrap();\n        assert!(watcher2.start().await.is_ok());\n        assert!(watcher2.stop().await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_struct_debug_format_completeness() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n        let debug_output = format!(\"{:?}\", watcher);\n\n        // Verify debug output contains all expected field names\n        assert!(debug_output.contains(\"FileWatcher\"));\n        assert!(debug_output.contains(\"config\"));\n        assert!(debug_output.contains(\"processor\"));\n        assert!(debug_output.contains(\"watcher\"));\n\n        // Verify debug output contains some config values\n        assert!(debug_output.contains(\"enabled\"));\n        assert!(debug_output.contains(\"debounce_ms\"));\n    }\n\n    #[test]\n    fn test_file_watcher_trait_implementations() {\n        // Verify required trait implementations\n        fn assert_debug<T: std::fmt::Debug>() {}\n        fn assert_send<T: Send>() {}\n        fn assert_sync<T: Sync>() {}\n\n        assert_debug::<FileWatcher>();\n        assert_send::<FileWatcher>();\n        assert_sync::<FileWatcher>();\n\n        // Test that the type can be used in various contexts\n        fn _takes_debug(_: impl std::fmt::Debug) {}\n        fn _takes_send(_: impl Send) {}\n        fn _takes_sync(_: impl Sync) {}\n\n        let config = FileWatcherConfig {\n            enabled: true,\n            debounce_ms: 100,\n            max_watched_dirs: 10,\n            ignore_patterns: vec![],\n            recursive: true,\n        };\n        let processor = Arc::new(DocumentProcessor::test_instance());\n\n        // This would be tested in a tokio context, but we're testing trait bounds here\n        // let watcher = FileWatcher::new(&config, processor).await.unwrap();\n        // _takes_debug(watcher);\n        // _takes_send(watcher);\n        // _takes_sync(watcher);\n    }\n}","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":104}},{"line":23,"address":[],"length":0,"stats":{"Line":52}},{"line":25,"address":[],"length":0,"stats":{"Line":52}},{"line":26,"address":[],"length":0,"stats":{"Line":156}},{"line":27,"address":[],"length":0,"stats":{"Line":104}},{"line":28,"address":[],"length":0,"stats":{"Line":104}},{"line":33,"address":[],"length":0,"stats":{"Line":104}},{"line":34,"address":[],"length":0,"stats":{"Line":52}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":48}},{"line":44,"address":[],"length":0,"stats":{"Line":48}},{"line":48,"address":[],"length":0,"stats":{"Line":94}},{"line":49,"address":[],"length":0,"stats":{"Line":47}},{"line":53,"address":[],"length":0,"stats":{"Line":47}},{"line":57,"address":[],"length":0,"stats":{"Line":186}},{"line":58,"address":[],"length":0,"stats":{"Line":279}},{"line":59,"address":[],"length":0,"stats":{"Line":93}},{"line":63,"address":[],"length":0,"stats":{"Line":93}},{"line":67,"address":[],"length":0,"stats":{"Line":182}},{"line":68,"address":[],"length":0,"stats":{"Line":273}},{"line":69,"address":[],"length":0,"stats":{"Line":91}},{"line":73,"address":[],"length":0,"stats":{"Line":91}}],"covered":22,"coverable":22},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","error.rs"],"content":"//! Error types for the Workspace Qdrant Daemon\n\nuse thiserror::Error;\nuse tonic::{Code, Status};\n\n/// Main error type for daemon operations\n#[derive(Error, Debug)]\npub enum DaemonError {\n    #[error(\"Configuration error: {0}\")]\n    Config(#[from] config::ConfigError),\n\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n\n    #[error(\"I/O error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"gRPC error: {0}\")]\n    Grpc(#[from] tonic::transport::Error),\n\n    #[error(\"Serialization error: {0}\")]\n    Serialization(#[from] serde_json::Error),\n\n    #[error(\"File watching error: {0}\")]\n    FileWatcher(#[from] notify::Error),\n\n    #[error(\"Git error: {0}\")]\n    Git(#[from] git2::Error),\n\n    #[error(\"HTTP client error: {0}\")]\n    Http(#[from] reqwest::Error),\n\n    #[error(\"Document processing error: {message}\")]\n    DocumentProcessing { message: String },\n\n    #[error(\"Search error: {message}\")]\n    Search { message: String },\n\n    #[error(\"Memory management error: {message}\")]\n    Memory { message: String },\n\n    #[error(\"System error: {message}\")]\n    System { message: String },\n\n    #[error(\"Project detection error: {message}\")]\n    ProjectDetection { message: String },\n\n    #[error(\"Connection pool error: {message}\")]\n    ConnectionPool { message: String },\n\n    #[error(\"Timeout error: operation timed out after {seconds}s\")]\n    Timeout { seconds: u64 },\n\n    #[error(\"Resource not found: {resource}\")]\n    NotFound { resource: String },\n\n    #[error(\"Invalid input: {message}\")]\n    InvalidInput { message: String },\n\n    #[error(\"Internal error: {message}\")]\n    Internal { message: String },\n}\n\nimpl From<DaemonError> for Status {\n    fn from(err: DaemonError) -> Self {\n        match err {\n            DaemonError::Config(_) | DaemonError::InvalidInput { .. } => {\n                Status::new(Code::InvalidArgument, err.to_string())\n            },\n            DaemonError::NotFound { .. } => {\n                Status::new(Code::NotFound, err.to_string())\n            },\n            DaemonError::Timeout { .. } => {\n                Status::new(Code::DeadlineExceeded, err.to_string())\n            },\n            DaemonError::Database(_) | DaemonError::Io(_) | DaemonError::FileWatcher(_) => {\n                Status::new(Code::Internal, \"Internal server error\")\n            },\n            _ => Status::new(Code::Internal, \"Internal server error\"),\n        }\n    }\n}\n\n/// Result type alias for daemon operations\npub type DaemonResult<T> = Result<T, DaemonError>;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::{Error, ErrorKind};\n\n    #[test]\n    fn test_daemon_error_display() {\n        let err = DaemonError::DocumentProcessing {\n            message: \"Test error\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Document processing error: Test error\");\n\n        let err = DaemonError::Search {\n            message: \"Search failed\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Search error: Search failed\");\n\n        let err = DaemonError::Memory {\n            message: \"Memory allocation failed\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Memory management error: Memory allocation failed\");\n\n        let err = DaemonError::System {\n            message: \"System call failed\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"System error: System call failed\");\n\n        let err = DaemonError::ProjectDetection {\n            message: \"No git repository found\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Project detection error: No git repository found\");\n\n        let err = DaemonError::ConnectionPool {\n            message: \"Pool exhausted\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Connection pool error: Pool exhausted\");\n\n        let err = DaemonError::Timeout { seconds: 30 };\n        assert_eq!(format!(\"{}\", err), \"Timeout error: operation timed out after 30s\");\n\n        let err = DaemonError::NotFound {\n            resource: \"document\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Resource not found: document\");\n\n        let err = DaemonError::InvalidInput {\n            message: \"Invalid format\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Invalid input: Invalid format\");\n\n        let err = DaemonError::Internal {\n            message: \"Unexpected state\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Internal error: Unexpected state\");\n    }\n\n    #[test]\n    fn test_daemon_error_debug() {\n        let err = DaemonError::DocumentProcessing {\n            message: \"Test error\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", err);\n        assert!(debug_str.contains(\"DocumentProcessing\"));\n        assert!(debug_str.contains(\"Test error\"));\n    }\n\n    #[test]\n    fn test_daemon_error_from_io_error() {\n        let io_error = Error::new(ErrorKind::NotFound, \"File not found\");\n        let daemon_error: DaemonError = io_error.into();\n\n        match daemon_error {\n            DaemonError::Io(ref e) => {\n                assert_eq!(e.kind(), ErrorKind::NotFound);\n                assert_eq!(e.to_string(), \"File not found\");\n            },\n            _ => panic!(\"Expected DaemonError::Io\"),\n        }\n    }\n\n    #[test]\n    fn test_daemon_error_from_serde_json_error() {\n        let json_error = serde_json::from_str::<serde_json::Value>(\"invalid json\")\n            .unwrap_err();\n        let daemon_error: DaemonError = json_error.into();\n\n        match daemon_error {\n            DaemonError::Serialization(_) => {\n                // Success - correct variant\n            },\n            _ => panic!(\"Expected DaemonError::Serialization\"),\n        }\n    }\n\n    #[test]\n    fn test_status_conversion_invalid_argument() {\n        let err = DaemonError::InvalidInput {\n            message: \"Bad request\".to_string(),\n        };\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::InvalidArgument);\n        assert!(status.message().contains(\"Invalid input: Bad request\"));\n\n        let err = DaemonError::Config(config::ConfigError::Message(\"Config parse error\".to_string()));\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::InvalidArgument);\n    }\n\n    #[test]\n    fn test_status_conversion_not_found() {\n        let err = DaemonError::NotFound {\n            resource: \"user\".to_string(),\n        };\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::NotFound);\n        assert!(status.message().contains(\"Resource not found: user\"));\n    }\n\n    #[test]\n    fn test_status_conversion_deadline_exceeded() {\n        let err = DaemonError::Timeout { seconds: 60 };\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::DeadlineExceeded);\n        assert!(status.message().contains(\"operation timed out after 60s\"));\n    }\n\n    #[test]\n    fn test_status_conversion_internal_error() {\n        let io_error = Error::new(ErrorKind::PermissionDenied, \"Access denied\");\n        let err = DaemonError::Io(io_error);\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::Internal);\n        assert_eq!(status.message(), \"Internal server error\");\n\n        let err = DaemonError::Database(sqlx::Error::PoolClosed);\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::Internal);\n        assert_eq!(status.message(), \"Internal server error\");\n\n        let err = DaemonError::DocumentProcessing {\n            message: \"Processing failed\".to_string(),\n        };\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::Internal);\n        assert_eq!(status.message(), \"Internal server error\");\n    }\n\n    #[test]\n    fn test_daemon_result_type() {\n        let success: DaemonResult<i32> = Ok(42);\n        assert_eq!(success.unwrap(), 42);\n\n        let error: DaemonResult<i32> = Err(DaemonError::Internal {\n            message: \"Test error\".to_string(),\n        });\n        assert!(error.is_err());\n    }\n\n    #[test]\n    fn test_error_chain() {\n        let io_error = Error::new(ErrorKind::NotFound, \"File not found\");\n        let daemon_error = DaemonError::Io(io_error);\n\n        let error_string = format!(\"{}\", daemon_error);\n        assert!(error_string.contains(\"I/O error:\"));\n        assert!(error_string.contains(\"File not found\"));\n    }\n\n    #[test]\n    fn test_all_error_variants_are_testable() {\n        // Test that we can create all error variants\n        let errors = vec![\n            DaemonError::DocumentProcessing { message: \"test\".to_string() },\n            DaemonError::Search { message: \"test\".to_string() },\n            DaemonError::Memory { message: \"test\".to_string() },\n            DaemonError::System { message: \"test\".to_string() },\n            DaemonError::ProjectDetection { message: \"test\".to_string() },\n            DaemonError::ConnectionPool { message: \"test\".to_string() },\n            DaemonError::Timeout { seconds: 10 },\n            DaemonError::NotFound { resource: \"test\".to_string() },\n            DaemonError::InvalidInput { message: \"test\".to_string() },\n            DaemonError::Internal { message: \"test\".to_string() },\n        ];\n\n        for error in errors {\n            // Each error should be debuggable\n            let debug_str = format!(\"{:?}\", error);\n            assert!(!debug_str.is_empty());\n\n            // Each error should be displayable\n            let display_str = format!(\"{}\", error);\n            assert!(!display_str.is_empty());\n\n            // Each error should convert to Status\n            let _status: Status = error.into();\n        }\n    }\n\n    #[test]\n    fn test_error_source_chain() {\n        let io_error = Error::new(ErrorKind::NotFound, \"File not found\");\n        let daemon_error = DaemonError::Io(io_error);\n\n        // Test that the source chain is preserved\n        let source = std::error::Error::source(&daemon_error);\n        assert!(source.is_some());\n\n        if let Some(source) = source {\n            assert_eq!(source.to_string(), \"File not found\");\n        }\n    }\n}","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":17}},{"line":66,"address":[],"length":0,"stats":{"Line":17}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":8}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":16}}],"covered":7,"coverable":7},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","grpc","middleware.rs"],"content":"//! gRPC middleware for connection management, metrics, and security\n\nuse std::time::{Duration, Instant};\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, info, warn};\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse dashmap::DashMap;\nuse parking_lot::RwLock;\n\n/// Connection tracking and management\n#[derive(Debug)]\npub struct ConnectionManager {\n    /// Active connections count\n    active_connections: AtomicU64,\n\n    /// Maximum allowed connections\n    max_connections: u64,\n\n    /// Connection metadata by client ID\n    connections: Arc<DashMap<String, ConnectionInfo>>,\n\n    /// Rate limiting state\n    rate_limiter: Arc<RwLock<RateLimiter>>,\n}\n\n#[derive(Debug)]\npub struct ConnectionInfo {\n    pub client_id: String,\n    pub connected_at: Instant,\n    pub last_activity: Instant,\n    pub request_count: AtomicU64,\n    pub bytes_sent: AtomicU64,\n    pub bytes_received: AtomicU64,\n}\n\nimpl Clone for ConnectionInfo {\n    fn clone(&self) -> Self {\n        Self {\n            client_id: self.client_id.clone(),\n            connected_at: self.connected_at,\n            last_activity: self.last_activity,\n            request_count: AtomicU64::new(self.request_count.load(Ordering::SeqCst)),\n            bytes_sent: AtomicU64::new(self.bytes_sent.load(Ordering::SeqCst)),\n            bytes_received: AtomicU64::new(self.bytes_received.load(Ordering::SeqCst)),\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct RateLimiter {\n    /// Requests per second limit per client\n    requests_per_second: u32,\n\n    /// Client request tracking\n    client_requests: DashMap<String, Vec<Instant>>,\n\n    /// Cleanup interval\n    last_cleanup: Instant,\n}\n\nimpl ConnectionManager {\n    pub fn new(max_connections: u64, requests_per_second: u32) -> Self {\n        Self {\n            active_connections: AtomicU64::new(0),\n            max_connections,\n            connections: Arc::new(DashMap::new()),\n            rate_limiter: Arc::new(RwLock::new(RateLimiter {\n                requests_per_second,\n                client_requests: DashMap::new(),\n                last_cleanup: Instant::now(),\n            })),\n        }\n    }\n\n    /// Register a new connection\n    pub fn register_connection(&self, client_id: String) -> Result<(), Status> {\n        let current_connections = self.active_connections.load(Ordering::SeqCst);\n\n        if current_connections >= self.max_connections {\n            warn!(\"Connection limit reached: {}/{}\", current_connections, self.max_connections);\n            return Err(Status::resource_exhausted(\"Connection limit reached\"));\n        }\n\n        let connection_info = ConnectionInfo {\n            client_id: client_id.clone(),\n            connected_at: Instant::now(),\n            last_activity: Instant::now(),\n            request_count: AtomicU64::new(0),\n            bytes_sent: AtomicU64::new(0),\n            bytes_received: AtomicU64::new(0),\n        };\n\n        self.connections.insert(client_id.clone(), connection_info);\n        self.active_connections.fetch_add(1, Ordering::SeqCst);\n\n        info!(\"Connection registered: {} (total: {})\", client_id, current_connections + 1);\n        Ok(())\n    }\n\n    /// Unregister a connection\n    pub fn unregister_connection(&self, client_id: &str) {\n        if self.connections.remove(client_id).is_some() {\n            let remaining = self.active_connections.fetch_sub(1, Ordering::SeqCst) - 1;\n            info!(\"Connection unregistered: {} (remaining: {})\", client_id, remaining);\n        }\n\n        // Clean up rate limiter tracking\n        self.rate_limiter.read().client_requests.remove(client_id);\n    }\n\n    /// Check if request is rate limited\n    pub fn check_rate_limit(&self, client_id: &str) -> Result<(), Status> {\n        let mut rate_limiter = self.rate_limiter.write();\n\n        // Cleanup old entries periodically\n        let now = Instant::now();\n        if now.duration_since(rate_limiter.last_cleanup) > Duration::from_secs(60) {\n            self.cleanup_rate_limiter(&mut rate_limiter, now);\n            rate_limiter.last_cleanup = now;\n        }\n\n        // Get or create client request history\n        let mut requests = rate_limiter.client_requests\n            .entry(client_id.to_string())\n            .or_insert_with(Vec::new)\n            .clone();\n\n        // Remove requests older than 1 second\n        requests.retain(|&timestamp| now.duration_since(timestamp) < Duration::from_secs(1));\n\n        // Check if rate limit exceeded\n        if requests.len() >= rate_limiter.requests_per_second as usize {\n            warn!(\"Rate limit exceeded for client: {}\", client_id);\n            return Err(Status::resource_exhausted(\"Rate limit exceeded\"));\n        }\n\n        // Add current request\n        requests.push(now);\n        rate_limiter.client_requests.insert(client_id.to_string(), requests);\n\n        Ok(())\n    }\n\n    /// Update connection activity\n    pub fn update_activity(&self, client_id: &str, bytes_sent: u64, bytes_received: u64) {\n        if let Some(mut connection) = self.connections.get_mut(client_id) {\n            connection.last_activity = Instant::now();\n            connection.request_count.fetch_add(1, Ordering::SeqCst);\n            connection.bytes_sent.fetch_add(bytes_sent, Ordering::SeqCst);\n            connection.bytes_received.fetch_add(bytes_received, Ordering::SeqCst);\n        }\n    }\n\n    /// Get connection statistics\n    pub fn get_stats(&self) -> ConnectionStats {\n        let active_count = self.active_connections.load(Ordering::SeqCst);\n        let total_requests: u64 = self.connections\n            .iter()\n            .map(|entry| entry.request_count.load(Ordering::SeqCst))\n            .sum();\n        let total_bytes_sent: u64 = self.connections\n            .iter()\n            .map(|entry| entry.bytes_sent.load(Ordering::SeqCst))\n            .sum();\n        let total_bytes_received: u64 = self.connections\n            .iter()\n            .map(|entry| entry.bytes_received.load(Ordering::SeqCst))\n            .sum();\n\n        ConnectionStats {\n            active_connections: active_count,\n            max_connections: self.max_connections,\n            total_requests,\n            total_bytes_sent,\n            total_bytes_received,\n        }\n    }\n\n    /// Cleanup expired connections\n    pub fn cleanup_expired_connections(&self, timeout: Duration) {\n        let now = Instant::now();\n        let mut expired_clients = Vec::new();\n\n        for entry in self.connections.iter() {\n            if now.duration_since(entry.last_activity) > timeout {\n                expired_clients.push(entry.client_id.clone());\n            }\n        }\n\n        for client_id in expired_clients {\n            self.unregister_connection(&client_id);\n            warn!(\"Expired connection cleaned up: {}\", client_id);\n        }\n    }\n\n    fn cleanup_rate_limiter(&self, rate_limiter: &mut RateLimiter, now: Instant) {\n        let cutoff = now - Duration::from_secs(60);\n\n        // Remove old client tracking data\n        rate_limiter.client_requests.retain(|_client_id, requests| {\n            requests.retain(|&timestamp| timestamp > cutoff);\n            !requests.is_empty()\n        });\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct ConnectionStats {\n    pub active_connections: u64,\n    pub max_connections: u64,\n    pub total_requests: u64,\n    pub total_bytes_sent: u64,\n    pub total_bytes_received: u64,\n}\n\n/// Connection pool for outbound connections (to Qdrant, etc.)\npub struct ConnectionPool<T: deadpool::managed::Manager> {\n    pool: deadpool::managed::Pool<T>,\n    config: PoolConfig,\n}\n\nimpl<T: deadpool::managed::Manager> std::fmt::Debug for ConnectionPool<T> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"ConnectionPool\")\n            .field(\"config\", &self.config)\n            .finish_non_exhaustive()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct PoolConfig {\n    pub max_size: usize,\n    pub min_idle: Option<usize>,\n    pub max_lifetime: Option<Duration>,\n    pub idle_timeout: Option<Duration>,\n    pub connection_timeout: Duration,\n}\n\nimpl Default for PoolConfig {\n    fn default() -> Self {\n        Self {\n            max_size: 10,\n            min_idle: Some(2),\n            max_lifetime: Some(Duration::from_secs(3600)), // 1 hour\n            idle_timeout: Some(Duration::from_secs(600)),   // 10 minutes\n            connection_timeout: Duration::from_secs(30),\n        }\n    }\n}\n\n/// Middleware interceptor for connection management\n#[derive(Debug, Clone)]\npub struct ConnectionInterceptor {\n    connection_manager: Arc<ConnectionManager>,\n}\n\nimpl ConnectionInterceptor {\n    pub fn new(connection_manager: Arc<ConnectionManager>) -> Self {\n        Self { connection_manager }\n    }\n\n    /// Intercept incoming requests\n    pub fn intercept<T>(&self, request: Request<T>) -> Result<Request<T>, Status> {\n        // Extract client ID from metadata\n        let client_id = request\n            .metadata()\n            .get(\"client-id\")\n            .and_then(|value| value.to_str().ok())\n            .unwrap_or(\"unknown\")\n            .to_string();\n\n        // Check rate limiting\n        self.connection_manager.check_rate_limit(&client_id)?;\n\n        // Update activity (approximate request size)\n        let request_size = std::mem::size_of_val(&request) as u64;\n        self.connection_manager.update_activity(&client_id, 0, request_size);\n\n        Ok(request)\n    }\n\n    /// Intercept outgoing responses\n    pub fn intercept_response<T>(&self, response: Response<T>, client_id: &str) -> Response<T> {\n        // Update activity (approximate response size)\n        let response_size = std::mem::size_of_val(&response) as u64;\n        self.connection_manager.update_activity(client_id, response_size, 0);\n\n        response\n    }\n}\n\n/// Retry configuration for failed connections\n#[derive(Debug, Clone)]\npub struct RetryConfig {\n    pub max_retries: u32,\n    pub initial_delay: Duration,\n    pub max_delay: Duration,\n    pub backoff_multiplier: f64,\n}\n\nimpl Default for RetryConfig {\n    fn default() -> Self {\n        Self {\n            max_retries: 3,\n            initial_delay: Duration::from_millis(100),\n            max_delay: Duration::from_secs(30),\n            backoff_multiplier: 2.0,\n        }\n    }\n}\n\n/// Retry wrapper for gRPC operations\npub async fn with_retry<F, T, E>(\n    operation: F,\n    config: &RetryConfig,\n) -> Result<T, E>\nwhere\n    F: Fn() -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<T, E>> + Send>>,\n    E: std::fmt::Debug,\n{\n    let mut delay = config.initial_delay;\n\n    for attempt in 1..=config.max_retries {\n        match operation().await {\n            Ok(result) => return Ok(result),\n            Err(err) if attempt == config.max_retries => {\n                debug!(\"Operation failed after {} attempts: {:?}\", config.max_retries, err);\n                return Err(err);\n            },\n            Err(err) => {\n                debug!(\"Operation failed (attempt {}/{}): {:?}\", attempt, config.max_retries, err);\n                tokio::time::sleep(delay).await;\n\n                // Exponential backoff with jitter\n                delay = std::cmp::min(\n                    Duration::from_millis(\n                        (delay.as_millis() as f64 * config.backoff_multiplier) as u64\n                    ),\n                    config.max_delay,\n                );\n            }\n        }\n    }\n\n    unreachable!()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tokio_test;\n    use std::sync::atomic::Ordering;\n    use std::time::Duration;\n    use tonic::{Request, Response, Status, metadata::MetadataValue};\n\n    #[test]\n    fn test_connection_manager_new() {\n        let manager = ConnectionManager::new(100, 10);\n\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 0);\n        assert_eq!(manager.max_connections, 100);\n        assert!(manager.connections.is_empty());\n    }\n\n    #[test]\n    fn test_connection_info_clone() {\n        let info = ConnectionInfo {\n            client_id: \"test_client\".to_string(),\n            connected_at: Instant::now(),\n            last_activity: Instant::now(),\n            request_count: AtomicU64::new(5),\n            bytes_sent: AtomicU64::new(1000),\n            bytes_received: AtomicU64::new(2000),\n        };\n\n        let cloned = info.clone();\n\n        assert_eq!(info.client_id, cloned.client_id);\n        assert_eq!(info.request_count.load(Ordering::SeqCst),\n                   cloned.request_count.load(Ordering::SeqCst));\n        assert_eq!(info.bytes_sent.load(Ordering::SeqCst),\n                   cloned.bytes_sent.load(Ordering::SeqCst));\n        assert_eq!(info.bytes_received.load(Ordering::SeqCst),\n                   cloned.bytes_received.load(Ordering::SeqCst));\n    }\n\n    #[test]\n    fn test_connection_manager_register_connection() {\n        let manager = ConnectionManager::new(2, 10);\n\n        // Register first connection\n        let result1 = manager.register_connection(\"client1\".to_string());\n        assert!(result1.is_ok());\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 1);\n\n        // Register second connection\n        let result2 = manager.register_connection(\"client2\".to_string());\n        assert!(result2.is_ok());\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 2);\n\n        // Try to register third connection (should fail due to limit)\n        let result3 = manager.register_connection(\"client3\".to_string());\n        assert!(result3.is_err());\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 2);\n    }\n\n    #[test]\n    fn test_connection_manager_unregister_connection() {\n        let manager = ConnectionManager::new(10, 10);\n\n        // Register and then unregister\n        manager.register_connection(\"client1\".to_string()).unwrap();\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 1);\n\n        manager.unregister_connection(\"client1\");\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 0);\n        assert!(manager.connections.is_empty());\n\n        // Unregistering non-existent connection should not panic\n        manager.unregister_connection(\"non_existent\");\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 0);\n    }\n\n    #[test]\n    fn test_connection_manager_rate_limiting() {\n        let manager = ConnectionManager::new(10, 2); // 2 requests per second\n\n        // First request should succeed\n        let result1 = manager.check_rate_limit(\"client1\");\n        assert!(result1.is_ok());\n\n        // Second request should succeed\n        let result2 = manager.check_rate_limit(\"client1\");\n        assert!(result2.is_ok());\n\n        // Third request should fail (rate limit exceeded)\n        let result3 = manager.check_rate_limit(\"client1\");\n        assert!(result3.is_err());\n        if let Err(status) = result3 {\n            assert_eq!(status.code(), tonic::Code::ResourceExhausted);\n        }\n    }\n\n    #[test]\n    fn test_connection_manager_rate_limiting_different_clients() {\n        let manager = ConnectionManager::new(10, 2); // 2 requests per second\n\n        // Two requests from client1\n        assert!(manager.check_rate_limit(\"client1\").is_ok());\n        assert!(manager.check_rate_limit(\"client1\").is_ok());\n\n        // Two requests from client2 should still succeed\n        assert!(manager.check_rate_limit(\"client2\").is_ok());\n        assert!(manager.check_rate_limit(\"client2\").is_ok());\n\n        // Third request from each client should fail\n        assert!(manager.check_rate_limit(\"client1\").is_err());\n        assert!(manager.check_rate_limit(\"client2\").is_err());\n    }\n\n    #[test]\n    fn test_connection_manager_update_activity() {\n        let manager = ConnectionManager::new(10, 10);\n        manager.register_connection(\"client1\".to_string()).unwrap();\n\n        // Update activity\n        manager.update_activity(\"client1\", 1000, 500);\n\n        let stats = manager.get_stats();\n        assert_eq!(stats.total_bytes_sent, 1000);\n        assert_eq!(stats.total_bytes_received, 500);\n        assert_eq!(stats.total_requests, 1);\n\n        // Update activity again\n        manager.update_activity(\"client1\", 2000, 1000);\n\n        let stats = manager.get_stats();\n        assert_eq!(stats.total_bytes_sent, 3000);\n        assert_eq!(stats.total_bytes_received, 1500);\n        assert_eq!(stats.total_requests, 2);\n    }\n\n    #[test]\n    fn test_connection_manager_get_stats() {\n        let manager = ConnectionManager::new(10, 10);\n\n        // Initial stats\n        let stats = manager.get_stats();\n        assert_eq!(stats.active_connections, 0);\n        assert_eq!(stats.max_connections, 10);\n        assert_eq!(stats.total_requests, 0);\n        assert_eq!(stats.total_bytes_sent, 0);\n        assert_eq!(stats.total_bytes_received, 0);\n\n        // Register connections and update activity\n        manager.register_connection(\"client1\".to_string()).unwrap();\n        manager.register_connection(\"client2\".to_string()).unwrap();\n        manager.update_activity(\"client1\", 100, 200);\n        manager.update_activity(\"client2\", 300, 400);\n\n        let stats = manager.get_stats();\n        assert_eq!(stats.active_connections, 2);\n        assert_eq!(stats.total_requests, 2);\n        assert_eq!(stats.total_bytes_sent, 400);\n        assert_eq!(stats.total_bytes_received, 600);\n    }\n\n    #[test]\n    fn test_connection_manager_cleanup_expired_connections() {\n        let manager = ConnectionManager::new(10, 10);\n        manager.register_connection(\"client1\".to_string()).unwrap();\n\n        // Connection should not be expired immediately\n        manager.cleanup_expired_connections(Duration::from_secs(1));\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 1);\n\n        // Connection should be expired with zero timeout\n        manager.cleanup_expired_connections(Duration::from_secs(0));\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 0);\n    }\n\n    #[test]\n    fn test_connection_stats_debug() {\n        let stats = ConnectionStats {\n            active_connections: 5,\n            max_connections: 10,\n            total_requests: 100,\n            total_bytes_sent: 1000,\n            total_bytes_received: 2000,\n        };\n\n        let debug_str = format!(\"{:?}\", stats);\n        assert!(debug_str.contains(\"ConnectionStats\"));\n        assert!(debug_str.contains(\"5\"));\n        assert!(debug_str.contains(\"100\"));\n    }\n\n    #[test]\n    fn test_connection_stats_clone() {\n        let stats = ConnectionStats {\n            active_connections: 5,\n            max_connections: 10,\n            total_requests: 100,\n            total_bytes_sent: 1000,\n            total_bytes_received: 2000,\n        };\n\n        let cloned = stats.clone();\n        assert_eq!(stats.active_connections, cloned.active_connections);\n        assert_eq!(stats.max_connections, cloned.max_connections);\n        assert_eq!(stats.total_requests, cloned.total_requests);\n        assert_eq!(stats.total_bytes_sent, cloned.total_bytes_sent);\n        assert_eq!(stats.total_bytes_received, cloned.total_bytes_received);\n    }\n\n    #[test]\n    fn test_pool_config_default() {\n        let config = PoolConfig::default();\n\n        assert_eq!(config.max_size, 10);\n        assert_eq!(config.min_idle, Some(2));\n        assert_eq!(config.max_lifetime, Some(Duration::from_secs(3600)));\n        assert_eq!(config.idle_timeout, Some(Duration::from_secs(600)));\n        assert_eq!(config.connection_timeout, Duration::from_secs(30));\n    }\n\n    #[test]\n    fn test_pool_config_debug() {\n        let config = PoolConfig::default();\n        let debug_str = format!(\"{:?}\", config);\n\n        assert!(debug_str.contains(\"PoolConfig\"));\n        assert!(debug_str.contains(\"max_size\"));\n        assert!(debug_str.contains(\"10\"));\n    }\n\n    #[test]\n    fn test_connection_interceptor_new() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager.clone());\n\n        assert!(Arc::ptr_eq(&interceptor.connection_manager, &manager));\n    }\n\n    #[test]\n    fn test_connection_interceptor_debug() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager);\n\n        let debug_str = format!(\"{:?}\", interceptor);\n        assert!(debug_str.contains(\"ConnectionInterceptor\"));\n        assert!(debug_str.contains(\"connection_manager\"));\n    }\n\n    #[test]\n    fn test_connection_interceptor_clone() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager);\n        let cloned = interceptor.clone();\n\n        assert!(Arc::ptr_eq(&interceptor.connection_manager, &cloned.connection_manager));\n    }\n\n    #[test]\n    fn test_connection_interceptor_intercept_without_client_id() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager);\n\n        let request: Request<()> = Request::new(());\n        let result = interceptor.intercept(request);\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_connection_interceptor_intercept_with_client_id() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager);\n\n        let mut request: Request<()> = Request::new(());\n        request.metadata_mut().insert(\n            \"client-id\",\n            MetadataValue::from_static(\"test_client\")\n        );\n\n        let result = interceptor.intercept(request);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_connection_interceptor_intercept_response() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager.clone());\n\n        manager.register_connection(\"test_client\".to_string()).unwrap();\n\n        let response: Response<()> = Response::new(());\n        let result = interceptor.intercept_response(response, \"test_client\");\n\n        // Should return the response unchanged\n        assert_eq!(result.get_ref(), &());\n    }\n\n    #[test]\n    fn test_retry_config_default() {\n        let config = RetryConfig::default();\n\n        assert_eq!(config.max_retries, 3);\n        assert_eq!(config.initial_delay, Duration::from_millis(100));\n        assert_eq!(config.max_delay, Duration::from_secs(30));\n        assert_eq!(config.backoff_multiplier, 2.0);\n    }\n\n    #[test]\n    fn test_retry_config_debug() {\n        let config = RetryConfig::default();\n        let debug_str = format!(\"{:?}\", config);\n\n        assert!(debug_str.contains(\"RetryConfig\"));\n        assert!(debug_str.contains(\"max_retries\"));\n        assert!(debug_str.contains(\"3\"));\n    }\n\n    #[test]\n    fn test_retry_config_clone() {\n        let config = RetryConfig::default();\n        let cloned = config.clone();\n\n        assert_eq!(config.max_retries, cloned.max_retries);\n        assert_eq!(config.initial_delay, cloned.initial_delay);\n        assert_eq!(config.max_delay, cloned.max_delay);\n        assert_eq!(config.backoff_multiplier, cloned.backoff_multiplier);\n    }\n\n    #[tokio::test]\n    async fn test_with_retry_success_first_attempt() {\n        let config = RetryConfig {\n            max_retries: 3,\n            initial_delay: Duration::from_millis(10),\n            max_delay: Duration::from_secs(1),\n            backoff_multiplier: 2.0,\n        };\n\n        let result = with_retry(\n            || Box::pin(async { Ok::<i32, &'static str>(42) }),\n            &config,\n        ).await;\n\n        assert_eq!(result.unwrap(), 42);\n    }\n\n    #[tokio::test]\n    async fn test_with_retry_success_after_failures() {\n        let config = RetryConfig {\n            max_retries: 3,\n            initial_delay: Duration::from_millis(1),\n            max_delay: Duration::from_secs(1),\n            backoff_multiplier: 2.0,\n        };\n\n        let attempt = Arc::new(AtomicU64::new(0));\n        let attempt_clone = Arc::clone(&attempt);\n        let result = with_retry(\n            move || {\n                let current_attempt = attempt_clone.fetch_add(1, Ordering::SeqCst) + 1;\n                Box::pin(async move {\n                    if current_attempt < 3 {\n                        Err(\"temporary failure\")\n                    } else {\n                        Ok::<i32, &'static str>(42)\n                    }\n                })\n            },\n            &config,\n        ).await;\n\n        assert_eq!(result.unwrap(), 42);\n    }\n\n    #[tokio::test]\n    async fn test_with_retry_final_failure() {\n        let config = RetryConfig {\n            max_retries: 2,\n            initial_delay: Duration::from_millis(1),\n            max_delay: Duration::from_secs(1),\n            backoff_multiplier: 2.0,\n        };\n\n        let result = with_retry(\n            || Box::pin(async { Err::<i32, &'static str>(\"permanent failure\") }),\n            &config,\n        ).await;\n\n        assert_eq!(result.unwrap_err(), \"permanent failure\");\n    }\n\n    #[test]\n    fn test_rate_limiter_debug() {\n        let rate_limiter = RateLimiter {\n            requests_per_second: 10,\n            client_requests: DashMap::new(),\n            last_cleanup: Instant::now(),\n        };\n\n        let debug_str = format!(\"{:?}\", rate_limiter);\n        assert!(debug_str.contains(\"RateLimiter\"));\n        assert!(debug_str.contains(\"requests_per_second\"));\n        assert!(debug_str.contains(\"10\"));\n    }\n\n    #[test]\n    fn test_connection_manager_send_sync() {\n        fn assert_send<T: Send>() {}\n        fn assert_sync<T: Sync>() {}\n\n        assert_send::<ConnectionManager>();\n        assert_sync::<ConnectionManager>();\n    }\n\n    #[test]\n    fn test_connection_interceptor_send_sync() {\n        fn assert_send<T: Send>() {}\n        fn assert_sync<T: Sync>() {}\n\n        assert_send::<ConnectionInterceptor>();\n        assert_sync::<ConnectionInterceptor>();\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_connection_management() {\n        let manager = Arc::new(ConnectionManager::new(100, 50));\n\n        let mut handles = vec![];\n\n        // Spawn multiple tasks to register connections concurrently\n        for i in 0..10 {\n            let manager_clone = Arc::clone(&manager);\n            let handle = tokio::spawn(async move {\n                let client_id = format!(\"client_{}\", i);\n                manager_clone.register_connection(client_id.clone()).unwrap();\n\n                // Simulate some activity\n                for _ in 0..5 {\n                    manager_clone.update_activity(&client_id, 100, 200);\n                    tokio::time::sleep(Duration::from_millis(1)).await;\n                }\n\n                manager_clone.unregister_connection(&client_id);\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all tasks to complete\n        for handle in handles {\n            handle.await.unwrap();\n        }\n\n        // All connections should be unregistered\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 0);\n    }\n}","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":44,"address":[],"length":0,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":26}},{"line":65,"address":[],"length":0,"stats":{"Line":52}},{"line":67,"address":[],"length":0,"stats":{"Line":78}},{"line":68,"address":[],"length":0,"stats":{"Line":78}},{"line":77,"address":[],"length":0,"stats":{"Line":19}},{"line":78,"address":[],"length":0,"stats":{"Line":76}},{"line":80,"address":[],"length":0,"stats":{"Line":19}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":13}},{"line":103,"address":[],"length":0,"stats":{"Line":39}},{"line":104,"address":[],"length":0,"stats":{"Line":36}},{"line":105,"address":[],"length":0,"stats":{"Line":12}},{"line":109,"address":[],"length":0,"stats":{"Line":39}},{"line":113,"address":[],"length":0,"stats":{"Line":11}},{"line":114,"address":[],"length":0,"stats":{"Line":22}},{"line":117,"address":[],"length":0,"stats":{"Line":22}},{"line":118,"address":[],"length":0,"stats":{"Line":22}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":33}},{"line":125,"address":[],"length":0,"stats":{"Line":33}},{"line":126,"address":[],"length":0,"stats":{"Line":11}},{"line":130,"address":[],"length":0,"stats":{"Line":49}},{"line":133,"address":[],"length":0,"stats":{"Line":22}},{"line":134,"address":[],"length":0,"stats":{"Line":3}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":57}},{"line":147,"address":[],"length":0,"stats":{"Line":169}},{"line":156,"address":[],"length":0,"stats":{"Line":8}},{"line":157,"address":[],"length":0,"stats":{"Line":32}},{"line":158,"address":[],"length":0,"stats":{"Line":24}},{"line":160,"address":[],"length":0,"stats":{"Line":20}},{"line":162,"address":[],"length":0,"stats":{"Line":24}},{"line":164,"address":[],"length":0,"stats":{"Line":20}},{"line":166,"address":[],"length":0,"stats":{"Line":24}},{"line":168,"address":[],"length":0,"stats":{"Line":20}},{"line":173,"address":[],"length":0,"stats":{"Line":16}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":6}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":245,"address":[],"length":0,"stats":{"Line":4}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":7}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":4}},{"line":269,"address":[],"length":0,"stats":{"Line":5}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":3}},{"line":289,"address":[],"length":0,"stats":{"Line":1}},{"line":303,"address":[],"length":0,"stats":{"Line":3}},{"line":306,"address":[],"length":0,"stats":{"Line":3}},{"line":307,"address":[],"length":0,"stats":{"Line":3}},{"line":314,"address":[],"length":0,"stats":{"Line":3}},{"line":322,"address":[],"length":0,"stats":{"Line":6}},{"line":324,"address":[],"length":0,"stats":{"Line":9}},{"line":325,"address":[],"length":0,"stats":{"Line":12}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":6}},{"line":328,"address":[],"length":0,"stats":{"Line":1}},{"line":329,"address":[],"length":0,"stats":{"Line":1}},{"line":331,"address":[],"length":0,"stats":{"Line":3}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":3}},{"line":337,"address":[],"length":0,"stats":{"Line":3}},{"line":338,"address":[],"length":0,"stats":{"Line":3}},{"line":340,"address":[],"length":0,"stats":{"Line":3}}],"covered":81,"coverable":97},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","grpc","mod.rs"],"content":"//! gRPC server implementations for all daemon services\n\npub mod server;\npub mod services;\npub mod middleware;\n\npub use server::GrpcServer;","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","grpc","server.rs"],"content":"//! Main gRPC server implementation with all service registrations\n\nuse crate::daemon::WorkspaceDaemon;\nuse crate::grpc::middleware::{ConnectionManager, ConnectionInterceptor};\nuse crate::grpc::services::{\n    DocumentProcessorImpl,\n    SearchServiceImpl,\n    MemoryServiceImpl,\n    SystemServiceImpl,\n};\nuse crate::proto::{\n    document_processor_server::DocumentProcessorServer,\n    search_service_server::SearchServiceServer,\n    memory_service_server::MemoryServiceServer,\n    system_service_server::SystemServiceServer,\n};\n\nuse anyhow::Result;\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::signal;\nuse tonic::transport::Server;\nuse tracing::info;\n\n/// Main gRPC server coordinating all daemon services\npub struct GrpcServer {\n    daemon: Arc<WorkspaceDaemon>,\n    address: SocketAddr,\n    connection_manager: Arc<ConnectionManager>,\n}\n\nimpl GrpcServer {\n    /// Create a new gRPC server instance\n    pub fn new(daemon: WorkspaceDaemon, address: SocketAddr) -> Self {\n        let config = daemon.config();\n        let connection_manager = Arc::new(ConnectionManager::new(\n            config.server.max_connections as u64,\n            100, // 100 requests per second per client\n        ));\n\n        Self {\n            daemon: Arc::new(daemon),\n            address,\n            connection_manager,\n        }\n    }\n\n    /// Start the gRPC server in foreground mode\n    pub async fn serve(self) -> Result<()> {\n        let address = self.address;\n        info!(\"Starting gRPC server on {}\", address);\n        info!(\"Connection manager initialized with max connections: {}\",\n              self.daemon.config().server.max_connections);\n\n        // Start connection cleanup task\n        let connection_manager_clone = Arc::clone(&self.connection_manager);\n        let cleanup_task = tokio::spawn(async move {\n            let mut interval = tokio::time::interval(Duration::from_secs(60));\n            loop {\n                interval.tick().await;\n                connection_manager_clone.cleanup_expired_connections(Duration::from_secs(300));\n            }\n        });\n\n        let server = self.build_server().await?;\n\n        // Graceful shutdown\n        let shutdown_signal = async {\n            signal::ctrl_c()\n                .await\n                .expect(\"Failed to install CTRL+C signal handler\");\n            info!(\"Received shutdown signal, gracefully shutting down...\");\n            cleanup_task.abort();\n        };\n\n        server\n            .serve_with_shutdown(address, shutdown_signal)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"gRPC server error: {}\", e))?;\n\n        info!(\"gRPC server shutdown complete\");\n        Ok(())\n    }\n\n    /// Start the gRPC server in daemon mode\n    pub async fn serve_daemon(self) -> Result<()> {\n        let address = self.address;\n        info!(\"Starting gRPC server in daemon mode on {}\", address);\n        info!(\"Connection manager initialized with max connections: {}\",\n              self.daemon.config().server.max_connections);\n\n        // Start connection cleanup task\n        let connection_manager_clone = Arc::clone(&self.connection_manager);\n        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(Duration::from_secs(60));\n            loop {\n                interval.tick().await;\n                connection_manager_clone.cleanup_expired_connections(Duration::from_secs(300));\n            }\n        });\n\n        let server = self.build_server().await?;\n\n        server\n            .serve(address)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"gRPC server error: {}\", e))?;\n\n        Ok(())\n    }\n\n    /// Build the complete gRPC server with all services\n    async fn build_server(self) -> Result<tonic::transport::server::Router> {\n        let reflection_service = tonic_reflection::server::Builder::configure()\n            .register_encoded_file_descriptor_set(include_bytes!(concat!(env!(\"OUT_DIR\"), \"/workspace_daemon_descriptor.bin\")))\n            .build_v1()\n            .map_err(|e| anyhow::anyhow!(\"Failed to build reflection service: {}\", e))?;\n\n        // Create connection interceptor\n        let interceptor = ConnectionInterceptor::new(Arc::clone(&self.connection_manager));\n\n        // Create service implementations\n        let document_processor = DocumentProcessorImpl::new(Arc::clone(&self.daemon));\n        let search_service = SearchServiceImpl::new(Arc::clone(&self.daemon));\n        let memory_service = MemoryServiceImpl::new(Arc::clone(&self.daemon));\n        let system_service = SystemServiceImpl::new(Arc::clone(&self.daemon));\n\n        let config = self.daemon.config();\n\n        let server = Server::builder()\n            // Add connection timeout from config\n            .timeout(Duration::from_secs(config.server.connection_timeout_secs))\n            // Set concurrency limits\n            .concurrency_limit_per_connection(256)\n            // Add keep-alive settings\n            .tcp_keepalive(Some(Duration::from_secs(60)))\n            // Register all services\n            .add_service(DocumentProcessorServer::new(document_processor))\n            .add_service(SearchServiceServer::new(search_service))\n            .add_service(MemoryServiceServer::new(memory_service))\n            .add_service(SystemServiceServer::new(system_service))\n            // Add reflection for debugging\n            .add_service(reflection_service);\n\n        Ok(server)\n    }\n\n    /// Get connection statistics\n    pub fn get_connection_stats(&self) -> crate::grpc::middleware::ConnectionStats {\n        self.connection_manager.get_stats()\n    }\n\n    /// Get connection manager for external access\n    pub fn connection_manager(&self) -> &Arc<ConnectionManager> {\n        &self.connection_manager\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use std::net::{IpAddr, Ipv4Addr};\n    use tempfile::TempDir;\n    use tokio_test;\n\n    fn create_test_daemon_config() -> DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\";\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50052, // Use different port for testing\n                max_connections: 100,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 60,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path.to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 2,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 1024 * 1024,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 10,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    async fn create_test_daemon() -> WorkspaceDaemon {\n        let config = create_test_daemon_config();\n        WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\")\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_new() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0);\n\n        let server = GrpcServer::new(daemon, address);\n\n        assert_eq!(server.address, address);\n        assert!(Arc::strong_count(&server.connection_manager) >= 1);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_connection_manager_access() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n        let connection_manager = server.connection_manager();\n\n        // Test that we can access connection manager\n        let stats = connection_manager.get_stats();\n        assert_eq!(stats.active_connections, 0);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_get_connection_stats() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n        let stats = server.get_connection_stats();\n\n        // Initially should have no active connections\n        assert_eq!(stats.active_connections, 0);\n        assert_eq!(stats.total_requests, 0);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_build_server() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n        let result = server.build_server().await;\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_grpc_server_address_types() {\n        // Test IPv4 address\n        let ipv4 = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1)), 8080);\n        assert_eq!(ipv4.ip(), IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1)));\n        assert_eq!(ipv4.port(), 8080);\n\n        // Test IPv6 address\n        let ipv6 = \"[::1]:9090\".parse::<SocketAddr>().unwrap();\n        assert!(ipv6.is_ipv6());\n        assert_eq!(ipv6.port(), 9090);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_with_different_ports() {\n        let daemon = create_test_daemon().await;\n\n        let ports = [8080, 8081, 8082];\n        for port in ports {\n            let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);\n            let server = GrpcServer::new(daemon.clone(), address);\n            assert_eq!(server.address.port(), port);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_connection_manager_initialization() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n        let connection_manager = server.connection_manager();\n\n        // Test that connection manager is properly initialized\n        let stats = connection_manager.get_stats();\n        assert_eq!(stats.active_connections, 0);\n        assert_eq!(stats.total_requests, 0);\n        assert_eq!(stats.total_bytes_sent, 0);\n        assert_eq!(stats.total_bytes_received, 0);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_daemon_config_access() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n\n        // Test accessing daemon config through server\n        let connection_manager = server.connection_manager();\n        let stats = connection_manager.get_stats();\n\n        // Should have valid stats\n        assert!(stats.active_connections >= 0);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_arc_sharing() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n        let daemon_arc = &server.daemon;\n\n        // Verify daemon is properly shared via Arc\n        assert!(Arc::strong_count(daemon_arc) >= 1);\n    }\n\n    #[test]\n    fn test_socket_addr_parsing() {\n        // Test various socket address formats\n        let addrs = [\n            \"127.0.0.1:8080\",\n            \"0.0.0.0:8080\",\n            \"[::1]:8080\",\n            \"[::]:8080\",\n        ];\n\n        for addr_str in addrs {\n            let result = addr_str.parse::<SocketAddr>();\n            assert!(result.is_ok(), \"Failed to parse address: {}\", addr_str);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_memory_efficiency() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n\n        // Verify that server doesn't hold unnecessary references\n        let initial_daemon_count = Arc::strong_count(&server.daemon);\n        let initial_manager_count = Arc::strong_count(&server.connection_manager);\n\n        assert_eq!(initial_daemon_count, 1);\n        assert_eq!(initial_manager_count, 1);\n    }\n\n    #[test]\n    fn test_grpc_server_send_sync() {\n        fn assert_send<T: Send>() {}\n        fn assert_sync<T: Sync>() {}\n\n        assert_send::<GrpcServer>();\n        assert_sync::<GrpcServer>();\n    }\n}","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":11}},{"line":36,"address":[],"length":0,"stats":{"Line":33}},{"line":37,"address":[],"length":0,"stats":{"Line":33}},{"line":38,"address":[],"length":0,"stats":{"Line":11}},{"line":43,"address":[],"length":0,"stats":{"Line":33}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":3}}],"covered":13,"coverable":51},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","grpc","services","document_processor.rs"],"content":"//! Document processing gRPC service implementation\n\nuse crate::daemon::WorkspaceDaemon;\nuse crate::proto::{\n    document_processor_server::DocumentProcessor,\n    ProcessDocumentRequest, ProcessDocumentResponse,\n    ProcessingStatusRequest, ProcessingStatusResponse,\n    CancelProcessingRequest,\n};\nuse std::sync::Arc;\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, error, info};\n\n/// Document processor service implementation\n#[derive(Debug)]\npub struct DocumentProcessorImpl {\n    daemon: Arc<WorkspaceDaemon>,\n}\n\nimpl DocumentProcessorImpl {\n    pub fn new(daemon: Arc<WorkspaceDaemon>) -> Self {\n        Self { daemon }\n    }\n}\n\n#[tonic::async_trait]\nimpl DocumentProcessor for DocumentProcessorImpl {\n    async fn process_document(\n        &self,\n        request: Request<ProcessDocumentRequest>,\n    ) -> Result<Response<ProcessDocumentResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Processing document: {:?}\", req.file_path);\n\n        // TODO: Implement actual document processing\n        // This is a placeholder implementation\n        let response = ProcessDocumentResponse {\n            document_id: uuid::Uuid::new_v4().to_string(),\n            status: crate::proto::ProcessingStatus::Completed as i32,\n            error_message: String::new(),\n            chunks_created: 1,\n            extracted_metadata: std::collections::HashMap::new(),\n            processed_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    type ProcessDocumentsStream = tokio_stream::wrappers::ReceiverStream<Result<ProcessDocumentResponse, Status>>;\n\n    async fn process_documents(\n        &self,\n        request: Request<tonic::Streaming<ProcessDocumentRequest>>,\n    ) -> Result<Response<Self::ProcessDocumentsStream>, Status> {\n        let mut stream = request.into_inner();\n        let (tx, rx) = tokio::sync::mpsc::channel(128);\n\n        // Spawn task to process the stream\n        tokio::spawn(async move {\n            while let Some(req) = stream.message().await.transpose() {\n                match req {\n                    Ok(req) => {\n                        debug!(\"Processing document in stream: {:?}\", req.file_path);\n\n                        // TODO: Implement actual processing\n                        let response = ProcessDocumentResponse {\n                            document_id: uuid::Uuid::new_v4().to_string(),\n                            status: crate::proto::ProcessingStatus::Completed as i32,\n                            error_message: String::new(),\n                            chunks_created: 1,\n                            extracted_metadata: std::collections::HashMap::new(),\n                            processed_at: Some(prost_types::Timestamp {\n                                seconds: chrono::Utc::now().timestamp(),\n                                nanos: 0,\n                            }),\n                        };\n\n                        if tx.send(Ok(response)).await.is_err() {\n                            break;\n                        }\n                    },\n                    Err(e) => {\n                        let _ = tx.send(Err(e)).await;\n                        break;\n                    }\n                }\n            }\n        });\n\n        Ok(Response::new(tokio_stream::wrappers::ReceiverStream::new(rx)))\n    }\n\n    async fn get_processing_status(\n        &self,\n        request: Request<ProcessingStatusRequest>,\n    ) -> Result<Response<ProcessingStatusResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Getting processing status for: {}\", req.operation_id);\n\n        // TODO: Implement actual status tracking\n        let response = ProcessingStatusResponse {\n            operation_id: req.operation_id,\n            status: crate::proto::ProcessingStatus::Completed as i32,\n            total_documents: 1,\n            processed_documents: 1,\n            failed_documents: 0,\n            error_messages: vec![],\n            started_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp() - 60,\n                nanos: 0,\n            }),\n            updated_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn cancel_processing(\n        &self,\n        request: Request<CancelProcessingRequest>,\n    ) -> Result<Response<()>, Status> {\n        let req = request.into_inner();\n        info!(\"Cancelling processing operation: {}\", req.operation_id);\n\n        // TODO: Implement actual cancellation logic\n\n        Ok(Response::new(()))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use tempfile::TempDir;\n    use tonic::Request;\n    use tokio_test;\n    use std::collections::HashMap;\n\n    fn create_test_daemon_config() -> DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\";\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50051,\n                max_connections: 100,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 60,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path.to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 2,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 1024 * 1024,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 10,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    async fn create_test_daemon() -> Arc<WorkspaceDaemon> {\n        let config = create_test_daemon_config();\n        Arc::new(WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\"))\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_impl_new() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon.clone());\n\n        assert!(Arc::ptr_eq(&processor.daemon, &daemon));\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_impl_debug() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let debug_str = format!(\"{:?}\", processor);\n        assert!(debug_str.contains(\"DocumentProcessorImpl\"));\n        assert!(debug_str.contains(\"daemon\"));\n    }\n\n    #[tokio::test]\n    async fn test_process_document_basic() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let request = Request::new(ProcessDocumentRequest {\n            project_id: \"test_project\".to_string(),\n            document_type: crate::proto::DocumentType::Text as i32,\n            file_path: \"/test/document.txt\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n            metadata: HashMap::new(),\n            options: None,\n        });\n\n        let result = processor.process_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.document_id.is_empty());\n        assert_eq!(response.status, crate::proto::ProcessingStatus::Completed as i32);\n        assert!(response.error_message.is_empty());\n        assert_eq!(response.chunks_created, 1);\n        assert!(response.processed_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_process_document_with_metadata() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let mut metadata = HashMap::new();\n        metadata.insert(\"author\".to_string(), \"test_author\".to_string());\n        metadata.insert(\"version\".to_string(), \"1.0\".to_string());\n\n        let request = Request::new(ProcessDocumentRequest {\n            project_id: \"test_project\".to_string(),\n            document_type: crate::proto::DocumentType::Text as i32,\n            file_path: \"/test/document_with_metadata.txt\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n            metadata,\n            options: None,\n        });\n\n        let result = processor.process_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.document_id.is_empty());\n        assert_eq!(response.status, crate::proto::ProcessingStatus::Completed as i32);\n    }\n\n    #[tokio::test]\n    async fn test_process_document_different_file_types() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let file_types = [\n            \"document.txt\",\n            \"readme.md\",\n            \"script.py\",\n            \"code.rs\",\n            \"data.json\",\n            \"page.html\",\n        ];\n\n        for file_name in file_types {\n            let request = Request::new(ProcessDocumentRequest {\n                project_id: \"test_project\".to_string(),\n                document_type: crate::proto::DocumentType::Text as i32,\n                file_path: format!(\"/test/{}\", file_name),\n                collection_name: \"test_collection\".to_string(),\n                metadata: HashMap::new(),\n                options: None,\n            });\n\n            let result = processor.process_document(request).await;\n            assert!(result.is_ok(), \"Failed to process file: {}\", file_name);\n\n            let response = result.unwrap().into_inner();\n            assert!(!response.document_id.is_empty());\n            assert_eq!(response.status, crate::proto::ProcessingStatus::Completed as i32);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_processing_status() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let request = Request::new(ProcessingStatusRequest {\n            operation_id: \"test_operation_123\".to_string(),\n        });\n\n        let result = processor.get_processing_status(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.operation_id, \"test_operation_123\");\n        assert_eq!(response.status, crate::proto::ProcessingStatus::Completed as i32);\n        assert_eq!(response.total_documents, 1);\n        assert_eq!(response.processed_documents, 1);\n        assert_eq!(response.failed_documents, 0);\n        assert!(response.error_messages.is_empty());\n        assert!(response.started_at.is_some());\n        assert!(response.updated_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_get_processing_status_different_operation_ids() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let operation_ids = [\n            \"op_1\",\n            \"operation_with_underscores_123\",\n            \"uuid-like-operation-456\",\n            \"simple\",\n        ];\n\n        for op_id in operation_ids {\n            let request = Request::new(ProcessingStatusRequest {\n                operation_id: op_id.to_string(),\n            });\n\n            let result = processor.get_processing_status(request).await;\n            assert!(result.is_ok(), \"Failed for operation ID: {}\", op_id);\n\n            let response = result.unwrap().into_inner();\n            assert_eq!(response.operation_id, op_id);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_cancel_processing() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let request = Request::new(CancelProcessingRequest {\n            operation_id: \"test_cancel_operation\".to_string(),\n        });\n\n        let result = processor.cancel_processing(request).await;\n        assert!(result.is_ok());\n\n        // Response should be empty unit type\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_cancel_processing_multiple_operations() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let operation_ids = [\n            \"cancel_op_1\",\n            \"cancel_op_2\",\n            \"cancel_op_3\",\n        ];\n\n        for op_id in operation_ids {\n            let request = Request::new(CancelProcessingRequest {\n                operation_id: op_id.to_string(),\n            });\n\n            let result = processor.cancel_processing(request).await;\n            assert!(result.is_ok(), \"Failed to cancel operation: {}\", op_id);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_process_document_unique_ids() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let mut document_ids = std::collections::HashSet::new();\n\n        // Process multiple documents and verify unique IDs\n        for i in 0..5 {\n            let request = Request::new(ProcessDocumentRequest {\n                project_id: \"test_project\".to_string(),\n                document_type: crate::proto::DocumentType::Text as i32,\n                file_path: format!(\"/test/document_{}.txt\", i),\n                collection_name: \"test_collection\".to_string(),\n                metadata: HashMap::new(),\n                options: None,\n            });\n\n            let result = processor.process_document(request).await;\n            assert!(result.is_ok());\n\n            let response = result.unwrap().into_inner();\n            assert!(document_ids.insert(response.document_id.clone()),\n                    \"Duplicate document ID generated: {}\", response.document_id);\n        }\n\n        assert_eq!(document_ids.len(), 5);\n    }\n\n    #[tokio::test]\n    async fn test_process_document_timestamps() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let before_processing = chrono::Utc::now().timestamp();\n\n        let request = Request::new(ProcessDocumentRequest {\n            project_id: \"test_project\".to_string(),\n            document_type: crate::proto::DocumentType::Text as i32,\n            file_path: \"/test/timestamp_test.txt\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n            metadata: HashMap::new(),\n            options: None,\n        });\n\n        let result = processor.process_document(request).await;\n        assert!(result.is_ok());\n\n        let after_processing = chrono::Utc::now().timestamp();\n        let response = result.unwrap().into_inner();\n\n        assert!(response.processed_at.is_some());\n        let processed_timestamp = response.processed_at.unwrap().seconds;\n        assert!(processed_timestamp >= before_processing);\n        assert!(processed_timestamp <= after_processing);\n    }\n\n    #[tokio::test]\n    async fn test_processing_status_timestamps() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let request = Request::new(ProcessingStatusRequest {\n            operation_id: \"timestamp_test_op\".to_string(),\n        });\n\n        let result = processor.get_processing_status(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.started_at.is_some());\n        assert!(response.updated_at.is_some());\n\n        let started_timestamp = response.started_at.unwrap().seconds;\n        let updated_timestamp = response.updated_at.unwrap().seconds;\n\n        // Updated timestamp should be after started timestamp\n        assert!(updated_timestamp >= started_timestamp);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_document_processing() {\n        let daemon = create_test_daemon().await;\n        let processor = Arc::new(DocumentProcessorImpl::new(daemon));\n\n        let mut handles = vec![];\n\n        // Process multiple documents concurrently\n        for i in 0..5 {\n            let processor_clone = Arc::clone(&processor);\n            let handle = tokio::spawn(async move {\n                let request = Request::new(ProcessDocumentRequest {\n                    project_id: \"test_project\".to_string(),\n                    document_type: crate::proto::DocumentType::Text as i32,\n                    file_path: format!(\"/test/concurrent_doc_{}.txt\", i),\n                    collection_name: \"test_collection\".to_string(),\n                    metadata: HashMap::new(),\n                    options: None,\n                });\n\n                processor_clone.process_document(request).await\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all tasks to complete\n        let results: Vec<_> = futures_util::future::join_all(handles).await;\n\n        // All tasks should complete successfully\n        for (i, result) in results.into_iter().enumerate() {\n            let task_result = result.unwrap();\n            assert!(task_result.is_ok(), \"Task {} failed\", i);\n\n            let response = task_result.unwrap().into_inner();\n            assert!(!response.document_id.is_empty());\n            assert_eq!(response.status, crate::proto::ProcessingStatus::Completed as i32);\n        }\n    }\n\n    #[test]\n    fn test_document_processor_impl_send_sync() {\n        fn assert_send<T: Send>() {}\n        fn assert_sync<T: Sync>() {}\n\n        assert_send::<DocumentProcessorImpl>();\n        assert_sync::<DocumentProcessorImpl>();\n    }\n}","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":14}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}}],"covered":1,"coverable":10},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","grpc","services","memory_service.rs"],"content":"//! Memory management gRPC service implementation\n\nuse crate::daemon::WorkspaceDaemon;\nuse crate::proto::{\n    memory_service_server::MemoryService,\n    AddDocumentRequest, AddDocumentResponse,\n    UpdateDocumentRequest, UpdateDocumentResponse,\n    RemoveDocumentRequest, GetDocumentRequest, GetDocumentResponse,\n    ListDocumentsRequest, ListDocumentsResponse,\n    CreateCollectionRequest, CreateCollectionResponse,\n    DeleteCollectionRequest, ListCollectionsRequest, ListCollectionsResponse,\n    DocumentInfo, CollectionInfo, DocumentContent, CollectionConfig,\n};\nuse std::sync::Arc;\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, error, info};\n\n/// Memory service implementation\n#[derive(Debug)]\npub struct MemoryServiceImpl {\n    daemon: Arc<WorkspaceDaemon>,\n}\n\nimpl MemoryServiceImpl {\n    pub fn new(daemon: Arc<WorkspaceDaemon>) -> Self {\n        Self { daemon }\n    }\n}\n\n#[tonic::async_trait]\nimpl MemoryService for MemoryServiceImpl {\n    async fn add_document(\n        &self,\n        request: Request<AddDocumentRequest>,\n    ) -> Result<Response<AddDocumentResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Adding document: {}\", req.file_path);\n\n        // TODO: Implement actual document addition\n        let response = AddDocumentResponse {\n            document_id: uuid::Uuid::new_v4().to_string(),\n            success: true,\n            error_message: String::new(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn update_document(\n        &self,\n        request: Request<UpdateDocumentRequest>,\n    ) -> Result<Response<UpdateDocumentResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Updating document: {}\", req.document_id);\n\n        // TODO: Implement actual document update\n        let response = UpdateDocumentResponse {\n            success: true,\n            error_message: String::new(),\n            updated_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn remove_document(\n        &self,\n        request: Request<RemoveDocumentRequest>,\n    ) -> Result<Response<()>, Status> {\n        let req = request.into_inner();\n        info!(\"Removing document: {} from collection: {}\", req.document_id, req.collection_name);\n\n        // TODO: Implement actual document removal\n\n        Ok(Response::new(()))\n    }\n\n    async fn get_document(\n        &self,\n        request: Request<GetDocumentRequest>,\n    ) -> Result<Response<GetDocumentResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Getting document: {} from collection: {}\", req.document_id, req.collection_name);\n\n        // TODO: Implement actual document retrieval\n        let response = GetDocumentResponse {\n            document_id: req.document_id.clone(),\n            content: Some(DocumentContent {\n                text: \"Example document content\".to_string(),\n                chunks: vec![],\n                extracted_metadata: std::collections::HashMap::new(),\n            }),\n            metadata: std::collections::HashMap::new(),\n            created_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp() - 86400,\n                nanos: 0,\n            }),\n            updated_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn list_documents(\n        &self,\n        request: Request<ListDocumentsRequest>,\n    ) -> Result<Response<ListDocumentsResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Listing documents in collection: {}\", req.collection_name);\n\n        // TODO: Implement actual document listing\n        let response = ListDocumentsResponse {\n            documents: vec![\n                DocumentInfo {\n                    document_id: uuid::Uuid::new_v4().to_string(),\n                    file_path: \"/example/document.txt\".to_string(),\n                    title: \"Example Document\".to_string(),\n                    document_type: crate::proto::DocumentType::Text as i32,\n                    file_size: 1024,\n                    metadata: std::collections::HashMap::new(),\n                    created_at: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp() - 86400,\n                        nanos: 0,\n                    }),\n                    updated_at: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n            ],\n            total_count: 1,\n            has_more: false,\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn create_collection(\n        &self,\n        request: Request<CreateCollectionRequest>,\n    ) -> Result<Response<CreateCollectionResponse>, Status> {\n        let req = request.into_inner();\n        info!(\"Creating collection: {} for project: {}\", req.collection_name, req.project_id);\n\n        // TODO: Implement actual collection creation\n        let response = CreateCollectionResponse {\n            success: true,\n            error_message: String::new(),\n            collection_id: uuid::Uuid::new_v4().to_string(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn delete_collection(\n        &self,\n        request: Request<DeleteCollectionRequest>,\n    ) -> Result<Response<()>, Status> {\n        let req = request.into_inner();\n        info!(\"Deleting collection: {} for project: {} (force: {})\",\n              req.collection_name, req.project_id, req.force);\n\n        // TODO: Implement actual collection deletion\n\n        Ok(Response::new(()))\n    }\n\n    async fn list_collections(\n        &self,\n        request: Request<ListCollectionsRequest>,\n    ) -> Result<Response<ListCollectionsResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Listing collections for project: {}\", req.project_id);\n\n        // TODO: Implement actual collection listing\n        let response = ListCollectionsResponse {\n            collections: vec![\n                CollectionInfo {\n                    collection_name: \"example-collection\".to_string(),\n                    collection_id: uuid::Uuid::new_v4().to_string(),\n                    project_id: req.project_id.clone(),\n                    document_count: 10,\n                    total_size_bytes: 10240,\n                    config: Some(CollectionConfig {\n                        vector_size: 384,\n                        distance_metric: \"Cosine\".to_string(),\n                        enable_indexing: true,\n                        metadata_schema: std::collections::HashMap::new(),\n                    }),\n                    created_at: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp() - 86400,\n                        nanos: 0,\n                    }),\n                },\n            ],\n        };\n\n        Ok(Response::new(response))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use tempfile::TempDir;\n    use tonic::Request;\n    use tokio_test;\n    use std::collections::HashMap;\n\n    fn create_test_daemon_config() -> DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\";\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50053,\n                max_connections: 100,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 60,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path.to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: crate::config::CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 2,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 1024 * 1024,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 10,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    async fn create_test_daemon() -> Arc<WorkspaceDaemon> {\n        let config = create_test_daemon_config();\n        Arc::new(WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\"))\n    }\n\n    #[tokio::test]\n    async fn test_memory_service_impl_new() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon.clone());\n\n        assert!(Arc::ptr_eq(&service.daemon, &daemon));\n    }\n\n    #[tokio::test]\n    async fn test_memory_service_impl_debug() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let debug_str = format!(\"{:?}\", service);\n        assert!(debug_str.contains(\"MemoryServiceImpl\"));\n        assert!(debug_str.contains(\"daemon\"));\n    }\n\n    #[tokio::test]\n    async fn test_add_document_basic() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(AddDocumentRequest {\n            file_path: \"/test/document.txt\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n            content: Some(DocumentContent {\n                text: \"Test document content\".to_string(),\n                chunks: vec![],\n                extracted_metadata: HashMap::new(),\n            }),\n            metadata: HashMap::new(),\n            project_id: \"test_project\".to_string(),\n        });\n\n        let result = service.add_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.document_id.is_empty());\n        assert!(response.success);\n        assert!(response.error_message.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_add_document_with_metadata() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let mut metadata = HashMap::new();\n        metadata.insert(\"author\".to_string(), \"John Doe\".to_string());\n        metadata.insert(\"category\".to_string(), \"documentation\".to_string());\n        metadata.insert(\"version\".to_string(), \"1.0\".to_string());\n\n        let mut extracted_metadata = HashMap::new();\n        extracted_metadata.insert(\"word_count\".to_string(), \"150\".to_string());\n        extracted_metadata.insert(\"language\".to_string(), \"en\".to_string());\n\n        let request = Request::new(AddDocumentRequest {\n            file_path: \"/test/document_with_metadata.txt\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n            content: Some(DocumentContent {\n                text: \"Test document with metadata\".to_string(),\n                chunks: vec![\n                    crate::proto::DocumentChunk {\n                        id: \"chunk1\".to_string(),\n                        content: \"First chunk content\".to_string(),\n                        start_offset: 0,\n                        end_offset: 50,\n                        metadata: HashMap::new(),\n                    },\n                    crate::proto::DocumentChunk {\n                        id: \"chunk2\".to_string(),\n                        content: \"Second chunk content\".to_string(),\n                        start_offset: 51,\n                        end_offset: 100,\n                        metadata: HashMap::new(),\n                    },\n                ],\n                extracted_metadata,\n            }),\n            metadata,\n            project_id: \"test_project\".to_string(),\n        });\n\n        let result = service.add_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.document_id.is_empty());\n        assert!(response.success);\n    }\n\n    #[tokio::test]\n    async fn test_add_document_different_file_types() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let file_types = [\n            (\"document.txt\", \"text/plain\"),\n            (\"readme.md\", \"text/markdown\"),\n            (\"script.py\", \"text/x-python\"),\n            (\"code.rs\", \"text/x-rust\"),\n            (\"data.json\", \"application/json\"),\n            (\"page.html\", \"text/html\"),\n        ];\n\n        for (file_name, _mime_type) in file_types {\n            let request = Request::new(AddDocumentRequest {\n                file_path: format!(\"/test/{}\", file_name),\n                collection_name: \"test_collection\".to_string(),\n                content: Some(DocumentContent {\n                    text: format!(\"Content for {}\", file_name),\n                    chunks: vec![],\n                    extracted_metadata: HashMap::new(),\n                }),\n                metadata: HashMap::new(),\n                project_id: \"test_project\".to_string(),\n            });\n\n            let result = service.add_document(request).await;\n            assert!(result.is_ok(), \"Failed to add document: {}\", file_name);\n\n            let response = result.unwrap().into_inner();\n            assert!(response.success);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_update_document_basic() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(UpdateDocumentRequest {\n            document_id: \"test_doc_123\".to_string(),\n            content: Some(DocumentContent {\n                text: \"Updated document content\".to_string(),\n                chunks: vec![],\n                extracted_metadata: HashMap::new(),\n            }),\n            metadata: HashMap::new(),\n        });\n\n        let result = service.update_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.success);\n        assert!(response.error_message.is_empty());\n        assert!(response.updated_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_update_document_timestamp() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let before_update = chrono::Utc::now().timestamp();\n\n        let request = Request::new(UpdateDocumentRequest {\n            document_id: \"timestamp_test_doc\".to_string(),\n            content: Some(DocumentContent {\n                text: \"Timestamp test content\".to_string(),\n                chunks: vec![],\n                extracted_metadata: HashMap::new(),\n            }),\n            metadata: HashMap::new(),\n        });\n\n        let result = service.update_document(request).await;\n        assert!(result.is_ok());\n\n        let after_update = chrono::Utc::now().timestamp();\n        let response = result.unwrap().into_inner();\n\n        assert!(response.updated_at.is_some());\n        let updated_timestamp = response.updated_at.unwrap().seconds;\n        assert!(updated_timestamp >= before_update);\n        assert!(updated_timestamp <= after_update);\n    }\n\n    #[tokio::test]\n    async fn test_remove_document() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(RemoveDocumentRequest {\n            document_id: \"doc_to_remove\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n        });\n\n        let result = service.remove_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_get_document() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let document_id = \"test_document_123\";\n        let collection_name = \"test_collection\";\n\n        let request = Request::new(GetDocumentRequest {\n            document_id: document_id.to_string(),\n            collection_name: collection_name.to_string(),\n        });\n\n        let result = service.get_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.document_id, document_id);\n        assert!(response.content.is_some());\n        assert!(response.created_at.is_some());\n        assert!(response.updated_at.is_some());\n\n        let content = response.content.unwrap();\n        assert_eq!(content.text, \"Example document content\");\n    }\n\n    #[tokio::test]\n    async fn test_get_document_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(GetDocumentRequest {\n            document_id: \"timestamp_doc\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n        });\n\n        let result = service.get_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.created_at.is_some());\n        assert!(response.updated_at.is_some());\n\n        let created_timestamp = response.created_at.unwrap().seconds;\n        let updated_timestamp = response.updated_at.unwrap().seconds;\n\n        // Updated should be after created (or equal)\n        assert!(updated_timestamp >= created_timestamp);\n    }\n\n    #[tokio::test]\n    async fn test_list_documents() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(ListDocumentsRequest {\n            collection_name: \"test_collection\".to_string(),\n            project_id: \"test_project\".to_string(),\n            limit: 10,\n            offset: 0,\n            filter: None,\n        });\n\n        let result = service.list_documents(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.documents.len(), 1);\n        assert_eq!(response.total_count, 1);\n        assert!(!response.has_more);\n\n        let document = &response.documents[0];\n        assert!(!document.document_id.is_empty());\n        assert_eq!(document.file_path, \"/example/document.txt\");\n        assert_eq!(document.title, \"Example Document\");\n        assert_eq!(document.file_size, 1024);\n        assert!(document.created_at.is_some());\n        assert!(document.updated_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_list_documents_pagination() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let pagination_params = [\n            (10, 0),   // First page\n            (5, 5),    // Second page\n            (1, 0),    // Single result\n            (20, 10),  // Larger offset\n        ];\n\n        for (limit, offset) in pagination_params {\n            let request = Request::new(ListDocumentsRequest {\n                collection_name: \"test_collection\".to_string(),\n                project_id: \"test_project\".to_string(),\n                limit,\n                offset,\n                filter: None,\n            });\n\n            let result = service.list_documents(request).await;\n            assert!(result.is_ok(), \"Failed for limit={}, offset={}\", limit, offset);\n\n            let response = result.unwrap().into_inner();\n            assert!(response.total_count >= 0);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_create_collection() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(CreateCollectionRequest {\n            collection_name: \"new_collection\".to_string(),\n            project_id: \"test_project\".to_string(),\n            config: Some(crate::proto::CollectionConfig {\n                vector_size: 384,\n                distance_metric: \"Cosine\".to_string(),\n                enable_indexing: true,\n                metadata_schema: HashMap::new(),\n            }),\n        });\n\n        let result = service.create_collection(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.success);\n        assert!(response.error_message.is_empty());\n        assert!(!response.collection_id.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_create_collection_different_configs() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let configs = [\n            (384, \"Cosine\", true),\n            (512, \"Euclidean\", false),\n            (768, \"Dot\", true),\n            (256, \"Cosine\", false),\n        ];\n\n        for (i, (vector_size, distance_metric, enable_indexing)) in configs.iter().enumerate() {\n            let request = Request::new(CreateCollectionRequest {\n                collection_name: format!(\"collection_{}\", i),\n                project_id: \"test_project\".to_string(),\n                config: Some(crate::proto::CollectionConfig {\n                    vector_size: *vector_size,\n                    distance_metric: distance_metric.to_string(),\n                    enable_indexing: *enable_indexing,\n                    metadata_schema: HashMap::new(),\n                }),\n            });\n\n            let result = service.create_collection(request).await;\n            assert!(result.is_ok(), \"Failed for config: {:?}\", (vector_size, distance_metric, enable_indexing));\n\n            let response = result.unwrap().into_inner();\n            assert!(response.success);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_delete_collection() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(DeleteCollectionRequest {\n            collection_name: \"collection_to_delete\".to_string(),\n            project_id: \"test_project\".to_string(),\n            force: false,\n        });\n\n        let result = service.delete_collection(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_delete_collection_force() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(DeleteCollectionRequest {\n            collection_name: \"force_delete_collection\".to_string(),\n            project_id: \"test_project\".to_string(),\n            force: true,\n        });\n\n        let result = service.delete_collection(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_list_collections() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let project_id = \"test_project\";\n        let request = Request::new(ListCollectionsRequest {\n            project_id: project_id.to_string(),\n        });\n\n        let result = service.list_collections(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.collections.len(), 1);\n\n        let collection = &response.collections[0];\n        assert_eq!(collection.collection_name, \"example-collection\");\n        assert!(!collection.collection_id.is_empty());\n        assert_eq!(collection.project_id, project_id);\n        assert_eq!(collection.document_count, 10);\n        assert_eq!(collection.total_size_bytes, 10240);\n        assert!(collection.config.is_some());\n        assert!(collection.created_at.is_some());\n\n        let config = collection.config.as_ref().unwrap();\n        assert_eq!(config.vector_size, 384);\n        assert_eq!(config.distance_metric, \"Cosine\");\n        assert!(config.enable_indexing);\n    }\n\n    #[tokio::test]\n    async fn test_list_collections_different_projects() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let project_ids = [\n            \"project_1\",\n            \"project_2\",\n            \"my-awesome-project\",\n            \"test_project_123\",\n        ];\n\n        for project_id in project_ids {\n            let request = Request::new(ListCollectionsRequest {\n                project_id: project_id.to_string(),\n            });\n\n            let result = service.list_collections(request).await;\n            assert!(result.is_ok(), \"Failed for project: {}\", project_id);\n\n            let response = result.unwrap().into_inner();\n            assert_eq!(response.collections.len(), 1);\n            assert_eq!(response.collections[0].project_id, project_id);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_memory_operations() {\n        let daemon = create_test_daemon().await;\n        let service = Arc::new(MemoryServiceImpl::new(daemon));\n\n        let mut handles = vec![];\n\n        // Perform multiple concurrent operations\n        for i in 0..5 {\n            let service_clone = Arc::clone(&service);\n            let handle = tokio::spawn(async move {\n                // Add document\n                let add_request = Request::new(AddDocumentRequest {\n                    file_path: format!(\"/test/concurrent_doc_{}.txt\", i),\n                    collection_name: \"test_collection\".to_string(),\n                    content: Some(DocumentContent {\n                        text: format!(\"Concurrent document {}\", i),\n                        chunks: vec![],\n                        extracted_metadata: HashMap::new(),\n                    }),\n                    metadata: HashMap::new(),\n                    project_id: \"test_project\".to_string(),\n                });\n\n                let add_result = service_clone.add_document(add_request).await;\n\n                // List documents\n                let list_request = Request::new(ListDocumentsRequest {\n                    collection_name: \"test_collection\".to_string(),\n                    project_id: \"test_project\".to_string(),\n                    limit: 10,\n                    offset: 0,\n                    filter: None,\n                });\n\n                let list_result = service_clone.list_documents(list_request).await;\n\n                (add_result, list_result)\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all operations to complete\n        let results: Vec<_> = futures_util::future::join_all(handles).await;\n\n        // All operations should complete successfully\n        for (i, result) in results.into_iter().enumerate() {\n            let (add_result, list_result) = result.unwrap();\n            assert!(add_result.is_ok(), \"Add operation {} failed\", i);\n            assert!(list_result.is_ok(), \"List operation {} failed\", i);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_document_unique_ids() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let mut document_ids = std::collections::HashSet::new();\n\n        // Add multiple documents and verify unique IDs\n        for i in 0..5 {\n            let request = Request::new(AddDocumentRequest {\n                file_path: format!(\"/test/unique_doc_{}.txt\", i),\n                collection_name: \"test_collection\".to_string(),\n                content: Some(DocumentContent {\n                    text: format!(\"Unique document {}\", i),\n                    chunks: vec![],\n                    extracted_metadata: HashMap::new(),\n                }),\n                metadata: HashMap::new(),\n                project_id: \"test_project\".to_string(),\n            });\n\n            let result = service.add_document(request).await;\n            assert!(result.is_ok());\n\n            let response = result.unwrap().into_inner();\n            assert!(document_ids.insert(response.document_id.clone()),\n                    \"Duplicate document ID generated: {}\", response.document_id);\n        }\n\n        assert_eq!(document_ids.len(), 5);\n    }\n\n    #[tokio::test]\n    async fn test_collection_unique_ids() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let mut collection_ids = std::collections::HashSet::new();\n\n        // Create multiple collections and verify unique IDs\n        for i in 0..5 {\n            let request = Request::new(CreateCollectionRequest {\n                collection_name: format!(\"unique_collection_{}\", i),\n                project_id: \"test_project\".to_string(),\n                config: Some(crate::proto::CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    metadata_schema: HashMap::new(),\n                }),\n            });\n\n            let result = service.create_collection(request).await;\n            assert!(result.is_ok());\n\n            let response = result.unwrap().into_inner();\n            assert!(collection_ids.insert(response.collection_id.clone()),\n                    \"Duplicate collection ID generated: {}\", response.collection_id);\n        }\n\n        assert_eq!(collection_ids.len(), 5);\n    }\n\n    #[test]\n    fn test_memory_service_impl_send_sync() {\n        fn assert_send<T: Send>() {}\n        fn assert_sync<T: Sync>() {}\n\n        assert_send::<MemoryServiceImpl>();\n        assert_sync::<MemoryServiceImpl>();\n    }\n}","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":22}}],"covered":1,"coverable":1},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","grpc","services","mod.rs"],"content":"//! gRPC service implementations\n\npub mod document_processor;\npub mod search_service;\npub mod memory_service;\npub mod system_service;\n\npub use document_processor::DocumentProcessorImpl;\npub use search_service::SearchServiceImpl;\npub use memory_service::MemoryServiceImpl;\npub use system_service::SystemServiceImpl;","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","grpc","services","search_service.rs"],"content":"//! Search service gRPC implementation\n\nuse crate::daemon::WorkspaceDaemon;\nuse crate::proto::{\n    search_service_server::SearchService,\n    HybridSearchRequest, HybridSearchResponse,\n    SemanticSearchRequest, SemanticSearchResponse,\n    KeywordSearchRequest, KeywordSearchResponse,\n    SuggestionsRequest, SuggestionsResponse,\n    SearchResult, SearchMetadata,\n};\nuse std::sync::Arc;\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, error, info};\n\n/// Search service implementation\n#[derive(Debug)]\npub struct SearchServiceImpl {\n    daemon: Arc<WorkspaceDaemon>,\n}\n\nimpl SearchServiceImpl {\n    pub fn new(daemon: Arc<WorkspaceDaemon>) -> Self {\n        Self { daemon }\n    }\n}\n\n#[tonic::async_trait]\nimpl SearchService for SearchServiceImpl {\n    async fn hybrid_search(\n        &self,\n        request: Request<HybridSearchRequest>,\n    ) -> Result<Response<HybridSearchResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Hybrid search requested: {}\", req.query);\n\n        // TODO: Implement actual hybrid search\n        let response = HybridSearchResponse {\n            results: vec![\n                SearchResult {\n                    document_id: uuid::Uuid::new_v4().to_string(),\n                    collection_name: \"example\".to_string(),\n                    score: 0.95,\n                    semantic_score: 0.9,\n                    keyword_score: 0.85,\n                    title: \"Example Document\".to_string(),\n                    content_snippet: \"This is an example search result...\".to_string(),\n                    metadata: std::collections::HashMap::new(),\n                    file_path: \"/path/to/document.txt\".to_string(),\n                    matched_terms: vec![\"example\".to_string()],\n                },\n            ],\n            metadata: Some(SearchMetadata {\n                total_results: 1,\n                max_score: 0.95,\n                search_time: Some(prost_types::Timestamp {\n                    seconds: chrono::Utc::now().timestamp(),\n                    nanos: 0,\n                }),\n                search_duration_ms: 25,\n                searched_collections: vec![\"example\".to_string()],\n            }),\n            query_id: uuid::Uuid::new_v4().to_string(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn semantic_search(\n        &self,\n        request: Request<SemanticSearchRequest>,\n    ) -> Result<Response<SemanticSearchResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Semantic search requested: {}\", req.query);\n\n        // TODO: Implement actual semantic search\n        let response = SemanticSearchResponse {\n            results: vec![],\n            metadata: Some(SearchMetadata {\n                total_results: 0,\n                max_score: 0.0,\n                search_time: Some(prost_types::Timestamp {\n                    seconds: chrono::Utc::now().timestamp(),\n                    nanos: 0,\n                }),\n                search_duration_ms: 15,\n                searched_collections: vec![],\n            }),\n            query_id: uuid::Uuid::new_v4().to_string(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn keyword_search(\n        &self,\n        request: Request<KeywordSearchRequest>,\n    ) -> Result<Response<KeywordSearchResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Keyword search requested: {}\", req.query);\n\n        // TODO: Implement actual keyword search\n        let response = KeywordSearchResponse {\n            results: vec![],\n            metadata: Some(SearchMetadata {\n                total_results: 0,\n                max_score: 0.0,\n                search_time: Some(prost_types::Timestamp {\n                    seconds: chrono::Utc::now().timestamp(),\n                    nanos: 0,\n                }),\n                search_duration_ms: 10,\n                searched_collections: vec![],\n            }),\n            query_id: uuid::Uuid::new_v4().to_string(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn get_suggestions(\n        &self,\n        request: Request<SuggestionsRequest>,\n    ) -> Result<Response<SuggestionsResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Suggestions requested for: {}\", req.partial_query);\n\n        // TODO: Implement actual suggestions\n        let response = SuggestionsResponse {\n            suggestions: vec![\n                format!(\"{} complete\", req.partial_query),\n                format!(\"{} suggestion\", req.partial_query),\n            ],\n            metadata: Some(SearchMetadata {\n                total_results: 2,\n                max_score: 1.0,\n                search_time: Some(prost_types::Timestamp {\n                    seconds: chrono::Utc::now().timestamp(),\n                    nanos: 0,\n                }),\n                search_duration_ms: 5,\n                searched_collections: vec![],\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use tempfile::TempDir;\n    use tonic::Request;\n    use tokio_test;\n    use std::collections::HashMap;\n\n    fn create_test_daemon_config() -> DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\";\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50054,\n                max_connections: 100,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 60,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path.to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 2,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 1024 * 1024,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 10,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    async fn create_test_daemon() -> Arc<WorkspaceDaemon> {\n        let config = create_test_daemon_config();\n        Arc::new(WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\"))\n    }\n\n    // Helper function to create proper HybridSearchRequest\n    fn create_hybrid_search_request(\n        query: &str,\n        semantic_weight: f32,\n        keyword_weight: f32,\n        limit: i32,\n        collection_names: Vec<String>\n    ) -> HybridSearchRequest {\n        HybridSearchRequest {\n            query: query.to_string(),\n            context: crate::proto::SearchContext::Project as i32,\n            options: Some(crate::proto::SearchOptions {\n                limit,\n                score_threshold: 0.0,\n                include_metadata: true,\n                include_content: true,\n                ranking: Some(crate::proto::RankingOptions {\n                    semantic_weight,\n                    keyword_weight,\n                    rrf_constant: 60.0,\n                }),\n            }),\n            project_id: \"test_project\".to_string(),\n            collection_names,\n        }\n    }\n\n    // Helper function to create SemanticSearchRequest\n    fn create_semantic_search_request(\n        query: &str,\n        similarity_threshold: f32,\n        limit: i32,\n        collection_names: Vec<String>\n    ) -> SemanticSearchRequest {\n        SemanticSearchRequest {\n            query: query.to_string(),\n            context: crate::proto::SearchContext::Project as i32,\n            options: Some(crate::proto::SearchOptions {\n                limit,\n                score_threshold: similarity_threshold,\n                include_metadata: true,\n                include_content: true,\n                ranking: None,\n            }),\n            project_id: \"test_project\".to_string(),\n            collection_names,\n        }\n    }\n\n    // Helper function to create KeywordSearchRequest\n    fn create_keyword_search_request(\n        query: &str,\n        limit: i32,\n        collection_names: Vec<String>\n    ) -> KeywordSearchRequest {\n        KeywordSearchRequest {\n            query: query.to_string(),\n            context: crate::proto::SearchContext::Project as i32,\n            options: Some(crate::proto::SearchOptions {\n                limit,\n                score_threshold: 0.0,\n                include_metadata: true,\n                include_content: true,\n                ranking: None,\n            }),\n            project_id: \"test_project\".to_string(),\n            collection_names,\n        }\n    }\n\n    // Helper function to create SuggestionsRequest\n    fn create_suggestions_request(\n        partial_query: &str,\n        limit: i32,\n        collection_names: Vec<String>\n    ) -> SuggestionsRequest {\n        SuggestionsRequest {\n            partial_query: partial_query.to_string(),\n            context: crate::proto::SearchContext::Project as i32,\n            max_suggestions: limit,\n            project_id: \"test_project\".to_string(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_search_service_impl_new() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon.clone());\n\n        assert!(Arc::ptr_eq(&service.daemon, &daemon));\n    }\n\n    #[tokio::test]\n    async fn test_search_service_impl_debug() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let debug_str = format!(\"{:?}\", service);\n        assert!(debug_str.contains(\"SearchServiceImpl\"));\n        assert!(debug_str.contains(\"daemon\"));\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_search_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(HybridSearchRequest {\n            query: \"test query\".to_string(),\n            context: crate::proto::SearchContext::Collection as i32,\n            options: Some(crate::proto::SearchOptions {\n                limit: 10,\n                score_threshold: 0.0,\n                include_metadata: true,\n                include_content: true,\n                ranking: Some(crate::proto::RankingOptions {\n                    semantic_weight: 0.7,\n                    keyword_weight: 0.3,\n                    rrf_constant: 60.0,\n                }),\n            }),\n            project_id: \"test_project\".to_string(),\n            collection_names: vec![\"test_collection\".to_string()],\n        });\n\n        let result = service.hybrid_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.query_id.is_empty());\n        assert_eq!(response.results.len(), 1);\n        assert!(response.metadata.is_some());\n\n        let metadata = response.metadata.unwrap();\n        assert_eq!(metadata.total_results, 1);\n        assert_eq!(metadata.max_score, 0.95);\n        assert!(metadata.search_time.is_some());\n        assert_eq!(metadata.search_duration_ms, 25);\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_search_different_queries() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let queries = [\n            \"simple query\",\n            \"complex search with multiple terms\",\n            \"特殊字符查询\", // Unicode characters\n            \"query with symbols !@#$%\",\n            \"12345 numeric query\",\n        ];\n\n        for query in queries {\n            let request = Request::new(create_hybrid_search_request(\n                query,\n                0.6,\n                0.4,\n                5,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.hybrid_search(request).await;\n            assert!(result.is_ok(), \"Failed for query: {}\", query);\n\n            let response = result.unwrap().into_inner();\n            assert!(!response.query_id.is_empty());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_search_different_weights() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let weight_combinations = [\n            (1.0, 0.0), // Pure semantic\n            (0.0, 1.0), // Pure keyword\n            (0.5, 0.5), // Equal weights\n            (0.8, 0.2), // Semantic-heavy\n            (0.3, 0.7), // Keyword-heavy\n        ];\n\n        for (semantic, keyword) in weight_combinations {\n            let request = Request::new(create_hybrid_search_request(\n                \"test query\",\n                semantic,\n                keyword,\n                10,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.hybrid_search(request).await;\n            assert!(result.is_ok(), \"Failed for weights: semantic={}, keyword={}\", semantic, keyword);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_search_metadata_validation() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(create_hybrid_search_request(\n            \"test query with metadata\",\n            0.7,\n            0.3,\n            10,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.hybrid_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.query_id.is_empty());\n        assert!(response.metadata.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_search_pagination() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let pagination_params = [\n            (10, 0),   // First page\n            (10, 10),  // Second page\n            (5, 0),    // Smaller page size\n            (20, 40),  // Larger offset\n            (1, 0),    // Single result\n        ];\n\n        for (limit, _offset) in pagination_params {\n            let request = Request::new(create_hybrid_search_request(\n                \"pagination test\",\n                0.7,\n                0.3,\n                limit,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.hybrid_search(request).await;\n            assert!(result.is_ok(), \"Failed for limit={}\", limit);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_semantic_search_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(create_semantic_search_request(\n            \"semantic search query\",\n            0.7,\n            10,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.semantic_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.query_id.is_empty());\n        assert!(response.metadata.is_some());\n\n        let metadata = response.metadata.unwrap();\n        assert!(metadata.search_time.is_some());\n        assert_eq!(metadata.search_duration_ms, 15);\n    }\n\n    #[tokio::test]\n    async fn test_semantic_search_different_thresholds() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let thresholds = [0.1, 0.3, 0.5, 0.7, 0.9];\n\n        for threshold in thresholds {\n            let request = Request::new(create_semantic_search_request(\n                \"threshold test\",\n                threshold,\n                10,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.semantic_search(request).await;\n            assert!(result.is_ok(), \"Failed for threshold: {}\", threshold);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_keyword_search_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(create_keyword_search_request(\n            \"keyword search\",\n            10,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.keyword_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.query_id.is_empty());\n        assert!(response.metadata.is_some());\n\n        let metadata = response.metadata.unwrap();\n        assert!(metadata.search_time.is_some());\n        assert_eq!(metadata.search_duration_ms, 10);\n    }\n\n    #[tokio::test]\n    async fn test_keyword_search_with_different_limits() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let limits = [1, 5, 10, 20, 50];\n\n        for limit in limits {\n            let request = Request::new(create_keyword_search_request(\n                \"limit test search\",\n                limit,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.keyword_search(request).await;\n            assert!(result.is_ok(), \"Failed for limit: {}\", limit);\n\n            let response = result.unwrap().into_inner();\n            assert!(!response.query_id.is_empty());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_keyword_search_different_queries() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let queries = [\"simple\", \"complex search terms\", \"special!@#$%\", \"numbers123\"];\n\n        for query in queries {\n            let request = Request::new(create_keyword_search_request(\n                query,\n                10,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.keyword_search(request).await;\n            assert!(result.is_ok(), \"Failed for query: {}\", query);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_suggestions_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(create_suggestions_request(\n            \"test\",\n            5,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.get_suggestions(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.suggestions.len(), 2);\n        assert!(response.suggestions[0].contains(\"test\"));\n        assert!(response.suggestions[1].contains(\"test\"));\n        assert!(response.metadata.is_some());\n\n        let metadata = response.metadata.unwrap();\n        assert_eq!(metadata.total_results, 2);\n        assert_eq!(metadata.search_duration_ms, 5);\n    }\n\n    #[tokio::test]\n    async fn test_get_suggestions_different_queries() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let partial_queries = [\n            \"t\",\n            \"te\",\n            \"test\",\n            \"testing\",\n            \"query\",\n            \"search\",\n        ];\n\n        for partial in partial_queries {\n            let request = Request::new(create_suggestions_request(\n                partial,\n                5,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.get_suggestions(request).await;\n            assert!(result.is_ok(), \"Failed for partial query: {}\", partial);\n\n            let response = result.unwrap().into_inner();\n            assert_eq!(response.suggestions.len(), 2);\n            for suggestion in &response.suggestions {\n                assert!(suggestion.contains(partial));\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_suggestions_different_limits() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let limits = [1, 3, 5, 10, 20];\n\n        for limit in limits {\n            let request = Request::new(create_suggestions_request(\n                \"suggestion\",\n                limit,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.get_suggestions(request).await;\n            assert!(result.is_ok(), \"Failed for limit: {}\", limit);\n\n            let response = result.unwrap().into_inner();\n            // Current implementation returns 2 suggestions regardless of limit\n            assert_eq!(response.suggestions.len(), 2);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_search_service_multiple_collections() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let collections = vec![\n            \"collection1\".to_string(),\n            \"collection2\".to_string(),\n            \"documents\".to_string(),\n            \"code\".to_string(),\n        ];\n\n        let request = Request::new(create_hybrid_search_request(\n            \"multi-collection search\",\n            0.7,\n            0.3,\n            10,\n            collections.clone()\n        ));\n\n        let result = service.hybrid_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.query_id.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_search_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let before_search = chrono::Utc::now().timestamp();\n\n        let request = Request::new(create_hybrid_search_request(\n            \"timestamp test\",\n            0.7,\n            0.3,\n            10,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.hybrid_search(request).await;\n        assert!(result.is_ok());\n\n        let after_search = chrono::Utc::now().timestamp();\n        let response = result.unwrap().into_inner();\n\n        assert!(response.metadata.is_some());\n        let metadata = response.metadata.unwrap();\n        assert!(metadata.search_time.is_some());\n\n        let search_timestamp = metadata.search_time.unwrap().seconds;\n        assert!(search_timestamp >= before_search);\n        assert!(search_timestamp <= after_search);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_searches() {\n        let daemon = create_test_daemon().await;\n        let service = Arc::new(SearchServiceImpl::new(daemon));\n\n        let mut handles = vec![];\n\n        // Perform multiple concurrent searches\n        for i in 0..5 {\n            let service_clone = Arc::clone(&service);\n            let handle = tokio::spawn(async move {\n                let request = Request::new(create_hybrid_search_request(\n                    &format!(\"concurrent search {}\", i),\n                    0.7,\n                    0.3,\n                    10,\n                    vec![\"test_collection\".to_string()]\n                ));\n\n                service_clone.hybrid_search(request).await\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all searches to complete\n        let results: Vec<_> = futures_util::future::join_all(handles).await;\n\n        // All searches should complete successfully\n        for (i, result) in results.into_iter().enumerate() {\n            let task_result = result.unwrap();\n            assert!(task_result.is_ok(), \"Search {} failed\", i);\n\n            let response = task_result.unwrap().into_inner();\n            assert!(!response.query_id.is_empty());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_search_result_structure() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(create_hybrid_search_request(\n            \"structure test\",\n            0.7,\n            0.3,\n            10,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.hybrid_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.results.len(), 1);\n\n        let search_result = &response.results[0];\n        assert!(!search_result.document_id.is_empty());\n        assert_eq!(search_result.collection_name, \"example\");\n        assert_eq!(search_result.score, 0.95);\n        assert_eq!(search_result.semantic_score, 0.9);\n        assert_eq!(search_result.keyword_score, 0.85);\n        assert_eq!(search_result.title, \"Example Document\");\n        assert!(!search_result.content_snippet.is_empty());\n        assert!(!search_result.file_path.is_empty());\n        assert_eq!(search_result.matched_terms.len(), 1);\n    }\n\n    #[test]\n    fn test_search_service_impl_send_sync() {\n        fn assert_send<T: Send>() {}\n        fn assert_sync<T: Sync>() {}\n\n        assert_send::<SearchServiceImpl>();\n        assert_sync::<SearchServiceImpl>();\n    }\n}","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":20}}],"covered":1,"coverable":1},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","grpc","services","system_service.rs"],"content":"//! System administration gRPC service implementation\n\nuse crate::daemon::WorkspaceDaemon;\nuse crate::proto::{\n    system_service_server::SystemService,\n    HealthCheckResponse, SystemStatusResponse, MetricsRequest, MetricsResponse,\n    ConfigResponse, UpdateConfigRequest, DetectProjectRequest, DetectProjectResponse,\n    ListProjectsResponse, ServiceStatus, ComponentHealth, SystemMetrics, ProjectInfo,\n};\nuse std::sync::Arc;\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, error, info};\n\n/// System service implementation\n#[derive(Debug)]\npub struct SystemServiceImpl {\n    daemon: Arc<WorkspaceDaemon>,\n}\n\nimpl SystemServiceImpl {\n    pub fn new(daemon: Arc<WorkspaceDaemon>) -> Self {\n        Self { daemon }\n    }\n}\n\n#[tonic::async_trait]\nimpl SystemService for SystemServiceImpl {\n    async fn health_check(\n        &self,\n        _request: Request<()>,\n    ) -> Result<Response<HealthCheckResponse>, Status> {\n        debug!(\"Health check requested\");\n\n        // TODO: Implement actual health checks\n        let response = HealthCheckResponse {\n            status: ServiceStatus::Healthy as i32,\n            components: vec![\n                ComponentHealth {\n                    component_name: \"database\".to_string(),\n                    status: ServiceStatus::Healthy as i32,\n                    message: \"SQLite database operational\".to_string(),\n                    last_check: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n                ComponentHealth {\n                    component_name: \"qdrant\".to_string(),\n                    status: ServiceStatus::Healthy as i32,\n                    message: \"Qdrant connection active\".to_string(),\n                    last_check: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n                ComponentHealth {\n                    component_name: \"file_watcher\".to_string(),\n                    status: ServiceStatus::Healthy as i32,\n                    message: \"File watching active\".to_string(),\n                    last_check: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n            ],\n            timestamp: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn get_status(\n        &self,\n        _request: Request<()>,\n    ) -> Result<Response<SystemStatusResponse>, Status> {\n        debug!(\"System status requested\");\n\n        // TODO: Implement actual system status collection\n        let response = SystemStatusResponse {\n            status: ServiceStatus::Healthy as i32,\n            metrics: Some(SystemMetrics {\n                cpu_usage_percent: 15.5,\n                memory_usage_bytes: 128 * 1024 * 1024, // 128MB\n                memory_total_bytes: 8 * 1024 * 1024 * 1024, // 8GB\n                disk_usage_bytes: 2 * 1024 * 1024 * 1024, // 2GB\n                disk_total_bytes: 500 * 1024 * 1024 * 1024, // 500GB\n                active_connections: 5,\n                pending_operations: 0,\n            }),\n            active_projects: vec![\"workspace-qdrant-mcp\".to_string()],\n            total_documents: 1000,\n            total_collections: 5,\n            uptime_since: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp() - 3600, // 1 hour ago\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn get_metrics(\n        &self,\n        request: Request<MetricsRequest>,\n    ) -> Result<Response<MetricsResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Metrics requested: {:?}\", req.metric_names);\n\n        // TODO: Implement actual metrics collection\n        let response = MetricsResponse {\n            metrics: vec![\n                crate::proto::Metric {\n                    name: \"grpc_requests_total\".to_string(),\n                    r#type: \"counter\".to_string(),\n                    labels: [(\"method\".to_string(), \"ProcessDocument\".to_string())].into_iter().collect(),\n                    value: 150.0,\n                    timestamp: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n                crate::proto::Metric {\n                    name: \"document_processing_duration_seconds\".to_string(),\n                    r#type: \"histogram\".to_string(),\n                    labels: [(\"status\".to_string(), \"success\".to_string())].into_iter().collect(),\n                    value: 2.5,\n                    timestamp: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n            ],\n            collected_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn get_config(\n        &self,\n        _request: Request<()>,\n    ) -> Result<Response<ConfigResponse>, Status> {\n        debug!(\"Configuration requested\");\n\n        let config = self.daemon.config();\n\n        // Convert configuration to string map\n        let mut configuration = std::collections::HashMap::new();\n        configuration.insert(\"server.host\".to_string(), config.server.host.clone());\n        configuration.insert(\"server.port\".to_string(), config.server.port.to_string());\n        configuration.insert(\"qdrant.url\".to_string(), config.qdrant.url.clone());\n        configuration.insert(\"database.sqlite_path\".to_string(), config.database.sqlite_path.clone());\n        configuration.insert(\"processing.max_concurrent_tasks\".to_string(), config.processing.max_concurrent_tasks.to_string());\n\n        let response = ConfigResponse {\n            configuration,\n            version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn update_config(\n        &self,\n        request: Request<UpdateConfigRequest>,\n    ) -> Result<Response<()>, Status> {\n        let req = request.into_inner();\n        info!(\"Configuration update requested: {:?}\", req.configuration);\n\n        // TODO: Implement configuration updates\n        // For now, just log the request\n\n        if req.restart_required {\n            info!(\"Configuration update requires restart\");\n        }\n\n        Ok(Response::new(()))\n    }\n\n    async fn detect_project(\n        &self,\n        request: Request<DetectProjectRequest>,\n    ) -> Result<Response<DetectProjectResponse>, Status> {\n        let req = request.into_inner();\n        debug!(\"Project detection requested for: {}\", req.path);\n\n        // TODO: Implement actual project detection\n        let response = DetectProjectResponse {\n            project: Some(ProjectInfo {\n                project_id: uuid::Uuid::new_v4().to_string(),\n                name: \"example-project\".to_string(),\n                root_path: req.path.clone(),\n                git_repository: \"https://github.com/example/project.git\".to_string(),\n                git_branch: \"main\".to_string(),\n                submodules: vec![],\n                metadata: [(\"detected_at\".to_string(), chrono::Utc::now().to_rfc3339())].into_iter().collect(),\n                detected_at: Some(prost_types::Timestamp {\n                    seconds: chrono::Utc::now().timestamp(),\n                    nanos: 0,\n                }),\n            }),\n            is_valid_project: true,\n            reasons: vec![\"Git repository detected\".to_string()],\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn list_projects(\n        &self,\n        _request: Request<()>,\n    ) -> Result<Response<ListProjectsResponse>, Status> {\n        debug!(\"Project list requested\");\n\n        // TODO: Implement actual project listing\n        let response = ListProjectsResponse {\n            projects: vec![\n                ProjectInfo {\n                    project_id: uuid::Uuid::new_v4().to_string(),\n                    name: \"workspace-qdrant-mcp\".to_string(),\n                    root_path: \"/Users/example/workspace-qdrant-mcp\".to_string(),\n                    git_repository: \"https://github.com/example/workspace-qdrant-mcp.git\".to_string(),\n                    git_branch: \"main\".to_string(),\n                    submodules: vec![],\n                    metadata: [(\"language\".to_string(), \"rust,python\".to_string())].into_iter().collect(),\n                    detected_at: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp() - 86400, // 1 day ago\n                        nanos: 0,\n                    }),\n                },\n            ],\n        };\n\n        Ok(Response::new(response))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use tempfile::TempDir;\n    use tonic::Request;\n    use tokio_test;\n    use std::collections::HashMap;\n\n    fn create_test_daemon_config() -> DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\";\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50051,\n                max_connections: 100,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 60,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path.to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: crate::config::CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 4,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 1024 * 1024,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 10,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    async fn create_test_daemon() -> Arc<WorkspaceDaemon> {\n        let config = create_test_daemon_config();\n        Arc::new(WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\"))\n    }\n\n    #[tokio::test]\n    async fn test_system_service_impl_new() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon.clone());\n\n        assert!(Arc::ptr_eq(&service.daemon, &daemon));\n    }\n\n    #[tokio::test]\n    async fn test_system_service_impl_debug() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let debug_str = format!(\"{:?}\", service);\n        assert!(debug_str.contains(\"SystemServiceImpl\"));\n        assert!(debug_str.contains(\"daemon\"));\n    }\n\n    #[tokio::test]\n    async fn test_health_check() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.health_check(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.status, ServiceStatus::Healthy as i32);\n        assert_eq!(response.components.len(), 3);\n        assert!(response.timestamp.is_some());\n\n        // Check individual components\n        let component_names: Vec<_> = response.components.iter()\n            .map(|c| c.component_name.as_str())\n            .collect();\n        assert!(component_names.contains(&\"database\"));\n        assert!(component_names.contains(&\"qdrant\"));\n        assert!(component_names.contains(&\"file_watcher\"));\n\n        // All components should be healthy\n        for component in &response.components {\n            assert_eq!(component.status, ServiceStatus::Healthy as i32);\n            assert!(!component.message.is_empty());\n            assert!(component.last_check.is_some());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_health_check_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let before_check = chrono::Utc::now().timestamp();\n        let request = Request::new(());\n        let result = service.health_check(request).await;\n        let after_check = chrono::Utc::now().timestamp();\n\n        assert!(result.is_ok());\n        let response = result.unwrap().into_inner();\n\n        // Main timestamp\n        assert!(response.timestamp.is_some());\n        let timestamp = response.timestamp.unwrap().seconds;\n        assert!(timestamp >= before_check && timestamp <= after_check);\n\n        // Component timestamps\n        for component in &response.components {\n            assert!(component.last_check.is_some());\n            let component_timestamp = component.last_check.as_ref().unwrap().seconds;\n            assert!(component_timestamp >= before_check && component_timestamp <= after_check);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_status() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.get_status(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.status, ServiceStatus::Healthy as i32);\n        assert!(response.metrics.is_some());\n        assert_eq!(response.active_projects.len(), 1);\n        assert_eq!(response.active_projects[0], \"workspace-qdrant-mcp\");\n        assert_eq!(response.total_documents, 1000);\n        assert_eq!(response.total_collections, 5);\n        assert!(response.uptime_since.is_some());\n\n        // Check metrics\n        let metrics = response.metrics.unwrap();\n        assert_eq!(metrics.cpu_usage_percent, 15.5);\n        assert_eq!(metrics.memory_usage_bytes, 128 * 1024 * 1024);\n        assert_eq!(metrics.memory_total_bytes, 8 * 1024 * 1024 * 1024);\n        assert_eq!(metrics.disk_usage_bytes, 2 * 1024 * 1024 * 1024);\n        assert_eq!(metrics.disk_total_bytes, 500 * 1024 * 1024 * 1024);\n        assert_eq!(metrics.active_connections, 5);\n        assert_eq!(metrics.pending_operations, 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_status_uptime() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.get_status(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.uptime_since.is_some());\n\n        let uptime_timestamp = response.uptime_since.unwrap().seconds;\n        let current_time = chrono::Utc::now().timestamp();\n\n        // Uptime should be in the past (simulated as 1 hour ago)\n        assert!(uptime_timestamp < current_time);\n        assert!(current_time - uptime_timestamp >= 3500); // Allow some margin\n    }\n\n    #[tokio::test]\n    async fn test_get_metrics_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(MetricsRequest {\n            since: None,\n            metric_names: vec![\"grpc_requests_total\".to_string()],\n        });\n\n        let result = service.get_metrics(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.metrics.len(), 2);\n        assert!(response.collected_at.is_some());\n\n        // Check specific metrics\n        let grpc_metric = response.metrics.iter()\n            .find(|m| m.name == \"grpc_requests_total\")\n            .expect(\"grpc_requests_total metric not found\");\n        assert_eq!(grpc_metric.r#type, \"counter\");\n        assert_eq!(grpc_metric.value, 150.0);\n        assert!(grpc_metric.labels.contains_key(\"method\"));\n        assert!(grpc_metric.timestamp.is_some());\n\n        let duration_metric = response.metrics.iter()\n            .find(|m| m.name == \"document_processing_duration_seconds\")\n            .expect(\"duration metric not found\");\n        assert_eq!(duration_metric.r#type, \"histogram\");\n        assert_eq!(duration_metric.value, 2.5);\n        assert!(duration_metric.labels.contains_key(\"status\"));\n    }\n\n    #[tokio::test]\n    async fn test_get_metrics_different_requests() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let metric_requests = [\n            vec![\"grpc_requests_total\".to_string()],\n            vec![\"document_processing_duration_seconds\".to_string()],\n            vec![\"grpc_requests_total\".to_string(), \"document_processing_duration_seconds\".to_string()],\n            vec![], // Empty list\n            vec![\"nonexistent_metric\".to_string()],\n        ];\n\n        for metrics in metric_requests {\n            let request = Request::new(MetricsRequest {\n                since: None,\n                metric_names: metrics.clone(),\n            });\n\n            let result = service.get_metrics(request).await;\n            assert!(result.is_ok(), \"Failed for metrics: {:?}\", metrics);\n\n            let response = result.unwrap().into_inner();\n            // Current implementation returns 2 metrics regardless of request\n            assert_eq!(response.metrics.len(), 2);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_metrics_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let before_request = chrono::Utc::now().timestamp();\n        let request = Request::new(MetricsRequest {\n            since: Some(prost_types::Timestamp {\n                seconds: before_request - 3600,\n                nanos: 0,\n            }),\n            metric_names: vec![\"test_metric\".to_string()],\n        });\n\n        let result = service.get_metrics(request).await;\n        let after_request = chrono::Utc::now().timestamp();\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.collected_at.is_some());\n\n        let collected_timestamp = response.collected_at.unwrap().seconds;\n        assert!(collected_timestamp >= before_request && collected_timestamp <= after_request);\n\n        // Check individual metric timestamps\n        for metric in &response.metrics {\n            assert!(metric.timestamp.is_some());\n            let metric_timestamp = metric.timestamp.as_ref().unwrap().seconds;\n            assert!(metric_timestamp >= before_request && metric_timestamp <= after_request);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_config() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.get_config(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.configuration.is_empty());\n        assert!(!response.version.is_empty());\n\n        // Check specific configuration values\n        assert_eq!(response.configuration.get(\"server.host\").unwrap(), \"127.0.0.1\");\n        assert_eq!(response.configuration.get(\"server.port\").unwrap(), \"50051\");\n        assert_eq!(response.configuration.get(\"qdrant.url\").unwrap(), \"http://localhost:6333\");\n        assert!(response.configuration.contains_key(\"database.sqlite_path\"));\n        assert_eq!(response.configuration.get(\"processing.max_concurrent_tasks\").unwrap(), \"4\");\n\n        // Check version format\n        let version = &response.version;\n        assert!(version.contains('.'), \"Version should contain dots: {}\", version);\n    }\n\n    #[tokio::test]\n    async fn test_update_config_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let mut config_updates = HashMap::new();\n        config_updates.insert(\"server.port\".to_string(), \"8080\".to_string());\n        config_updates.insert(\"processing.max_concurrent_tasks\".to_string(), \"8\".to_string());\n\n        let request = Request::new(UpdateConfigRequest {\n            configuration: config_updates,\n            restart_required: false,\n        });\n\n        let result = service.update_config(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_update_config_restart_required() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let mut config_updates = HashMap::new();\n        config_updates.insert(\"qdrant.url\".to_string(), \"http://new-host:6333\".to_string());\n\n        let request = Request::new(UpdateConfigRequest {\n            configuration: config_updates,\n            restart_required: true,\n        });\n\n        let result = service.update_config(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_detect_project() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(DetectProjectRequest {\n            path: \"/path/to/project\".to_string(),\n        });\n\n        let result = service.detect_project(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.project.is_some());\n        assert!(response.is_valid_project);\n        assert_eq!(response.reasons.len(), 1);\n        assert_eq!(response.reasons[0], \"Git repository detected\");\n\n        let project = response.project.unwrap();\n        assert!(!project.project_id.is_empty());\n        assert_eq!(project.name, \"example-project\");\n        assert_eq!(project.root_path, \"/path/to/project\");\n        assert_eq!(project.git_repository, \"https://github.com/example/project.git\");\n        assert_eq!(project.git_branch, \"main\");\n        assert!(project.submodules.is_empty());\n        assert!(project.metadata.contains_key(\"detected_at\"));\n        assert!(project.detected_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_detect_project_different_paths() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let test_paths = [\n            \"/home/user/project\",\n            \"/Users/developer/workspace/my-app\",\n            \"./relative/path\",\n            \"../parent/project\",\n            \"/very/deep/nested/project/structure\",\n        ];\n\n        for path in test_paths {\n            let request = Request::new(DetectProjectRequest {\n                path: path.to_string(),\n            });\n\n            let result = service.detect_project(request).await;\n            assert!(result.is_ok(), \"Failed for path: {}\", path);\n\n            let response = result.unwrap().into_inner();\n            assert!(response.project.is_some());\n            assert_eq!(response.project.unwrap().root_path, path);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_detect_project_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let before_detection = chrono::Utc::now().timestamp();\n        let request = Request::new(DetectProjectRequest {\n            path: \"/timestamp/test/project\".to_string(),\n        });\n\n        let result = service.detect_project(request).await;\n        let after_detection = chrono::Utc::now().timestamp();\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.project.is_some());\n\n        let project = response.project.unwrap();\n        assert!(project.detected_at.is_some());\n\n        let detected_timestamp = project.detected_at.unwrap().seconds;\n        assert!(detected_timestamp >= before_detection && detected_timestamp <= after_detection);\n    }\n\n    #[tokio::test]\n    async fn test_list_projects() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.list_projects(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.projects.len(), 1);\n\n        let project = &response.projects[0];\n        assert!(!project.project_id.is_empty());\n        assert_eq!(project.name, \"workspace-qdrant-mcp\");\n        assert_eq!(project.root_path, \"/Users/example/workspace-qdrant-mcp\");\n        assert_eq!(project.git_repository, \"https://github.com/example/workspace-qdrant-mcp.git\");\n        assert_eq!(project.git_branch, \"main\");\n        assert!(project.submodules.is_empty());\n        assert!(project.metadata.contains_key(\"language\"));\n        assert_eq!(project.metadata.get(\"language\").unwrap(), \"rust,python\");\n        assert!(project.detected_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_list_projects_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.list_projects(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.projects.len(), 1);\n\n        let project = &response.projects[0];\n        assert!(project.detected_at.is_some());\n\n        let detected_timestamp = project.detected_at.as_ref().unwrap().seconds;\n        let current_time = chrono::Utc::now().timestamp();\n\n        // Should be detected in the past (simulated as 1 day ago)\n        assert!(detected_timestamp < current_time);\n        assert!(current_time - detected_timestamp >= 86300); // Allow some margin for 1 day\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_system_operations() {\n        let daemon = create_test_daemon().await;\n        let service = Arc::new(SystemServiceImpl::new(daemon));\n\n        let mut handles = vec![];\n\n        // Perform multiple concurrent system operations\n        for i in 0..5 {\n            let service_clone = Arc::clone(&service);\n            let handle = tokio::spawn(async move {\n                // Health check\n                let health_request = Request::new(());\n                let health_result = service_clone.health_check(health_request).await;\n\n                // Get status\n                let status_request = Request::new(());\n                let status_result = service_clone.get_status(status_request).await;\n\n                // Get config\n                let config_request = Request::new(());\n                let config_result = service_clone.get_config(config_request).await;\n\n                // Project detection\n                let detect_request = Request::new(DetectProjectRequest {\n                    path: format!(\"/test/project_{}\", i),\n                });\n                let detect_result = service_clone.detect_project(detect_request).await;\n\n                (health_result, status_result, config_result, detect_result)\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all operations to complete\n        let results: Vec<_> = futures_util::future::join_all(handles).await;\n\n        // All operations should complete successfully\n        for (i, result) in results.into_iter().enumerate() {\n            let (health_result, status_result, config_result, detect_result) = result.unwrap();\n            assert!(health_result.is_ok(), \"Health check {} failed\", i);\n            assert!(status_result.is_ok(), \"Status check {} failed\", i);\n            assert!(config_result.is_ok(), \"Config check {} failed\", i);\n            assert!(detect_result.is_ok(), \"Project detection {} failed\", i);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_project_unique_ids() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let mut project_ids = std::collections::HashSet::new();\n\n        // Detect multiple projects and verify unique IDs\n        for i in 0..5 {\n            let request = Request::new(DetectProjectRequest {\n                path: format!(\"/test/unique_project_{}\", i),\n            });\n\n            let result = service.detect_project(request).await;\n            assert!(result.is_ok());\n\n            let response = result.unwrap().into_inner();\n            assert!(response.project.is_some());\n\n            let project = response.project.unwrap();\n            assert!(project_ids.insert(project.project_id.clone()),\n                    \"Duplicate project ID generated: {}\", project.project_id);\n        }\n\n        assert_eq!(project_ids.len(), 5);\n    }\n\n    #[tokio::test]\n    async fn test_metrics_labels_structure() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(MetricsRequest {\n            since: None,\n            metric_names: vec![\"test_metric\".to_string()],\n        });\n\n        let result = service.get_metrics(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.metrics.len(), 2);\n\n        for metric in &response.metrics {\n            assert!(!metric.name.is_empty());\n            assert!(!metric.r#type.is_empty());\n            assert!(!metric.labels.is_empty());\n            assert!(metric.value >= 0.0);\n            assert!(metric.timestamp.is_some());\n        }\n    }\n\n    #[test]\n    fn test_system_service_impl_send_sync() {\n        fn assert_send<T: Send>() {}\n        fn assert_sync<T: Sync>() {}\n\n        assert_send::<SystemServiceImpl>();\n        assert_sync::<SystemServiceImpl>();\n    }\n}","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":21}}],"covered":1,"coverable":1},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","lib.rs"],"content":"//! Workspace Qdrant Daemon Library\n//!\n//! This library provides the core functionality for the workspace document processing\n//! and vector search daemon.\n\npub mod config;\npub mod error;\npub mod daemon;\npub mod grpc;\n\n// Include generated protobuf code\npub mod proto {\n    tonic::include_proto!(\"workspace_daemon\");\n}\n\n// Re-export commonly used types\npub use config::*;\npub use error::*;","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","src","main.rs"],"content":"//! Workspace Qdrant Daemon\n//!\n//! High-performance Rust daemon for workspace document processing and vector search.\n//! Provides gRPC services for document processing, search operations, memory management,\n//! and system administration.\n\nuse anyhow::Result;\nuse clap::Parser;\nuse std::net::SocketAddr;\nuse tracing::{info, warn};\n\nmod grpc;\nmod daemon;\nmod config;\nmod error;\n\n// Include generated protobuf code\npub mod proto {\n    tonic::include_proto!(\"workspace_daemon\");\n}\n\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    /// gRPC server address\n    #[arg(short, long, default_value = \"127.0.0.1:50051\")]\n    address: SocketAddr,\n\n    /// Configuration file path\n    #[arg(short, long)]\n    config: Option<std::path::PathBuf>,\n\n    /// Log level\n    #[arg(short, long, default_value = \"info\")]\n    log_level: String,\n\n    /// Enable metrics collection\n    #[arg(long)]\n    enable_metrics: bool,\n\n    /// Daemon mode (run in background)\n    #[arg(short, long)]\n    daemon: bool,\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let args = Args::parse();\n\n    // Initialize tracing\n    init_tracing(&args.log_level)?;\n\n    info!(\"Starting Workspace Qdrant Daemon v{}\", env!(\"CARGO_PKG_VERSION\"));\n    info!(\"gRPC server will listen on: {}\", args.address);\n\n    // Load configuration\n    let config = config::DaemonConfig::load(args.config.as_deref())?;\n    info!(\"Configuration loaded successfully\");\n\n    // Initialize daemon\n    let mut daemon = daemon::WorkspaceDaemon::new(config).await?;\n\n    // Start daemon services\n    daemon.start().await?;\n\n    // Start gRPC server\n    let grpc_server = grpc::server::GrpcServer::new(daemon, args.address);\n\n    if args.daemon {\n        info!(\"Running in daemon mode\");\n        grpc_server.serve_daemon().await?;\n    } else {\n        info!(\"Running in foreground mode\");\n        grpc_server.serve().await?;\n    }\n\n    Ok(())\n}\n\nfn init_tracing(level: &str) -> Result<()> {\n    use tracing_subscriber::{fmt, prelude::*, EnvFilter};\n\n    let filter = EnvFilter::try_from_default_env()\n        .or_else(|_| EnvFilter::try_new(level))\n        .map_err(|e| anyhow::anyhow!(\"Invalid log level: {}\", e))?;\n\n    tracing_subscriber::registry()\n        .with(fmt::layer().with_target(false))\n        .with(filter)\n        .init();\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::Parser;\n\n    #[test]\n    fn test_args_default_values() {\n        let args = Args::parse_from(&[\"test\"]);\n\n        assert_eq!(args.address.to_string(), \"127.0.0.1:50051\");\n        assert_eq!(args.log_level, \"info\");\n        assert!(!args.enable_metrics);\n        assert!(!args.daemon);\n        assert!(args.config.is_none());\n    }\n\n    #[test]\n    fn test_args_custom_values() {\n        let args = Args::parse_from(&[\n            \"test\",\n            \"-a\", \"0.0.0.0:8080\",\n            \"-l\", \"debug\",\n            \"--enable-metrics\",\n            \"--daemon\",\n            \"-c\", \"/path/to/config.yaml\"\n        ]);\n\n        assert_eq!(args.address.to_string(), \"0.0.0.0:8080\");\n        assert_eq!(args.log_level, \"debug\");\n        assert!(args.enable_metrics);\n        assert!(args.daemon);\n        assert_eq!(args.config.unwrap().to_string_lossy(), \"/path/to/config.yaml\");\n    }\n\n    #[test]\n    fn test_args_debug_format() {\n        let args = Args::parse_from(&[\"test\"]);\n        let debug_str = format!(\"{:?}\", args);\n\n        assert!(debug_str.contains(\"Args\"));\n        assert!(debug_str.contains(\"127.0.0.1:50051\"));\n        assert!(debug_str.contains(\"info\"));\n    }\n\n    #[test]\n    fn test_init_tracing_valid_levels() {\n        // Test various valid log levels\n        let valid_levels = vec![\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n\n        for level in valid_levels {\n            // Note: We can't actually call init_tracing multiple times in tests\n            // because it would panic, so we just test the validation logic\n            let result = std::panic::catch_unwind(|| {\n                init_tracing(level)\n            });\n            // Should not panic for valid levels (though it may fail due to already initialized)\n            assert!(result.is_ok() || result.is_err()); // Either succeeds or fails gracefully\n        }\n    }\n\n    #[test]\n    fn test_init_tracing_invalid_level() {\n        let result = init_tracing(\"invalid_level\");\n        assert!(result.is_err());\n\n        let error_msg = result.unwrap_err().to_string();\n        assert!(error_msg.contains(\"Invalid log level\"));\n    }\n\n    #[test]\n    fn test_args_parser_help() {\n        // Test that the help text can be generated without panicking\n        let result = std::panic::catch_unwind(|| {\n            Args::parse_from(&[\"test\", \"--help\"])\n        });\n        // Should panic with help message (this is expected behavior for --help)\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_args_with_ipv6_address() {\n        let args = Args::parse_from(&[\n            \"test\",\n            \"-a\", \"[::1]:9090\"\n        ]);\n\n        assert_eq!(args.address.to_string(), \"[::1]:9090\");\n    }\n\n    #[test]\n    fn test_args_long_flags() {\n        let args = Args::parse_from(&[\n            \"test\",\n            \"--address\", \"192.168.1.1:3000\",\n            \"--log-level\", \"debug\",\n            \"--enable-metrics\",\n            \"--daemon\",\n            \"--config\", \"/etc/daemon.yaml\"\n        ]);\n\n        assert_eq!(args.address.to_string(), \"192.168.1.1:3000\");\n        assert_eq!(args.log_level, \"debug\");\n        assert!(args.enable_metrics);\n        assert!(args.daemon);\n        assert_eq!(args.config.unwrap().to_string_lossy(), \"/etc/daemon.yaml\");\n    }\n\n    #[test]\n    fn test_args_mixed_flags() {\n        let args = Args::parse_from(&[\n            \"test\",\n            \"-a\", \"0.0.0.0:8080\",\n            \"--log-level\", \"warn\",\n            \"--enable-metrics\"\n        ]);\n\n        assert_eq!(args.address.to_string(), \"0.0.0.0:8080\");\n        assert_eq!(args.log_level, \"warn\");\n        assert!(args.enable_metrics);\n        assert!(!args.daemon);\n    }\n\n    #[test]\n    fn test_args_version_flag() {\n        let result = std::panic::catch_unwind(|| {\n            Args::parse_from(&[\"test\", \"--version\"])\n        });\n        // Should panic with version message (this is expected behavior for --version)\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_args_invalid_address() {\n        let result = std::panic::catch_unwind(|| {\n            Args::parse_from(&[\"test\", \"-a\", \"invalid_address\"])\n        });\n        // Should panic due to invalid socket address format\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_args_invalid_port() {\n        let result = std::panic::catch_unwind(|| {\n            Args::parse_from(&[\"test\", \"-a\", \"127.0.0.1:99999\"])\n        });\n        // Should panic due to invalid port number\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_args_empty_config_path() {\n        let args = Args::parse_from(&[\n            \"test\",\n            \"--config\", \"\"\n        ]);\n\n        assert_eq!(args.config.unwrap().to_string_lossy(), \"\");\n    }\n\n    #[test]\n    fn test_args_relative_config_path() {\n        let args = Args::parse_from(&[\n            \"test\",\n            \"--config\", \"./config.yaml\"\n        ]);\n\n        assert_eq!(args.config.unwrap().to_string_lossy(), \"./config.yaml\");\n    }\n\n    #[test]\n    fn test_args_all_log_levels() {\n        let log_levels = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n\n        for level in log_levels {\n            let args = Args::parse_from(&[\n                \"test\",\n                \"--log-level\", level\n            ]);\n            assert_eq!(args.log_level, level);\n        }\n    }\n\n    #[test]\n    fn test_args_different_ports() {\n        let ports = [\"8080\", \"3000\", \"9090\", \"50051\"];\n\n        for port in ports {\n            let address = format!(\"127.0.0.1:{}\", port);\n            let args = Args::parse_from(&[\n                \"test\",\n                \"-a\", &address\n            ]);\n            assert_eq!(args.address.to_string(), address);\n        }\n    }\n\n    #[test]\n    fn test_args_different_hosts() {\n        let hosts = [\n            \"127.0.0.1:8080\",\n            \"0.0.0.0:8080\",\n            \"localhost:8080\",\n            \"[::]:8080\",\n            \"[::1]:8080\"\n        ];\n\n        for host in hosts {\n            let result = std::panic::catch_unwind(|| {\n                Args::parse_from(&[\"test\", \"-a\", host])\n            });\n            // Some hosts may be valid, others may not be parseable\n            // We're just testing that the parser handles various formats\n            let _ = result;\n        }\n    }\n\n    #[test]\n    fn test_args_boolean_flags_combinations() {\n        // Test all combinations of boolean flags\n        let combinations = [\n            (false, false),\n            (true, false),\n            (false, true),\n            (true, true),\n        ];\n\n        for (enable_metrics, daemon) in combinations {\n            let mut cmd = vec![\"test\"];\n            if enable_metrics {\n                cmd.push(\"--enable-metrics\");\n            }\n            if daemon {\n                cmd.push(\"--daemon\");\n            }\n\n            let args = Args::parse_from(&cmd);\n            assert_eq!(args.enable_metrics, enable_metrics);\n            assert_eq!(args.daemon, daemon);\n        }\n    }\n\n    #[test]\n    fn test_args_config_file_extensions() {\n        let extensions = [\n            \"config.yaml\",\n            \"config.yml\",\n            \"config.json\",\n            \"config.toml\",\n            \"config.conf\",\n            \"daemon.cfg\"\n        ];\n\n        for ext in extensions {\n            let args = Args::parse_from(&[\n                \"test\",\n                \"--config\", ext\n            ]);\n            assert_eq!(args.config.unwrap().to_string_lossy(), ext);\n        }\n    }\n\n    #[test]\n    fn test_init_tracing_case_insensitive() {\n        let levels = [\"INFO\", \"Debug\", \"WARN\", \"error\", \"TRACE\"];\n\n        for level in levels {\n            let result = std::panic::catch_unwind(|| {\n                init_tracing(level)\n            });\n            // Should handle case variations gracefully\n            let _ = result;\n        }\n    }\n\n    #[test]\n    fn test_init_tracing_with_numbers() {\n        let result = init_tracing(\"info,hyper=warn,tonic=debug\");\n        // Complex log filter should work or fail gracefully\n        let _ = result;\n    }\n\n    #[test]\n    fn test_init_tracing_empty_string() {\n        let result = init_tracing(\"\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_init_tracing_with_whitespace() {\n        let result = init_tracing(\" info \");\n        // Should handle whitespace gracefully\n        let _ = result;\n    }\n\n    #[test]\n    fn test_proto_module_access() {\n        // Test that the proto module is properly included\n        // We can't test the actual protobuf types without the generated code,\n        // but we can ensure the module exists\n        let _proto_module = stringify!(proto);\n        assert_eq!(_proto_module, \"proto\");\n    }\n\n    #[test]\n    fn test_cargo_pkg_version_constant() {\n        // Test that the version constant is accessible\n        let version = env!(\"CARGO_PKG_VERSION\");\n        assert!(!version.is_empty());\n        assert!(version.contains('.'));\n    }\n\n    #[tokio::test]\n    async fn test_args_async_compatibility() {\n        // Test that Args can be used in async context\n        let args = Args::parse_from(&[\"test\"]);\n\n        tokio::time::sleep(tokio::time::Duration::from_millis(1)).await;\n\n        assert_eq!(args.address.to_string(), \"127.0.0.1:50051\");\n    }\n\n    #[test]\n    fn test_multiple_args_parsing() {\n        // Test parsing multiple times doesn't interfere\n        let args1 = Args::parse_from(&[\"test\", \"-a\", \"127.0.0.1:8080\"]);\n        let args2 = Args::parse_from(&[\"test\", \"-a\", \"127.0.0.1:9090\"]);\n\n        assert_eq!(args1.address.to_string(), \"127.0.0.1:8080\");\n        assert_eq!(args2.address.to_string(), \"127.0.0.1:9090\");\n    }\n\n    #[test]\n    fn test_args_serialization_friendly() {\n        let args = Args::parse_from(&[\"test\"]);\n\n        // Test that Args fields are accessible for serialization\n        let _address = &args.address;\n        let _config = &args.config;\n        let _log_level = &args.log_level;\n        let _enable_metrics = args.enable_metrics;\n        let _daemon = args.daemon;\n\n        // All fields should be accessible\n        assert_eq!(args.log_level, \"info\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","target-cov","debug","build","crunchy-f65bc0d837723aac","out","lib.rs"],"content":"\n/// Unroll the given for loop\n///\n/// Example:\n///\n/// ```ignore\n/// unroll! {\n///   for i in 0..5 {\n///     println!(\"Iteration {}\", i);\n///   }\n/// }\n/// ```\n///\n/// will expand into:\n///\n/// ```ignore\n/// { println!(\"Iteration {}\", 0); }\n/// { println!(\"Iteration {}\", 1); }\n/// { println!(\"Iteration {}\", 2); }\n/// { println!(\"Iteration {}\", 3); }\n/// { println!(\"Iteration {}\", 4); }\n/// ```\n#[macro_export]\nmacro_rules! unroll {\n    (for $v:ident in 0..0 $c:block) => {};\n\n    (for $v:ident < $max:tt in ($start:tt..$end:tt).step_by($val:expr) {$($c:tt)*}) => {\n        {\n            let step = $val;\n            let start = $start;\n            let end = start + ($end - start) / step;\n            unroll! {\n                for val < $max in start..end {\n                    let $v: usize = ((val - start) * step) + start;\n\n                    $($c)*\n                }\n            }\n        }\n    };\n\n    (for $v:ident in ($start:tt..$end:tt).step_by($val:expr) {$($c:tt)*}) => {\n        unroll! {\n            for $v < $end in ($start..$end).step_by($val) {$($c)*}\n        }\n    };\n\n    (for $v:ident in ($start:tt..$end:tt) {$($c:tt)*}) => {\n        unroll!{\n            for $v in $start..$end {$($c)*}\n        }\n    };\n\n    (for $v:ident in $start:tt..$end:tt {$($c:tt)*}) => {\n        #[allow(non_upper_case_globals)]\n        #[allow(unused_comparisons)]\n        {\n            unroll!(@$v, 0, $end, {\n                    if $v >= $start {$($c)*}\n                }\n            );\n        }\n    };\n\n    (for $v:ident < $max:tt in $start:tt..$end:tt $c:block) => {\n        #[allow(non_upper_case_globals)]\n        {\n            let range = $start..$end;\n            assert!(\n                $max >= range.end,\n                \"`{}` out of range `{:?}`\",\n                stringify!($max),\n                range,\n            );\n            unroll!(\n                @$v,\n                0,\n                $max,\n                {\n                    if $v >= range.start && $v < range.end {\n                        $c\n                    }\n                }\n            );\n        }\n    };\n\n    (for $v:ident in 0..$end:tt {$($statement:tt)*}) => {\n        #[allow(non_upper_case_globals)]\n        { unroll!(@$v, 0, $end, {$($statement)*}); }\n    };\n\n    (@$v:ident, $a:expr, 0, $c:block) => {\n        { const $v: usize = $a; $c }\n    };\n\n    (@$v:ident, $a:expr, 1, $c:block) => {\n        { const $v: usize = $a; $c }\n    };\n\n    (@$v:ident, $a:expr, 2, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n    };\n\n    (@$v:ident, $a:expr, 3, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n    };\n\n    (@$v:ident, $a:expr, 4, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n    };\n\n    (@$v:ident, $a:expr, 5, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n    };\n\n    (@$v:ident, $a:expr, 6, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n    };\n\n    (@$v:ident, $a:expr, 7, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n    };\n\n    (@$v:ident, $a:expr, 8, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n    };\n\n    (@$v:ident, $a:expr, 9, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n    };\n\n    (@$v:ident, $a:expr, 10, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n    };\n\n    (@$v:ident, $a:expr, 11, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n    };\n\n    (@$v:ident, $a:expr, 12, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n    };\n\n    (@$v:ident, $a:expr, 13, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n    };\n\n    (@$v:ident, $a:expr, 14, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n        { const $v: usize = $a + 13; $c }\n    };\n\n    (@$v:ident, $a:expr, 15, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n        { const $v: usize = $a + 13; $c }\n        { const $v: usize = $a + 14; $c }\n    };\n\n    (@$v:ident, $a:expr, 16, $c:block) => {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n        { const $v: usize = $a + 13; $c }\n        { const $v: usize = $a + 14; $c }\n        { const $v: usize = $a + 15; $c }\n    };\n\n    (@$v:ident, $a:expr, 17, $c:block) => {\n        unroll!(@$v, $a, 16, $c);\n        { const $v: usize = $a + 16; $c }\n    };\n\n    (@$v:ident, $a:expr, 18, $c:block) => {\n        unroll!(@$v, $a, 9, $c);\n        unroll!(@$v, $a + 9, 9, $c);\n    };\n\n    (@$v:ident, $a:expr, 19, $c:block) => {\n        unroll!(@$v, $a, 18, $c);\n        { const $v: usize = $a + 18; $c }\n    };\n\n    (@$v:ident, $a:expr, 20, $c:block) => {\n        unroll!(@$v, $a, 10, $c);\n        unroll!(@$v, $a + 10, 10, $c);\n    };\n\n    (@$v:ident, $a:expr, 21, $c:block) => {\n        unroll!(@$v, $a, 20, $c);\n        { const $v: usize = $a + 20; $c }\n    };\n\n    (@$v:ident, $a:expr, 22, $c:block) => {\n        unroll!(@$v, $a, 11, $c);\n        unroll!(@$v, $a + 11, 11, $c);\n    };\n\n    (@$v:ident, $a:expr, 23, $c:block) => {\n        unroll!(@$v, $a, 22, $c);\n        { const $v: usize = $a + 22; $c }\n    };\n\n    (@$v:ident, $a:expr, 24, $c:block) => {\n        unroll!(@$v, $a, 12, $c);\n        unroll!(@$v, $a + 12, 12, $c);\n    };\n\n    (@$v:ident, $a:expr, 25, $c:block) => {\n        unroll!(@$v, $a, 24, $c);\n        { const $v: usize = $a + 24; $c }\n    };\n\n    (@$v:ident, $a:expr, 26, $c:block) => {\n        unroll!(@$v, $a, 13, $c);\n        unroll!(@$v, $a + 13, 13, $c);\n    };\n\n    (@$v:ident, $a:expr, 27, $c:block) => {\n        unroll!(@$v, $a, 26, $c);\n        { const $v: usize = $a + 26; $c }\n    };\n\n    (@$v:ident, $a:expr, 28, $c:block) => {\n        unroll!(@$v, $a, 14, $c);\n        unroll!(@$v, $a + 14, 14, $c);\n    };\n\n    (@$v:ident, $a:expr, 29, $c:block) => {\n        unroll!(@$v, $a, 28, $c);\n        { const $v: usize = $a + 28; $c }\n    };\n\n    (@$v:ident, $a:expr, 30, $c:block) => {\n        unroll!(@$v, $a, 15, $c);\n        unroll!(@$v, $a + 15, 15, $c);\n    };\n\n    (@$v:ident, $a:expr, 31, $c:block) => {\n        unroll!(@$v, $a, 30, $c);\n        { const $v: usize = $a + 30; $c }\n    };\n\n    (@$v:ident, $a:expr, 32, $c:block) => {\n        unroll!(@$v, $a, 16, $c);\n        unroll!(@$v, $a + 16, 16, $c);\n    };\n\n    (@$v:ident, $a:expr, 33, $c:block) => {\n        unroll!(@$v, $a, 32, $c);\n        { const $v: usize = $a + 32; $c }\n    };\n\n    (@$v:ident, $a:expr, 34, $c:block) => {\n        unroll!(@$v, $a, 17, $c);\n        unroll!(@$v, $a + 17, 17, $c);\n    };\n\n    (@$v:ident, $a:expr, 35, $c:block) => {\n        unroll!(@$v, $a, 34, $c);\n        { const $v: usize = $a + 34; $c }\n    };\n\n    (@$v:ident, $a:expr, 36, $c:block) => {\n        unroll!(@$v, $a, 18, $c);\n        unroll!(@$v, $a + 18, 18, $c);\n    };\n\n    (@$v:ident, $a:expr, 37, $c:block) => {\n        unroll!(@$v, $a, 36, $c);\n        { const $v: usize = $a + 36; $c }\n    };\n\n    (@$v:ident, $a:expr, 38, $c:block) => {\n        unroll!(@$v, $a, 19, $c);\n        unroll!(@$v, $a + 19, 19, $c);\n    };\n\n    (@$v:ident, $a:expr, 39, $c:block) => {\n        unroll!(@$v, $a, 38, $c);\n        { const $v: usize = $a + 38; $c }\n    };\n\n    (@$v:ident, $a:expr, 40, $c:block) => {\n        unroll!(@$v, $a, 20, $c);\n        unroll!(@$v, $a + 20, 20, $c);\n    };\n\n    (@$v:ident, $a:expr, 41, $c:block) => {\n        unroll!(@$v, $a, 40, $c);\n        { const $v: usize = $a + 40; $c }\n    };\n\n    (@$v:ident, $a:expr, 42, $c:block) => {\n        unroll!(@$v, $a, 21, $c);\n        unroll!(@$v, $a + 21, 21, $c);\n    };\n\n    (@$v:ident, $a:expr, 43, $c:block) => {\n        unroll!(@$v, $a, 42, $c);\n        { const $v: usize = $a + 42; $c }\n    };\n\n    (@$v:ident, $a:expr, 44, $c:block) => {\n        unroll!(@$v, $a, 22, $c);\n        unroll!(@$v, $a + 22, 22, $c);\n    };\n\n    (@$v:ident, $a:expr, 45, $c:block) => {\n        unroll!(@$v, $a, 44, $c);\n        { const $v: usize = $a + 44; $c }\n    };\n\n    (@$v:ident, $a:expr, 46, $c:block) => {\n        unroll!(@$v, $a, 23, $c);\n        unroll!(@$v, $a + 23, 23, $c);\n    };\n\n    (@$v:ident, $a:expr, 47, $c:block) => {\n        unroll!(@$v, $a, 46, $c);\n        { const $v: usize = $a + 46; $c }\n    };\n\n    (@$v:ident, $a:expr, 48, $c:block) => {\n        unroll!(@$v, $a, 24, $c);\n        unroll!(@$v, $a + 24, 24, $c);\n    };\n\n    (@$v:ident, $a:expr, 49, $c:block) => {\n        unroll!(@$v, $a, 48, $c);\n        { const $v: usize = $a + 48; $c }\n    };\n\n    (@$v:ident, $a:expr, 50, $c:block) => {\n        unroll!(@$v, $a, 25, $c);\n        unroll!(@$v, $a + 25, 25, $c);\n    };\n\n    (@$v:ident, $a:expr, 51, $c:block) => {\n        unroll!(@$v, $a, 50, $c);\n        { const $v: usize = $a + 50; $c }\n    };\n\n    (@$v:ident, $a:expr, 52, $c:block) => {\n        unroll!(@$v, $a, 26, $c);\n        unroll!(@$v, $a + 26, 26, $c);\n    };\n\n    (@$v:ident, $a:expr, 53, $c:block) => {\n        unroll!(@$v, $a, 52, $c);\n        { const $v: usize = $a + 52; $c }\n    };\n\n    (@$v:ident, $a:expr, 54, $c:block) => {\n        unroll!(@$v, $a, 27, $c);\n        unroll!(@$v, $a + 27, 27, $c);\n    };\n\n    (@$v:ident, $a:expr, 55, $c:block) => {\n        unroll!(@$v, $a, 54, $c);\n        { const $v: usize = $a + 54; $c }\n    };\n\n    (@$v:ident, $a:expr, 56, $c:block) => {\n        unroll!(@$v, $a, 28, $c);\n        unroll!(@$v, $a + 28, 28, $c);\n    };\n\n    (@$v:ident, $a:expr, 57, $c:block) => {\n        unroll!(@$v, $a, 56, $c);\n        { const $v: usize = $a + 56; $c }\n    };\n\n    (@$v:ident, $a:expr, 58, $c:block) => {\n        unroll!(@$v, $a, 29, $c);\n        unroll!(@$v, $a + 29, 29, $c);\n    };\n\n    (@$v:ident, $a:expr, 59, $c:block) => {\n        unroll!(@$v, $a, 58, $c);\n        { const $v: usize = $a + 58; $c }\n    };\n\n    (@$v:ident, $a:expr, 60, $c:block) => {\n        unroll!(@$v, $a, 30, $c);\n        unroll!(@$v, $a + 30, 30, $c);\n    };\n\n    (@$v:ident, $a:expr, 61, $c:block) => {\n        unroll!(@$v, $a, 60, $c);\n        { const $v: usize = $a + 60; $c }\n    };\n\n    (@$v:ident, $a:expr, 62, $c:block) => {\n        unroll!(@$v, $a, 31, $c);\n        unroll!(@$v, $a + 31, 31, $c);\n    };\n\n    (@$v:ident, $a:expr, 63, $c:block) => {\n        unroll!(@$v, $a, 62, $c);\n        { const $v: usize = $a + 62; $c }\n    };\n\n    (@$v:ident, $a:expr, 64, $c:block) => {\n        unroll!(@$v, $a, 32, $c);\n        unroll!(@$v, $a + 32, 32, $c);\n    };\n\n    (@$v:ident, $a:expr, 65, $c:block) => {\n        unroll!(@$v, $a, 64, $c);\n        { const $v: usize = $a + 64; $c }\n    };\n\n    (@$v:ident, $a:expr, 66, $c:block) => {\n        unroll!(@$v, $a, 33, $c);\n        unroll!(@$v, $a + 33, 33, $c);\n    };\n\n    (@$v:ident, $a:expr, 67, $c:block) => {\n        unroll!(@$v, $a, 66, $c);\n        { const $v: usize = $a + 66; $c }\n    };\n\n    (@$v:ident, $a:expr, 68, $c:block) => {\n        unroll!(@$v, $a, 34, $c);\n        unroll!(@$v, $a + 34, 34, $c);\n    };\n\n    (@$v:ident, $a:expr, 69, $c:block) => {\n        unroll!(@$v, $a, 68, $c);\n        { const $v: usize = $a + 68; $c }\n    };\n\n    (@$v:ident, $a:expr, 70, $c:block) => {\n        unroll!(@$v, $a, 35, $c);\n        unroll!(@$v, $a + 35, 35, $c);\n    };\n\n    (@$v:ident, $a:expr, 71, $c:block) => {\n        unroll!(@$v, $a, 70, $c);\n        { const $v: usize = $a + 70; $c }\n    };\n\n    (@$v:ident, $a:expr, 72, $c:block) => {\n        unroll!(@$v, $a, 36, $c);\n        unroll!(@$v, $a + 36, 36, $c);\n    };\n\n    (@$v:ident, $a:expr, 73, $c:block) => {\n        unroll!(@$v, $a, 72, $c);\n        { const $v: usize = $a + 72; $c }\n    };\n\n    (@$v:ident, $a:expr, 74, $c:block) => {\n        unroll!(@$v, $a, 37, $c);\n        unroll!(@$v, $a + 37, 37, $c);\n    };\n\n    (@$v:ident, $a:expr, 75, $c:block) => {\n        unroll!(@$v, $a, 74, $c);\n        { const $v: usize = $a + 74; $c }\n    };\n\n    (@$v:ident, $a:expr, 76, $c:block) => {\n        unroll!(@$v, $a, 38, $c);\n        unroll!(@$v, $a + 38, 38, $c);\n    };\n\n    (@$v:ident, $a:expr, 77, $c:block) => {\n        unroll!(@$v, $a, 76, $c);\n        { const $v: usize = $a + 76; $c }\n    };\n\n    (@$v:ident, $a:expr, 78, $c:block) => {\n        unroll!(@$v, $a, 39, $c);\n        unroll!(@$v, $a + 39, 39, $c);\n    };\n\n    (@$v:ident, $a:expr, 79, $c:block) => {\n        unroll!(@$v, $a, 78, $c);\n        { const $v: usize = $a + 78; $c }\n    };\n\n    (@$v:ident, $a:expr, 80, $c:block) => {\n        unroll!(@$v, $a, 40, $c);\n        unroll!(@$v, $a + 40, 40, $c);\n    };\n\n    (@$v:ident, $a:expr, 81, $c:block) => {\n        unroll!(@$v, $a, 80, $c);\n        { const $v: usize = $a + 80; $c }\n    };\n\n    (@$v:ident, $a:expr, 82, $c:block) => {\n        unroll!(@$v, $a, 41, $c);\n        unroll!(@$v, $a + 41, 41, $c);\n    };\n\n    (@$v:ident, $a:expr, 83, $c:block) => {\n        unroll!(@$v, $a, 82, $c);\n        { const $v: usize = $a + 82; $c }\n    };\n\n    (@$v:ident, $a:expr, 84, $c:block) => {\n        unroll!(@$v, $a, 42, $c);\n        unroll!(@$v, $a + 42, 42, $c);\n    };\n\n    (@$v:ident, $a:expr, 85, $c:block) => {\n        unroll!(@$v, $a, 84, $c);\n        { const $v: usize = $a + 84; $c }\n    };\n\n    (@$v:ident, $a:expr, 86, $c:block) => {\n        unroll!(@$v, $a, 43, $c);\n        unroll!(@$v, $a + 43, 43, $c);\n    };\n\n    (@$v:ident, $a:expr, 87, $c:block) => {\n        unroll!(@$v, $a, 86, $c);\n        { const $v: usize = $a + 86; $c }\n    };\n\n    (@$v:ident, $a:expr, 88, $c:block) => {\n        unroll!(@$v, $a, 44, $c);\n        unroll!(@$v, $a + 44, 44, $c);\n    };\n\n    (@$v:ident, $a:expr, 89, $c:block) => {\n        unroll!(@$v, $a, 88, $c);\n        { const $v: usize = $a + 88; $c }\n    };\n\n    (@$v:ident, $a:expr, 90, $c:block) => {\n        unroll!(@$v, $a, 45, $c);\n        unroll!(@$v, $a + 45, 45, $c);\n    };\n\n    (@$v:ident, $a:expr, 91, $c:block) => {\n        unroll!(@$v, $a, 90, $c);\n        { const $v: usize = $a + 90; $c }\n    };\n\n    (@$v:ident, $a:expr, 92, $c:block) => {\n        unroll!(@$v, $a, 46, $c);\n        unroll!(@$v, $a + 46, 46, $c);\n    };\n\n    (@$v:ident, $a:expr, 93, $c:block) => {\n        unroll!(@$v, $a, 92, $c);\n        { const $v: usize = $a + 92; $c }\n    };\n\n    (@$v:ident, $a:expr, 94, $c:block) => {\n        unroll!(@$v, $a, 47, $c);\n        unroll!(@$v, $a + 47, 47, $c);\n    };\n\n    (@$v:ident, $a:expr, 95, $c:block) => {\n        unroll!(@$v, $a, 94, $c);\n        { const $v: usize = $a + 94; $c }\n    };\n\n    (@$v:ident, $a:expr, 96, $c:block) => {\n        unroll!(@$v, $a, 48, $c);\n        unroll!(@$v, $a + 48, 48, $c);\n    };\n\n    (@$v:ident, $a:expr, 97, $c:block) => {\n        unroll!(@$v, $a, 96, $c);\n        { const $v: usize = $a + 96; $c }\n    };\n\n    (@$v:ident, $a:expr, 98, $c:block) => {\n        unroll!(@$v, $a, 49, $c);\n        unroll!(@$v, $a + 49, 49, $c);\n    };\n\n    (@$v:ident, $a:expr, 99, $c:block) => {\n        unroll!(@$v, $a, 98, $c);\n        { const $v: usize = $a + 98; $c }\n    };\n\n    (@$v:ident, $a:expr, 100, $c:block) => {\n        unroll!(@$v, $a, 50, $c);\n        unroll!(@$v, $a + 50, 50, $c);\n    };\n\n    (@$v:ident, $a:expr, 101, $c:block) => {\n        unroll!(@$v, $a, 100, $c);\n        { const $v: usize = $a + 100; $c }\n    };\n\n    (@$v:ident, $a:expr, 102, $c:block) => {\n        unroll!(@$v, $a, 51, $c);\n        unroll!(@$v, $a + 51, 51, $c);\n    };\n\n    (@$v:ident, $a:expr, 103, $c:block) => {\n        unroll!(@$v, $a, 102, $c);\n        { const $v: usize = $a + 102; $c }\n    };\n\n    (@$v:ident, $a:expr, 104, $c:block) => {\n        unroll!(@$v, $a, 52, $c);\n        unroll!(@$v, $a + 52, 52, $c);\n    };\n\n    (@$v:ident, $a:expr, 105, $c:block) => {\n        unroll!(@$v, $a, 104, $c);\n        { const $v: usize = $a + 104; $c }\n    };\n\n    (@$v:ident, $a:expr, 106, $c:block) => {\n        unroll!(@$v, $a, 53, $c);\n        unroll!(@$v, $a + 53, 53, $c);\n    };\n\n    (@$v:ident, $a:expr, 107, $c:block) => {\n        unroll!(@$v, $a, 106, $c);\n        { const $v: usize = $a + 106; $c }\n    };\n\n    (@$v:ident, $a:expr, 108, $c:block) => {\n        unroll!(@$v, $a, 54, $c);\n        unroll!(@$v, $a + 54, 54, $c);\n    };\n\n    (@$v:ident, $a:expr, 109, $c:block) => {\n        unroll!(@$v, $a, 108, $c);\n        { const $v: usize = $a + 108; $c }\n    };\n\n    (@$v:ident, $a:expr, 110, $c:block) => {\n        unroll!(@$v, $a, 55, $c);\n        unroll!(@$v, $a + 55, 55, $c);\n    };\n\n    (@$v:ident, $a:expr, 111, $c:block) => {\n        unroll!(@$v, $a, 110, $c);\n        { const $v: usize = $a + 110; $c }\n    };\n\n    (@$v:ident, $a:expr, 112, $c:block) => {\n        unroll!(@$v, $a, 56, $c);\n        unroll!(@$v, $a + 56, 56, $c);\n    };\n\n    (@$v:ident, $a:expr, 113, $c:block) => {\n        unroll!(@$v, $a, 112, $c);\n        { const $v: usize = $a + 112; $c }\n    };\n\n    (@$v:ident, $a:expr, 114, $c:block) => {\n        unroll!(@$v, $a, 57, $c);\n        unroll!(@$v, $a + 57, 57, $c);\n    };\n\n    (@$v:ident, $a:expr, 115, $c:block) => {\n        unroll!(@$v, $a, 114, $c);\n        { const $v: usize = $a + 114; $c }\n    };\n\n    (@$v:ident, $a:expr, 116, $c:block) => {\n        unroll!(@$v, $a, 58, $c);\n        unroll!(@$v, $a + 58, 58, $c);\n    };\n\n    (@$v:ident, $a:expr, 117, $c:block) => {\n        unroll!(@$v, $a, 116, $c);\n        { const $v: usize = $a + 116; $c }\n    };\n\n    (@$v:ident, $a:expr, 118, $c:block) => {\n        unroll!(@$v, $a, 59, $c);\n        unroll!(@$v, $a + 59, 59, $c);\n    };\n\n    (@$v:ident, $a:expr, 119, $c:block) => {\n        unroll!(@$v, $a, 118, $c);\n        { const $v: usize = $a + 118; $c }\n    };\n\n    (@$v:ident, $a:expr, 120, $c:block) => {\n        unroll!(@$v, $a, 60, $c);\n        unroll!(@$v, $a + 60, 60, $c);\n    };\n\n    (@$v:ident, $a:expr, 121, $c:block) => {\n        unroll!(@$v, $a, 120, $c);\n        { const $v: usize = $a + 120; $c }\n    };\n\n    (@$v:ident, $a:expr, 122, $c:block) => {\n        unroll!(@$v, $a, 61, $c);\n        unroll!(@$v, $a + 61, 61, $c);\n    };\n\n    (@$v:ident, $a:expr, 123, $c:block) => {\n        unroll!(@$v, $a, 122, $c);\n        { const $v: usize = $a + 122; $c }\n    };\n\n    (@$v:ident, $a:expr, 124, $c:block) => {\n        unroll!(@$v, $a, 62, $c);\n        unroll!(@$v, $a + 62, 62, $c);\n    };\n\n    (@$v:ident, $a:expr, 125, $c:block) => {\n        unroll!(@$v, $a, 124, $c);\n        { const $v: usize = $a + 124; $c }\n    };\n\n    (@$v:ident, $a:expr, 126, $c:block) => {\n        unroll!(@$v, $a, 63, $c);\n        unroll!(@$v, $a + 63, 63, $c);\n    };\n\n    (@$v:ident, $a:expr, 127, $c:block) => {\n        unroll!(@$v, $a, 126, $c);\n        { const $v: usize = $a + 126; $c }\n    };\n\n    (@$v:ident, $a:expr, 128, $c:block) => {\n        unroll!(@$v, $a, 64, $c);\n        unroll!(@$v, $a + 64, 64, $c);\n    };\n\n}\n\n\n#[cfg(all(test, feature = \"std\"))]\nmod tests {\n    #[test]\n    fn invalid_range() {\n        let mut a: Vec<usize> = vec![];\n        unroll! {\n                for i in (5..4) {\n                    a.push(i);\n                }\n            }\n        assert_eq!(a, vec![]);\n    }\n\n    #[test]\n    fn start_at_one_with_step() {\n        let mut a: Vec<usize> = vec![];\n        unroll! {\n                for i in (2..4).step_by(1) {\n                    a.push(i);\n                }\n            }\n        assert_eq!(a, vec![2, 3]);\n    }\n\n    #[test]\n    fn start_at_one() {\n        let mut a: Vec<usize> = vec![];\n        unroll! {\n                for i in 1..4 {\n                    a.push(i);\n                }\n            }\n        assert_eq!(a, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_all() {\n        {\n            let a: Vec<usize> = vec![];\n            unroll! {\n                for i in 0..0 {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..0).collect::<Vec<usize>>());\n        }\n        {\n            let mut a: Vec<usize> = vec![];\n            unroll! {\n                for i in 0..1 {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..1).collect::<Vec<usize>>());\n        }\n        {\n            let mut a: Vec<usize> = vec![];\n            unroll! {\n                for i in 0..128 {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..128).collect::<Vec<usize>>());\n        }\n        {\n            let mut a: Vec<usize> = vec![];\n            let start = 128 / 4;\n            let end = start * 3;\n            unroll! {\n                for i < 128 in start..end {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (start..end).collect::<Vec<usize>>());\n        }\n        {\n            let mut a: Vec<usize> = vec![];\n            unroll! {\n                for i in (0..128).step_by(2) {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..128 / 2).map(|x| x * 2).collect::<Vec<usize>>());\n        }\n        {\n            let mut a: Vec<usize> = vec![];\n            let start = 128 / 4;\n            let end = start * 3;\n            unroll! {\n                for i < 128 in (start..end).step_by(2) {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (start..end).filter(|x| x % 2 == 0).collect::<Vec<usize>>());\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","target-cov","debug","build","libsqlite3-sys-eb8239674874f9fc","out","bindgen.rs"],"content":"/* automatically generated by rust-bindgen 0.69.4 */\n\nextern \"C\" {\n    pub fn sqlite3_auto_extension(\n        xEntryPoint: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                db: *mut sqlite3,\n                pzErrMsg: *mut *mut ::std::os::raw::c_char,\n                _: *const sqlite3_api_routines,\n            ) -> ::std::os::raw::c_int,\n        >,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_cancel_auto_extension(\n        xEntryPoint: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                db: *mut sqlite3,\n                pzErrMsg: *mut *mut ::std::os::raw::c_char,\n                _: *const sqlite3_api_routines,\n            ) -> ::std::os::raw::c_int,\n        >,\n    ) -> ::std::os::raw::c_int;\n}\n\npub const SQLITE_VERSION: &[u8; 7] = b\"3.46.0\\0\";\npub const SQLITE_VERSION_NUMBER: i32 = 3046000;\npub const SQLITE_SOURCE_ID: &[u8; 85] =\n    b\"2024-05-23 13:25:27 96c92aba00c8375bc32fafcdf12429c58bd8aabfcadab6683e35bbb9cdebf19e\\0\";\npub const SQLITE_OK: i32 = 0;\npub const SQLITE_ERROR: i32 = 1;\npub const SQLITE_INTERNAL: i32 = 2;\npub const SQLITE_PERM: i32 = 3;\npub const SQLITE_ABORT: i32 = 4;\npub const SQLITE_BUSY: i32 = 5;\npub const SQLITE_LOCKED: i32 = 6;\npub const SQLITE_NOMEM: i32 = 7;\npub const SQLITE_READONLY: i32 = 8;\npub const SQLITE_INTERRUPT: i32 = 9;\npub const SQLITE_IOERR: i32 = 10;\npub const SQLITE_CORRUPT: i32 = 11;\npub const SQLITE_NOTFOUND: i32 = 12;\npub const SQLITE_FULL: i32 = 13;\npub const SQLITE_CANTOPEN: i32 = 14;\npub const SQLITE_PROTOCOL: i32 = 15;\npub const SQLITE_EMPTY: i32 = 16;\npub const SQLITE_SCHEMA: i32 = 17;\npub const SQLITE_TOOBIG: i32 = 18;\npub const SQLITE_CONSTRAINT: i32 = 19;\npub const SQLITE_MISMATCH: i32 = 20;\npub const SQLITE_MISUSE: i32 = 21;\npub const SQLITE_NOLFS: i32 = 22;\npub const SQLITE_AUTH: i32 = 23;\npub const SQLITE_FORMAT: i32 = 24;\npub const SQLITE_RANGE: i32 = 25;\npub const SQLITE_NOTADB: i32 = 26;\npub const SQLITE_NOTICE: i32 = 27;\npub const SQLITE_WARNING: i32 = 28;\npub const SQLITE_ROW: i32 = 100;\npub const SQLITE_DONE: i32 = 101;\npub const SQLITE_ERROR_MISSING_COLLSEQ: i32 = 257;\npub const SQLITE_ERROR_RETRY: i32 = 513;\npub const SQLITE_ERROR_SNAPSHOT: i32 = 769;\npub const SQLITE_IOERR_READ: i32 = 266;\npub const SQLITE_IOERR_SHORT_READ: i32 = 522;\npub const SQLITE_IOERR_WRITE: i32 = 778;\npub const SQLITE_IOERR_FSYNC: i32 = 1034;\npub const SQLITE_IOERR_DIR_FSYNC: i32 = 1290;\npub const SQLITE_IOERR_TRUNCATE: i32 = 1546;\npub const SQLITE_IOERR_FSTAT: i32 = 1802;\npub const SQLITE_IOERR_UNLOCK: i32 = 2058;\npub const SQLITE_IOERR_RDLOCK: i32 = 2314;\npub const SQLITE_IOERR_DELETE: i32 = 2570;\npub const SQLITE_IOERR_BLOCKED: i32 = 2826;\npub const SQLITE_IOERR_NOMEM: i32 = 3082;\npub const SQLITE_IOERR_ACCESS: i32 = 3338;\npub const SQLITE_IOERR_CHECKRESERVEDLOCK: i32 = 3594;\npub const SQLITE_IOERR_LOCK: i32 = 3850;\npub const SQLITE_IOERR_CLOSE: i32 = 4106;\npub const SQLITE_IOERR_DIR_CLOSE: i32 = 4362;\npub const SQLITE_IOERR_SHMOPEN: i32 = 4618;\npub const SQLITE_IOERR_SHMSIZE: i32 = 4874;\npub const SQLITE_IOERR_SHMLOCK: i32 = 5130;\npub const SQLITE_IOERR_SHMMAP: i32 = 5386;\npub const SQLITE_IOERR_SEEK: i32 = 5642;\npub const SQLITE_IOERR_DELETE_NOENT: i32 = 5898;\npub const SQLITE_IOERR_MMAP: i32 = 6154;\npub const SQLITE_IOERR_GETTEMPPATH: i32 = 6410;\npub const SQLITE_IOERR_CONVPATH: i32 = 6666;\npub const SQLITE_IOERR_VNODE: i32 = 6922;\npub const SQLITE_IOERR_AUTH: i32 = 7178;\npub const SQLITE_IOERR_BEGIN_ATOMIC: i32 = 7434;\npub const SQLITE_IOERR_COMMIT_ATOMIC: i32 = 7690;\npub const SQLITE_IOERR_ROLLBACK_ATOMIC: i32 = 7946;\npub const SQLITE_IOERR_DATA: i32 = 8202;\npub const SQLITE_IOERR_CORRUPTFS: i32 = 8458;\npub const SQLITE_IOERR_IN_PAGE: i32 = 8714;\npub const SQLITE_LOCKED_SHAREDCACHE: i32 = 262;\npub const SQLITE_LOCKED_VTAB: i32 = 518;\npub const SQLITE_BUSY_RECOVERY: i32 = 261;\npub const SQLITE_BUSY_SNAPSHOT: i32 = 517;\npub const SQLITE_BUSY_TIMEOUT: i32 = 773;\npub const SQLITE_CANTOPEN_NOTEMPDIR: i32 = 270;\npub const SQLITE_CANTOPEN_ISDIR: i32 = 526;\npub const SQLITE_CANTOPEN_FULLPATH: i32 = 782;\npub const SQLITE_CANTOPEN_CONVPATH: i32 = 1038;\npub const SQLITE_CANTOPEN_DIRTYWAL: i32 = 1294;\npub const SQLITE_CANTOPEN_SYMLINK: i32 = 1550;\npub const SQLITE_CORRUPT_VTAB: i32 = 267;\npub const SQLITE_CORRUPT_SEQUENCE: i32 = 523;\npub const SQLITE_CORRUPT_INDEX: i32 = 779;\npub const SQLITE_READONLY_RECOVERY: i32 = 264;\npub const SQLITE_READONLY_CANTLOCK: i32 = 520;\npub const SQLITE_READONLY_ROLLBACK: i32 = 776;\npub const SQLITE_READONLY_DBMOVED: i32 = 1032;\npub const SQLITE_READONLY_CANTINIT: i32 = 1288;\npub const SQLITE_READONLY_DIRECTORY: i32 = 1544;\npub const SQLITE_ABORT_ROLLBACK: i32 = 516;\npub const SQLITE_CONSTRAINT_CHECK: i32 = 275;\npub const SQLITE_CONSTRAINT_COMMITHOOK: i32 = 531;\npub const SQLITE_CONSTRAINT_FOREIGNKEY: i32 = 787;\npub const SQLITE_CONSTRAINT_FUNCTION: i32 = 1043;\npub const SQLITE_CONSTRAINT_NOTNULL: i32 = 1299;\npub const SQLITE_CONSTRAINT_PRIMARYKEY: i32 = 1555;\npub const SQLITE_CONSTRAINT_TRIGGER: i32 = 1811;\npub const SQLITE_CONSTRAINT_UNIQUE: i32 = 2067;\npub const SQLITE_CONSTRAINT_VTAB: i32 = 2323;\npub const SQLITE_CONSTRAINT_ROWID: i32 = 2579;\npub const SQLITE_CONSTRAINT_PINNED: i32 = 2835;\npub const SQLITE_CONSTRAINT_DATATYPE: i32 = 3091;\npub const SQLITE_NOTICE_RECOVER_WAL: i32 = 283;\npub const SQLITE_NOTICE_RECOVER_ROLLBACK: i32 = 539;\npub const SQLITE_NOTICE_RBU: i32 = 795;\npub const SQLITE_WARNING_AUTOINDEX: i32 = 284;\npub const SQLITE_AUTH_USER: i32 = 279;\npub const SQLITE_OK_LOAD_PERMANENTLY: i32 = 256;\npub const SQLITE_OK_SYMLINK: i32 = 512;\npub const SQLITE_OPEN_READONLY: i32 = 1;\npub const SQLITE_OPEN_READWRITE: i32 = 2;\npub const SQLITE_OPEN_CREATE: i32 = 4;\npub const SQLITE_OPEN_DELETEONCLOSE: i32 = 8;\npub const SQLITE_OPEN_EXCLUSIVE: i32 = 16;\npub const SQLITE_OPEN_AUTOPROXY: i32 = 32;\npub const SQLITE_OPEN_URI: i32 = 64;\npub const SQLITE_OPEN_MEMORY: i32 = 128;\npub const SQLITE_OPEN_MAIN_DB: i32 = 256;\npub const SQLITE_OPEN_TEMP_DB: i32 = 512;\npub const SQLITE_OPEN_TRANSIENT_DB: i32 = 1024;\npub const SQLITE_OPEN_MAIN_JOURNAL: i32 = 2048;\npub const SQLITE_OPEN_TEMP_JOURNAL: i32 = 4096;\npub const SQLITE_OPEN_SUBJOURNAL: i32 = 8192;\npub const SQLITE_OPEN_SUPER_JOURNAL: i32 = 16384;\npub const SQLITE_OPEN_NOMUTEX: i32 = 32768;\npub const SQLITE_OPEN_FULLMUTEX: i32 = 65536;\npub const SQLITE_OPEN_SHAREDCACHE: i32 = 131072;\npub const SQLITE_OPEN_PRIVATECACHE: i32 = 262144;\npub const SQLITE_OPEN_WAL: i32 = 524288;\npub const SQLITE_OPEN_NOFOLLOW: i32 = 16777216;\npub const SQLITE_OPEN_EXRESCODE: i32 = 33554432;\npub const SQLITE_OPEN_MASTER_JOURNAL: i32 = 16384;\npub const SQLITE_IOCAP_ATOMIC: i32 = 1;\npub const SQLITE_IOCAP_ATOMIC512: i32 = 2;\npub const SQLITE_IOCAP_ATOMIC1K: i32 = 4;\npub const SQLITE_IOCAP_ATOMIC2K: i32 = 8;\npub const SQLITE_IOCAP_ATOMIC4K: i32 = 16;\npub const SQLITE_IOCAP_ATOMIC8K: i32 = 32;\npub const SQLITE_IOCAP_ATOMIC16K: i32 = 64;\npub const SQLITE_IOCAP_ATOMIC32K: i32 = 128;\npub const SQLITE_IOCAP_ATOMIC64K: i32 = 256;\npub const SQLITE_IOCAP_SAFE_APPEND: i32 = 512;\npub const SQLITE_IOCAP_SEQUENTIAL: i32 = 1024;\npub const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN: i32 = 2048;\npub const SQLITE_IOCAP_POWERSAFE_OVERWRITE: i32 = 4096;\npub const SQLITE_IOCAP_IMMUTABLE: i32 = 8192;\npub const SQLITE_IOCAP_BATCH_ATOMIC: i32 = 16384;\npub const SQLITE_LOCK_NONE: i32 = 0;\npub const SQLITE_LOCK_SHARED: i32 = 1;\npub const SQLITE_LOCK_RESERVED: i32 = 2;\npub const SQLITE_LOCK_PENDING: i32 = 3;\npub const SQLITE_LOCK_EXCLUSIVE: i32 = 4;\npub const SQLITE_SYNC_NORMAL: i32 = 2;\npub const SQLITE_SYNC_FULL: i32 = 3;\npub const SQLITE_SYNC_DATAONLY: i32 = 16;\npub const SQLITE_FCNTL_LOCKSTATE: i32 = 1;\npub const SQLITE_FCNTL_GET_LOCKPROXYFILE: i32 = 2;\npub const SQLITE_FCNTL_SET_LOCKPROXYFILE: i32 = 3;\npub const SQLITE_FCNTL_LAST_ERRNO: i32 = 4;\npub const SQLITE_FCNTL_SIZE_HINT: i32 = 5;\npub const SQLITE_FCNTL_CHUNK_SIZE: i32 = 6;\npub const SQLITE_FCNTL_FILE_POINTER: i32 = 7;\npub const SQLITE_FCNTL_SYNC_OMITTED: i32 = 8;\npub const SQLITE_FCNTL_WIN32_AV_RETRY: i32 = 9;\npub const SQLITE_FCNTL_PERSIST_WAL: i32 = 10;\npub const SQLITE_FCNTL_OVERWRITE: i32 = 11;\npub const SQLITE_FCNTL_VFSNAME: i32 = 12;\npub const SQLITE_FCNTL_POWERSAFE_OVERWRITE: i32 = 13;\npub const SQLITE_FCNTL_PRAGMA: i32 = 14;\npub const SQLITE_FCNTL_BUSYHANDLER: i32 = 15;\npub const SQLITE_FCNTL_TEMPFILENAME: i32 = 16;\npub const SQLITE_FCNTL_MMAP_SIZE: i32 = 18;\npub const SQLITE_FCNTL_TRACE: i32 = 19;\npub const SQLITE_FCNTL_HAS_MOVED: i32 = 20;\npub const SQLITE_FCNTL_SYNC: i32 = 21;\npub const SQLITE_FCNTL_COMMIT_PHASETWO: i32 = 22;\npub const SQLITE_FCNTL_WIN32_SET_HANDLE: i32 = 23;\npub const SQLITE_FCNTL_WAL_BLOCK: i32 = 24;\npub const SQLITE_FCNTL_ZIPVFS: i32 = 25;\npub const SQLITE_FCNTL_RBU: i32 = 26;\npub const SQLITE_FCNTL_VFS_POINTER: i32 = 27;\npub const SQLITE_FCNTL_JOURNAL_POINTER: i32 = 28;\npub const SQLITE_FCNTL_WIN32_GET_HANDLE: i32 = 29;\npub const SQLITE_FCNTL_PDB: i32 = 30;\npub const SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: i32 = 31;\npub const SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: i32 = 32;\npub const SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: i32 = 33;\npub const SQLITE_FCNTL_LOCK_TIMEOUT: i32 = 34;\npub const SQLITE_FCNTL_DATA_VERSION: i32 = 35;\npub const SQLITE_FCNTL_SIZE_LIMIT: i32 = 36;\npub const SQLITE_FCNTL_CKPT_DONE: i32 = 37;\npub const SQLITE_FCNTL_RESERVE_BYTES: i32 = 38;\npub const SQLITE_FCNTL_CKPT_START: i32 = 39;\npub const SQLITE_FCNTL_EXTERNAL_READER: i32 = 40;\npub const SQLITE_FCNTL_CKSM_FILE: i32 = 41;\npub const SQLITE_FCNTL_RESET_CACHE: i32 = 42;\npub const SQLITE_GET_LOCKPROXYFILE: i32 = 2;\npub const SQLITE_SET_LOCKPROXYFILE: i32 = 3;\npub const SQLITE_LAST_ERRNO: i32 = 4;\npub const SQLITE_ACCESS_EXISTS: i32 = 0;\npub const SQLITE_ACCESS_READWRITE: i32 = 1;\npub const SQLITE_ACCESS_READ: i32 = 2;\npub const SQLITE_SHM_UNLOCK: i32 = 1;\npub const SQLITE_SHM_LOCK: i32 = 2;\npub const SQLITE_SHM_SHARED: i32 = 4;\npub const SQLITE_SHM_EXCLUSIVE: i32 = 8;\npub const SQLITE_SHM_NLOCK: i32 = 8;\npub const SQLITE_CONFIG_SINGLETHREAD: i32 = 1;\npub const SQLITE_CONFIG_MULTITHREAD: i32 = 2;\npub const SQLITE_CONFIG_SERIALIZED: i32 = 3;\npub const SQLITE_CONFIG_MALLOC: i32 = 4;\npub const SQLITE_CONFIG_GETMALLOC: i32 = 5;\npub const SQLITE_CONFIG_SCRATCH: i32 = 6;\npub const SQLITE_CONFIG_PAGECACHE: i32 = 7;\npub const SQLITE_CONFIG_HEAP: i32 = 8;\npub const SQLITE_CONFIG_MEMSTATUS: i32 = 9;\npub const SQLITE_CONFIG_MUTEX: i32 = 10;\npub const SQLITE_CONFIG_GETMUTEX: i32 = 11;\npub const SQLITE_CONFIG_LOOKASIDE: i32 = 13;\npub const SQLITE_CONFIG_PCACHE: i32 = 14;\npub const SQLITE_CONFIG_GETPCACHE: i32 = 15;\npub const SQLITE_CONFIG_LOG: i32 = 16;\npub const SQLITE_CONFIG_URI: i32 = 17;\npub const SQLITE_CONFIG_PCACHE2: i32 = 18;\npub const SQLITE_CONFIG_GETPCACHE2: i32 = 19;\npub const SQLITE_CONFIG_COVERING_INDEX_SCAN: i32 = 20;\npub const SQLITE_CONFIG_SQLLOG: i32 = 21;\npub const SQLITE_CONFIG_MMAP_SIZE: i32 = 22;\npub const SQLITE_CONFIG_WIN32_HEAPSIZE: i32 = 23;\npub const SQLITE_CONFIG_PCACHE_HDRSZ: i32 = 24;\npub const SQLITE_CONFIG_PMASZ: i32 = 25;\npub const SQLITE_CONFIG_STMTJRNL_SPILL: i32 = 26;\npub const SQLITE_CONFIG_SMALL_MALLOC: i32 = 27;\npub const SQLITE_CONFIG_SORTERREF_SIZE: i32 = 28;\npub const SQLITE_CONFIG_MEMDB_MAXSIZE: i32 = 29;\npub const SQLITE_CONFIG_ROWID_IN_VIEW: i32 = 30;\npub const SQLITE_DBCONFIG_MAINDBNAME: i32 = 1000;\npub const SQLITE_DBCONFIG_LOOKASIDE: i32 = 1001;\npub const SQLITE_DBCONFIG_ENABLE_FKEY: i32 = 1002;\npub const SQLITE_DBCONFIG_ENABLE_TRIGGER: i32 = 1003;\npub const SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER: i32 = 1004;\npub const SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION: i32 = 1005;\npub const SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE: i32 = 1006;\npub const SQLITE_DBCONFIG_ENABLE_QPSG: i32 = 1007;\npub const SQLITE_DBCONFIG_TRIGGER_EQP: i32 = 1008;\npub const SQLITE_DBCONFIG_RESET_DATABASE: i32 = 1009;\npub const SQLITE_DBCONFIG_DEFENSIVE: i32 = 1010;\npub const SQLITE_DBCONFIG_WRITABLE_SCHEMA: i32 = 1011;\npub const SQLITE_DBCONFIG_LEGACY_ALTER_TABLE: i32 = 1012;\npub const SQLITE_DBCONFIG_DQS_DML: i32 = 1013;\npub const SQLITE_DBCONFIG_DQS_DDL: i32 = 1014;\npub const SQLITE_DBCONFIG_ENABLE_VIEW: i32 = 1015;\npub const SQLITE_DBCONFIG_LEGACY_FILE_FORMAT: i32 = 1016;\npub const SQLITE_DBCONFIG_TRUSTED_SCHEMA: i32 = 1017;\npub const SQLITE_DBCONFIG_STMT_SCANSTATUS: i32 = 1018;\npub const SQLITE_DBCONFIG_REVERSE_SCANORDER: i32 = 1019;\npub const SQLITE_DBCONFIG_MAX: i32 = 1019;\npub const SQLITE_DENY: i32 = 1;\npub const SQLITE_IGNORE: i32 = 2;\npub const SQLITE_CREATE_INDEX: i32 = 1;\npub const SQLITE_CREATE_TABLE: i32 = 2;\npub const SQLITE_CREATE_TEMP_INDEX: i32 = 3;\npub const SQLITE_CREATE_TEMP_TABLE: i32 = 4;\npub const SQLITE_CREATE_TEMP_TRIGGER: i32 = 5;\npub const SQLITE_CREATE_TEMP_VIEW: i32 = 6;\npub const SQLITE_CREATE_TRIGGER: i32 = 7;\npub const SQLITE_CREATE_VIEW: i32 = 8;\npub const SQLITE_DELETE: i32 = 9;\npub const SQLITE_DROP_INDEX: i32 = 10;\npub const SQLITE_DROP_TABLE: i32 = 11;\npub const SQLITE_DROP_TEMP_INDEX: i32 = 12;\npub const SQLITE_DROP_TEMP_TABLE: i32 = 13;\npub const SQLITE_DROP_TEMP_TRIGGER: i32 = 14;\npub const SQLITE_DROP_TEMP_VIEW: i32 = 15;\npub const SQLITE_DROP_TRIGGER: i32 = 16;\npub const SQLITE_DROP_VIEW: i32 = 17;\npub const SQLITE_INSERT: i32 = 18;\npub const SQLITE_PRAGMA: i32 = 19;\npub const SQLITE_READ: i32 = 20;\npub const SQLITE_SELECT: i32 = 21;\npub const SQLITE_TRANSACTION: i32 = 22;\npub const SQLITE_UPDATE: i32 = 23;\npub const SQLITE_ATTACH: i32 = 24;\npub const SQLITE_DETACH: i32 = 25;\npub const SQLITE_ALTER_TABLE: i32 = 26;\npub const SQLITE_REINDEX: i32 = 27;\npub const SQLITE_ANALYZE: i32 = 28;\npub const SQLITE_CREATE_VTABLE: i32 = 29;\npub const SQLITE_DROP_VTABLE: i32 = 30;\npub const SQLITE_FUNCTION: i32 = 31;\npub const SQLITE_SAVEPOINT: i32 = 32;\npub const SQLITE_COPY: i32 = 0;\npub const SQLITE_RECURSIVE: i32 = 33;\npub const SQLITE_TRACE_STMT: i32 = 1;\npub const SQLITE_TRACE_PROFILE: i32 = 2;\npub const SQLITE_TRACE_ROW: i32 = 4;\npub const SQLITE_TRACE_CLOSE: i32 = 8;\npub const SQLITE_LIMIT_LENGTH: i32 = 0;\npub const SQLITE_LIMIT_SQL_LENGTH: i32 = 1;\npub const SQLITE_LIMIT_COLUMN: i32 = 2;\npub const SQLITE_LIMIT_EXPR_DEPTH: i32 = 3;\npub const SQLITE_LIMIT_COMPOUND_SELECT: i32 = 4;\npub const SQLITE_LIMIT_VDBE_OP: i32 = 5;\npub const SQLITE_LIMIT_FUNCTION_ARG: i32 = 6;\npub const SQLITE_LIMIT_ATTACHED: i32 = 7;\npub const SQLITE_LIMIT_LIKE_PATTERN_LENGTH: i32 = 8;\npub const SQLITE_LIMIT_VARIABLE_NUMBER: i32 = 9;\npub const SQLITE_LIMIT_TRIGGER_DEPTH: i32 = 10;\npub const SQLITE_LIMIT_WORKER_THREADS: i32 = 11;\npub const SQLITE_PREPARE_PERSISTENT: ::std::os::raw::c_uint = 1;\npub const SQLITE_PREPARE_NORMALIZE: ::std::os::raw::c_uint = 2;\npub const SQLITE_PREPARE_NO_VTAB: ::std::os::raw::c_uint = 4;\npub const SQLITE_INTEGER: i32 = 1;\npub const SQLITE_FLOAT: i32 = 2;\npub const SQLITE_BLOB: i32 = 4;\npub const SQLITE_NULL: i32 = 5;\npub const SQLITE_TEXT: i32 = 3;\npub const SQLITE3_TEXT: i32 = 3;\npub const SQLITE_UTF8: i32 = 1;\npub const SQLITE_UTF16LE: i32 = 2;\npub const SQLITE_UTF16BE: i32 = 3;\npub const SQLITE_UTF16: i32 = 4;\npub const SQLITE_ANY: i32 = 5;\npub const SQLITE_UTF16_ALIGNED: i32 = 8;\npub const SQLITE_DETERMINISTIC: i32 = 2048;\npub const SQLITE_DIRECTONLY: i32 = 524288;\npub const SQLITE_SUBTYPE: i32 = 1048576;\npub const SQLITE_INNOCUOUS: i32 = 2097152;\npub const SQLITE_RESULT_SUBTYPE: i32 = 16777216;\npub const SQLITE_WIN32_DATA_DIRECTORY_TYPE: i32 = 1;\npub const SQLITE_WIN32_TEMP_DIRECTORY_TYPE: i32 = 2;\npub const SQLITE_TXN_NONE: i32 = 0;\npub const SQLITE_TXN_READ: i32 = 1;\npub const SQLITE_TXN_WRITE: i32 = 2;\npub const SQLITE_INDEX_SCAN_UNIQUE: i32 = 1;\npub const SQLITE_INDEX_CONSTRAINT_EQ: i32 = 2;\npub const SQLITE_INDEX_CONSTRAINT_GT: i32 = 4;\npub const SQLITE_INDEX_CONSTRAINT_LE: i32 = 8;\npub const SQLITE_INDEX_CONSTRAINT_LT: i32 = 16;\npub const SQLITE_INDEX_CONSTRAINT_GE: i32 = 32;\npub const SQLITE_INDEX_CONSTRAINT_MATCH: i32 = 64;\npub const SQLITE_INDEX_CONSTRAINT_LIKE: i32 = 65;\npub const SQLITE_INDEX_CONSTRAINT_GLOB: i32 = 66;\npub const SQLITE_INDEX_CONSTRAINT_REGEXP: i32 = 67;\npub const SQLITE_INDEX_CONSTRAINT_NE: i32 = 68;\npub const SQLITE_INDEX_CONSTRAINT_ISNOT: i32 = 69;\npub const SQLITE_INDEX_CONSTRAINT_ISNOTNULL: i32 = 70;\npub const SQLITE_INDEX_CONSTRAINT_ISNULL: i32 = 71;\npub const SQLITE_INDEX_CONSTRAINT_IS: i32 = 72;\npub const SQLITE_INDEX_CONSTRAINT_LIMIT: i32 = 73;\npub const SQLITE_INDEX_CONSTRAINT_OFFSET: i32 = 74;\npub const SQLITE_INDEX_CONSTRAINT_FUNCTION: i32 = 150;\npub const SQLITE_MUTEX_FAST: i32 = 0;\npub const SQLITE_MUTEX_RECURSIVE: i32 = 1;\npub const SQLITE_MUTEX_STATIC_MAIN: i32 = 2;\npub const SQLITE_MUTEX_STATIC_MEM: i32 = 3;\npub const SQLITE_MUTEX_STATIC_MEM2: i32 = 4;\npub const SQLITE_MUTEX_STATIC_OPEN: i32 = 4;\npub const SQLITE_MUTEX_STATIC_PRNG: i32 = 5;\npub const SQLITE_MUTEX_STATIC_LRU: i32 = 6;\npub const SQLITE_MUTEX_STATIC_LRU2: i32 = 7;\npub const SQLITE_MUTEX_STATIC_PMEM: i32 = 7;\npub const SQLITE_MUTEX_STATIC_APP1: i32 = 8;\npub const SQLITE_MUTEX_STATIC_APP2: i32 = 9;\npub const SQLITE_MUTEX_STATIC_APP3: i32 = 10;\npub const SQLITE_MUTEX_STATIC_VFS1: i32 = 11;\npub const SQLITE_MUTEX_STATIC_VFS2: i32 = 12;\npub const SQLITE_MUTEX_STATIC_VFS3: i32 = 13;\npub const SQLITE_MUTEX_STATIC_MASTER: i32 = 2;\npub const SQLITE_TESTCTRL_FIRST: i32 = 5;\npub const SQLITE_TESTCTRL_PRNG_SAVE: i32 = 5;\npub const SQLITE_TESTCTRL_PRNG_RESTORE: i32 = 6;\npub const SQLITE_TESTCTRL_PRNG_RESET: i32 = 7;\npub const SQLITE_TESTCTRL_FK_NO_ACTION: i32 = 7;\npub const SQLITE_TESTCTRL_BITVEC_TEST: i32 = 8;\npub const SQLITE_TESTCTRL_FAULT_INSTALL: i32 = 9;\npub const SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: i32 = 10;\npub const SQLITE_TESTCTRL_PENDING_BYTE: i32 = 11;\npub const SQLITE_TESTCTRL_ASSERT: i32 = 12;\npub const SQLITE_TESTCTRL_ALWAYS: i32 = 13;\npub const SQLITE_TESTCTRL_RESERVE: i32 = 14;\npub const SQLITE_TESTCTRL_JSON_SELFCHECK: i32 = 14;\npub const SQLITE_TESTCTRL_OPTIMIZATIONS: i32 = 15;\npub const SQLITE_TESTCTRL_ISKEYWORD: i32 = 16;\npub const SQLITE_TESTCTRL_SCRATCHMALLOC: i32 = 17;\npub const SQLITE_TESTCTRL_INTERNAL_FUNCTIONS: i32 = 17;\npub const SQLITE_TESTCTRL_LOCALTIME_FAULT: i32 = 18;\npub const SQLITE_TESTCTRL_EXPLAIN_STMT: i32 = 19;\npub const SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD: i32 = 19;\npub const SQLITE_TESTCTRL_NEVER_CORRUPT: i32 = 20;\npub const SQLITE_TESTCTRL_VDBE_COVERAGE: i32 = 21;\npub const SQLITE_TESTCTRL_BYTEORDER: i32 = 22;\npub const SQLITE_TESTCTRL_ISINIT: i32 = 23;\npub const SQLITE_TESTCTRL_SORTER_MMAP: i32 = 24;\npub const SQLITE_TESTCTRL_IMPOSTER: i32 = 25;\npub const SQLITE_TESTCTRL_PARSER_COVERAGE: i32 = 26;\npub const SQLITE_TESTCTRL_RESULT_INTREAL: i32 = 27;\npub const SQLITE_TESTCTRL_PRNG_SEED: i32 = 28;\npub const SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS: i32 = 29;\npub const SQLITE_TESTCTRL_SEEK_COUNT: i32 = 30;\npub const SQLITE_TESTCTRL_TRACEFLAGS: i32 = 31;\npub const SQLITE_TESTCTRL_TUNE: i32 = 32;\npub const SQLITE_TESTCTRL_LOGEST: i32 = 33;\npub const SQLITE_TESTCTRL_USELONGDOUBLE: i32 = 34;\npub const SQLITE_TESTCTRL_LAST: i32 = 34;\npub const SQLITE_STATUS_MEMORY_USED: i32 = 0;\npub const SQLITE_STATUS_PAGECACHE_USED: i32 = 1;\npub const SQLITE_STATUS_PAGECACHE_OVERFLOW: i32 = 2;\npub const SQLITE_STATUS_SCRATCH_USED: i32 = 3;\npub const SQLITE_STATUS_SCRATCH_OVERFLOW: i32 = 4;\npub const SQLITE_STATUS_MALLOC_SIZE: i32 = 5;\npub const SQLITE_STATUS_PARSER_STACK: i32 = 6;\npub const SQLITE_STATUS_PAGECACHE_SIZE: i32 = 7;\npub const SQLITE_STATUS_SCRATCH_SIZE: i32 = 8;\npub const SQLITE_STATUS_MALLOC_COUNT: i32 = 9;\npub const SQLITE_DBSTATUS_LOOKASIDE_USED: i32 = 0;\npub const SQLITE_DBSTATUS_CACHE_USED: i32 = 1;\npub const SQLITE_DBSTATUS_SCHEMA_USED: i32 = 2;\npub const SQLITE_DBSTATUS_STMT_USED: i32 = 3;\npub const SQLITE_DBSTATUS_LOOKASIDE_HIT: i32 = 4;\npub const SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE: i32 = 5;\npub const SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: i32 = 6;\npub const SQLITE_DBSTATUS_CACHE_HIT: i32 = 7;\npub const SQLITE_DBSTATUS_CACHE_MISS: i32 = 8;\npub const SQLITE_DBSTATUS_CACHE_WRITE: i32 = 9;\npub const SQLITE_DBSTATUS_DEFERRED_FKS: i32 = 10;\npub const SQLITE_DBSTATUS_CACHE_USED_SHARED: i32 = 11;\npub const SQLITE_DBSTATUS_CACHE_SPILL: i32 = 12;\npub const SQLITE_DBSTATUS_MAX: i32 = 12;\npub const SQLITE_STMTSTATUS_FULLSCAN_STEP: i32 = 1;\npub const SQLITE_STMTSTATUS_SORT: i32 = 2;\npub const SQLITE_STMTSTATUS_AUTOINDEX: i32 = 3;\npub const SQLITE_STMTSTATUS_VM_STEP: i32 = 4;\npub const SQLITE_STMTSTATUS_REPREPARE: i32 = 5;\npub const SQLITE_STMTSTATUS_RUN: i32 = 6;\npub const SQLITE_STMTSTATUS_FILTER_MISS: i32 = 7;\npub const SQLITE_STMTSTATUS_FILTER_HIT: i32 = 8;\npub const SQLITE_STMTSTATUS_MEMUSED: i32 = 99;\npub const SQLITE_CHECKPOINT_PASSIVE: i32 = 0;\npub const SQLITE_CHECKPOINT_FULL: i32 = 1;\npub const SQLITE_CHECKPOINT_RESTART: i32 = 2;\npub const SQLITE_CHECKPOINT_TRUNCATE: i32 = 3;\npub const SQLITE_VTAB_CONSTRAINT_SUPPORT: i32 = 1;\npub const SQLITE_VTAB_INNOCUOUS: i32 = 2;\npub const SQLITE_VTAB_DIRECTONLY: i32 = 3;\npub const SQLITE_VTAB_USES_ALL_SCHEMAS: i32 = 4;\npub const SQLITE_ROLLBACK: i32 = 1;\npub const SQLITE_FAIL: i32 = 3;\npub const SQLITE_REPLACE: i32 = 5;\npub const SQLITE_SCANSTAT_NLOOP: i32 = 0;\npub const SQLITE_SCANSTAT_NVISIT: i32 = 1;\npub const SQLITE_SCANSTAT_EST: i32 = 2;\npub const SQLITE_SCANSTAT_NAME: i32 = 3;\npub const SQLITE_SCANSTAT_EXPLAIN: i32 = 4;\npub const SQLITE_SCANSTAT_SELECTID: i32 = 5;\npub const SQLITE_SCANSTAT_PARENTID: i32 = 6;\npub const SQLITE_SCANSTAT_NCYCLE: i32 = 7;\npub const SQLITE_SCANSTAT_COMPLEX: i32 = 1;\npub const SQLITE_SERIALIZE_NOCOPY: ::std::os::raw::c_uint = 1;\npub const SQLITE_DESERIALIZE_FREEONCLOSE: ::std::os::raw::c_uint = 1;\npub const SQLITE_DESERIALIZE_RESIZEABLE: ::std::os::raw::c_uint = 2;\npub const SQLITE_DESERIALIZE_READONLY: ::std::os::raw::c_uint = 4;\npub const NOT_WITHIN: i32 = 0;\npub const PARTLY_WITHIN: i32 = 1;\npub const FULLY_WITHIN: i32 = 2;\npub const SQLITE_SESSION_OBJCONFIG_SIZE: i32 = 1;\npub const SQLITE_SESSION_OBJCONFIG_ROWID: i32 = 2;\npub const SQLITE_CHANGESETSTART_INVERT: i32 = 2;\npub const SQLITE_CHANGESETAPPLY_NOSAVEPOINT: i32 = 1;\npub const SQLITE_CHANGESETAPPLY_INVERT: i32 = 2;\npub const SQLITE_CHANGESETAPPLY_IGNORENOOP: i32 = 4;\npub const SQLITE_CHANGESETAPPLY_FKNOACTION: i32 = 8;\npub const SQLITE_CHANGESET_DATA: i32 = 1;\npub const SQLITE_CHANGESET_NOTFOUND: i32 = 2;\npub const SQLITE_CHANGESET_CONFLICT: i32 = 3;\npub const SQLITE_CHANGESET_CONSTRAINT: i32 = 4;\npub const SQLITE_CHANGESET_FOREIGN_KEY: i32 = 5;\npub const SQLITE_CHANGESET_OMIT: i32 = 0;\npub const SQLITE_CHANGESET_REPLACE: i32 = 1;\npub const SQLITE_CHANGESET_ABORT: i32 = 2;\npub const SQLITE_SESSION_CONFIG_STRMSIZE: i32 = 1;\npub const FTS5_TOKENIZE_QUERY: i32 = 1;\npub const FTS5_TOKENIZE_PREFIX: i32 = 2;\npub const FTS5_TOKENIZE_DOCUMENT: i32 = 4;\npub const FTS5_TOKENIZE_AUX: i32 = 8;\npub const FTS5_TOKEN_COLOCATED: i32 = 1;\nextern \"C\" {\n    pub static sqlite3_version: [::std::os::raw::c_char; 0usize];\n}\nextern \"C\" {\n    pub fn sqlite3_libversion() -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_sourceid() -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_libversion_number() -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_compileoption_used(\n        zOptName: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_compileoption_get(N: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_threadsafe() -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3 {\n    _unused: [u8; 0],\n}\npub type sqlite_int64 = ::std::os::raw::c_longlong;\npub type sqlite_uint64 = ::std::os::raw::c_ulonglong;\npub type sqlite3_int64 = sqlite_int64;\npub type sqlite3_uint64 = sqlite_uint64;\nextern \"C\" {\n    pub fn sqlite3_close(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\npub type sqlite3_callback = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        arg1: *mut ::std::os::raw::c_void,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut *mut ::std::os::raw::c_char,\n        arg4: *mut *mut ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int,\n>;\nextern \"C\" {\n    pub fn sqlite3_exec(\n        arg1: *mut sqlite3,\n        sql: *const ::std::os::raw::c_char,\n        callback: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut ::std::os::raw::c_char,\n                arg4: *mut *mut ::std::os::raw::c_char,\n            ) -> ::std::os::raw::c_int,\n        >,\n        arg2: *mut ::std::os::raw::c_void,\n        errmsg: *mut *mut ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_file {\n    pub pMethods: *const sqlite3_io_methods,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_io_methods {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xClose: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file) -> ::std::os::raw::c_int,\n    >,\n    pub xRead: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: *mut ::std::os::raw::c_void,\n            iAmt: ::std::os::raw::c_int,\n            iOfst: sqlite3_int64,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xWrite: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: *const ::std::os::raw::c_void,\n            iAmt: ::std::os::raw::c_int,\n            iOfst: sqlite3_int64,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xTruncate: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file, size: sqlite3_int64) -> ::std::os::raw::c_int,\n    >,\n    pub xSync: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            flags: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xFileSize: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            pSize: *mut sqlite3_int64,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xLock: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xUnlock: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xCheckReservedLock: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            pResOut: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xFileControl: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            op: ::std::os::raw::c_int,\n            pArg: *mut ::std::os::raw::c_void,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xSectorSize: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file) -> ::std::os::raw::c_int,\n    >,\n    pub xDeviceCharacteristics: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file) -> ::std::os::raw::c_int,\n    >,\n    pub xShmMap: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            iPg: ::std::os::raw::c_int,\n            pgsz: ::std::os::raw::c_int,\n            arg2: ::std::os::raw::c_int,\n            arg3: *mut *mut ::std::os::raw::c_void,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xShmLock: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            offset: ::std::os::raw::c_int,\n            n: ::std::os::raw::c_int,\n            flags: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xShmBarrier: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_file)>,\n    pub xShmUnmap: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            deleteFlag: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xFetch: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            iOfst: sqlite3_int64,\n            iAmt: ::std::os::raw::c_int,\n            pp: *mut *mut ::std::os::raw::c_void,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xUnfetch: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            iOfst: sqlite3_int64,\n            p: *mut ::std::os::raw::c_void,\n        ) -> ::std::os::raw::c_int,\n    >,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_mutex {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_api_routines {\n    _unused: [u8; 0],\n}\npub type sqlite3_filename = *const ::std::os::raw::c_char;\npub type sqlite3_syscall_ptr = ::std::option::Option<unsafe extern \"C\" fn()>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_vfs {\n    pub iVersion: ::std::os::raw::c_int,\n    pub szOsFile: ::std::os::raw::c_int,\n    pub mxPathname: ::std::os::raw::c_int,\n    pub pNext: *mut sqlite3_vfs,\n    pub zName: *const ::std::os::raw::c_char,\n    pub pAppData: *mut ::std::os::raw::c_void,\n    pub xOpen: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: sqlite3_filename,\n            arg2: *mut sqlite3_file,\n            flags: ::std::os::raw::c_int,\n            pOutFlags: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xDelete: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            syncDir: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xAccess: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            flags: ::std::os::raw::c_int,\n            pResOut: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xFullPathname: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            nOut: ::std::os::raw::c_int,\n            zOut: *mut ::std::os::raw::c_char,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xDlOpen: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zFilename: *const ::std::os::raw::c_char,\n        ) -> *mut ::std::os::raw::c_void,\n    >,\n    pub xDlError: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            nByte: ::std::os::raw::c_int,\n            zErrMsg: *mut ::std::os::raw::c_char,\n        ),\n    >,\n    pub xDlSym: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            arg2: *mut ::std::os::raw::c_void,\n            zSymbol: *const ::std::os::raw::c_char,\n        ) -> ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_vfs,\n                arg2: *mut ::std::os::raw::c_void,\n                zSymbol: *const ::std::os::raw::c_char,\n            ),\n        >,\n    >,\n    pub xDlClose: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vfs, arg2: *mut ::std::os::raw::c_void),\n    >,\n    pub xRandomness: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            nByte: ::std::os::raw::c_int,\n            zOut: *mut ::std::os::raw::c_char,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xSleep: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            microseconds: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xCurrentTime: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vfs, arg2: *mut f64) -> ::std::os::raw::c_int,\n    >,\n    pub xGetLastError: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            arg2: ::std::os::raw::c_int,\n            arg3: *mut ::std::os::raw::c_char,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xCurrentTimeInt64: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            arg2: *mut sqlite3_int64,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xSetSystemCall: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            arg2: sqlite3_syscall_ptr,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xGetSystemCall: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n        ) -> sqlite3_syscall_ptr,\n    >,\n    pub xNextSystemCall: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n        ) -> *const ::std::os::raw::c_char,\n    >,\n}\nextern \"C\" {\n    pub fn sqlite3_initialize() -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_shutdown() -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_os_init() -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_os_end() -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_config(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_config(\n        arg1: *mut sqlite3,\n        op: ::std::os::raw::c_int,\n        ...\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_mem_methods {\n    pub xMalloc: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void,\n    >,\n    pub xFree: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    pub xRealloc: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: ::std::os::raw::c_int,\n        ) -> *mut ::std::os::raw::c_void,\n    >,\n    pub xSize: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub xRoundup: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,\n    >,\n    pub xInit: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub xShutdown: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    pub pAppData: *mut ::std::os::raw::c_void,\n}\nextern \"C\" {\n    pub fn sqlite3_extended_result_codes(\n        arg1: *mut sqlite3,\n        onoff: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_last_insert_rowid(arg1: *mut sqlite3) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_set_last_insert_rowid(arg1: *mut sqlite3, arg2: sqlite3_int64);\n}\nextern \"C\" {\n    pub fn sqlite3_changes(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_changes64(arg1: *mut sqlite3) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_total_changes(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_total_changes64(arg1: *mut sqlite3) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_interrupt(arg1: *mut sqlite3);\n}\nextern \"C\" {\n    pub fn sqlite3_is_interrupted(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_complete(sql: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_busy_handler(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_busy_timeout(\n        arg1: *mut sqlite3,\n        ms: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_get_table(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_char,\n        pazResult: *mut *mut *mut ::std::os::raw::c_char,\n        pnRow: *mut ::std::os::raw::c_int,\n        pnColumn: *mut ::std::os::raw::c_int,\n        pzErrmsg: *mut *mut ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_free_table(result: *mut *mut ::std::os::raw::c_char);\n}\nextern \"C\" {\n    pub fn sqlite3_mprintf(arg1: *const ::std::os::raw::c_char, ...)\n        -> *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_snprintf(\n        arg1: ::std::os::raw::c_int,\n        arg2: *mut ::std::os::raw::c_char,\n        arg3: *const ::std::os::raw::c_char,\n        ...\n    ) -> *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_malloc(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_malloc64(arg1: sqlite3_uint64) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_realloc(\n        arg1: *mut ::std::os::raw::c_void,\n        arg2: ::std::os::raw::c_int,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_realloc64(\n        arg1: *mut ::std::os::raw::c_void,\n        arg2: sqlite3_uint64,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_free(arg1: *mut ::std::os::raw::c_void);\n}\nextern \"C\" {\n    pub fn sqlite3_msize(arg1: *mut ::std::os::raw::c_void) -> sqlite3_uint64;\n}\nextern \"C\" {\n    pub fn sqlite3_memory_used() -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_memory_highwater(resetFlag: ::std::os::raw::c_int) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_randomness(N: ::std::os::raw::c_int, P: *mut ::std::os::raw::c_void);\n}\nextern \"C\" {\n    pub fn sqlite3_set_authorizer(\n        arg1: *mut sqlite3,\n        xAuth: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_char,\n                arg4: *const ::std::os::raw::c_char,\n                arg5: *const ::std::os::raw::c_char,\n                arg6: *const ::std::os::raw::c_char,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pUserData: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_trace(\n        arg1: *mut sqlite3,\n        xTrace: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *const ::std::os::raw::c_char,\n            ),\n        >,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_profile(\n        arg1: *mut sqlite3,\n        xProfile: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *const ::std::os::raw::c_char,\n                arg3: sqlite3_uint64,\n            ),\n        >,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_trace_v2(\n        arg1: *mut sqlite3,\n        uMask: ::std::os::raw::c_uint,\n        xCallback: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: ::std::os::raw::c_uint,\n                arg2: *mut ::std::os::raw::c_void,\n                arg3: *mut ::std::os::raw::c_void,\n                arg4: *mut ::std::os::raw::c_void,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pCtx: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_progress_handler(\n        arg1: *mut sqlite3,\n        arg2: ::std::os::raw::c_int,\n        arg3: ::std::option::Option<\n            unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n        >,\n        arg4: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_open(\n        filename: *const ::std::os::raw::c_char,\n        ppDb: *mut *mut sqlite3,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_open_v2(\n        filename: *const ::std::os::raw::c_char,\n        ppDb: *mut *mut sqlite3,\n        flags: ::std::os::raw::c_int,\n        zVfs: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_parameter(\n        z: sqlite3_filename,\n        zParam: *const ::std::os::raw::c_char,\n    ) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_boolean(\n        z: sqlite3_filename,\n        zParam: *const ::std::os::raw::c_char,\n        bDefault: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_int64(\n        arg1: sqlite3_filename,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: sqlite3_int64,\n    ) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_key(\n        z: sqlite3_filename,\n        N: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_filename_database(arg1: sqlite3_filename) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_filename_journal(arg1: sqlite3_filename) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_filename_wal(arg1: sqlite3_filename) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_database_file_object(arg1: *const ::std::os::raw::c_char) -> *mut sqlite3_file;\n}\nextern \"C\" {\n    pub fn sqlite3_create_filename(\n        zDatabase: *const ::std::os::raw::c_char,\n        zJournal: *const ::std::os::raw::c_char,\n        zWal: *const ::std::os::raw::c_char,\n        nParam: ::std::os::raw::c_int,\n        azParam: *mut *const ::std::os::raw::c_char,\n    ) -> sqlite3_filename;\n}\nextern \"C\" {\n    pub fn sqlite3_free_filename(arg1: sqlite3_filename);\n}\nextern \"C\" {\n    pub fn sqlite3_errcode(db: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_extended_errcode(db: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_errmsg(arg1: *mut sqlite3) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_errstr(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_error_offset(db: *mut sqlite3) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_stmt {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_limit(\n        arg1: *mut sqlite3,\n        id: ::std::os::raw::c_int,\n        newVal: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_prepare_v2(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_char,\n        nByte: ::std::os::raw::c_int,\n        ppStmt: *mut *mut sqlite3_stmt,\n        pzTail: *mut *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_prepare_v3(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_char,\n        nByte: ::std::os::raw::c_int,\n        prepFlags: ::std::os::raw::c_uint,\n        ppStmt: *mut *mut sqlite3_stmt,\n        pzTail: *mut *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_sql(pStmt: *mut sqlite3_stmt) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_expanded_sql(pStmt: *mut sqlite3_stmt) -> *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_readonly(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_isexplain(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_explain(\n        pStmt: *mut sqlite3_stmt,\n        eMode: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_busy(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_value {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_context {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_bind_blob(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_void,\n        n: ::std::os::raw::c_int,\n        arg4: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_blob64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_void,\n        arg4: sqlite3_uint64,\n        arg5: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_double(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: f64,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_int(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_int64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: sqlite3_int64,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_null(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_text(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_char,\n        arg4: ::std::os::raw::c_int,\n        arg5: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_text64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_char,\n        arg4: sqlite3_uint64,\n        arg5: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n        encoding: ::std::os::raw::c_uchar,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_value(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const sqlite3_value,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_pointer(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut ::std::os::raw::c_void,\n        arg4: *const ::std::os::raw::c_char,\n        arg5: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_zeroblob(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        n: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_zeroblob64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: sqlite3_uint64,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_parameter_count(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_parameter_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_parameter_index(\n        arg1: *mut sqlite3_stmt,\n        zName: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_clear_bindings(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_name(\n        arg1: *mut sqlite3_stmt,\n        N: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_database_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_table_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_origin_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_decltype(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_step(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_data_count(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_blob(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_column_double(arg1: *mut sqlite3_stmt, iCol: ::std::os::raw::c_int) -> f64;\n}\nextern \"C\" {\n    pub fn sqlite3_column_int(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_int64(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_column_text(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_uchar;\n}\nextern \"C\" {\n    pub fn sqlite3_column_value(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -> *mut sqlite3_value;\n}\nextern \"C\" {\n    pub fn sqlite3_column_bytes(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_type(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_function_v2(\n        db: *mut sqlite3,\n        zFunctionName: *const ::std::os::raw::c_char,\n        nArg: ::std::os::raw::c_int,\n        eTextRep: ::std::os::raw::c_int,\n        pApp: *mut ::std::os::raw::c_void,\n        xFunc: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        >,\n        xStep: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        >,\n        xFinal: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n        xDestroy: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_window_function(\n        db: *mut sqlite3,\n        zFunctionName: *const ::std::os::raw::c_char,\n        nArg: ::std::os::raw::c_int,\n        eTextRep: ::std::os::raw::c_int,\n        pApp: *mut ::std::os::raw::c_void,\n        xStep: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        >,\n        xFinal: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n        xValue: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n        xInverse: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        >,\n        xDestroy: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_aggregate_count(arg1: *mut sqlite3_context) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_expired(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_transfer_bindings(\n        arg1: *mut sqlite3_stmt,\n        arg2: *mut sqlite3_stmt,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_global_recover() -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_thread_cleanup();\n}\nextern \"C\" {\n    pub fn sqlite3_memory_alarm(\n        arg1: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: sqlite3_int64,\n                arg3: ::std::os::raw::c_int,\n            ),\n        >,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: sqlite3_int64,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_blob(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_value_double(arg1: *mut sqlite3_value) -> f64;\n}\nextern \"C\" {\n    pub fn sqlite3_value_int(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_int64(arg1: *mut sqlite3_value) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_value_pointer(\n        arg1: *mut sqlite3_value,\n        arg2: *const ::std::os::raw::c_char,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_value_text(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_uchar;\n}\nextern \"C\" {\n    pub fn sqlite3_value_bytes(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_type(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_numeric_type(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_nochange(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_frombind(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_encoding(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_subtype(arg1: *mut sqlite3_value) -> ::std::os::raw::c_uint;\n}\nextern \"C\" {\n    pub fn sqlite3_value_dup(arg1: *const sqlite3_value) -> *mut sqlite3_value;\n}\nextern \"C\" {\n    pub fn sqlite3_value_free(arg1: *mut sqlite3_value);\n}\nextern \"C\" {\n    pub fn sqlite3_aggregate_context(\n        arg1: *mut sqlite3_context,\n        nBytes: ::std::os::raw::c_int,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_user_data(arg1: *mut sqlite3_context) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_context_db_handle(arg1: *mut sqlite3_context) -> *mut sqlite3;\n}\nextern \"C\" {\n    pub fn sqlite3_get_auxdata(\n        arg1: *mut sqlite3_context,\n        N: ::std::os::raw::c_int,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_set_auxdata(\n        arg1: *mut sqlite3_context,\n        N: ::std::os::raw::c_int,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_get_clientdata(\n        arg1: *mut sqlite3,\n        arg2: *const ::std::os::raw::c_char,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_set_clientdata(\n        arg1: *mut sqlite3,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: *mut ::std::os::raw::c_void,\n        arg4: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\npub type sqlite3_destructor_type =\n    ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>;\nextern \"C\" {\n    pub fn sqlite3_result_blob(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_void,\n        arg3: ::std::os::raw::c_int,\n        arg4: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_blob64(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_void,\n        arg3: sqlite3_uint64,\n        arg4: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_double(arg1: *mut sqlite3_context, arg2: f64);\n}\nextern \"C\" {\n    pub fn sqlite3_result_error(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: ::std::os::raw::c_int,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_error_toobig(arg1: *mut sqlite3_context);\n}\nextern \"C\" {\n    pub fn sqlite3_result_error_nomem(arg1: *mut sqlite3_context);\n}\nextern \"C\" {\n    pub fn sqlite3_result_error_code(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_result_int(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_result_int64(arg1: *mut sqlite3_context, arg2: sqlite3_int64);\n}\nextern \"C\" {\n    pub fn sqlite3_result_null(arg1: *mut sqlite3_context);\n}\nextern \"C\" {\n    pub fn sqlite3_result_text(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: ::std::os::raw::c_int,\n        arg4: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_text64(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: sqlite3_uint64,\n        arg4: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n        encoding: ::std::os::raw::c_uchar,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_value(arg1: *mut sqlite3_context, arg2: *mut sqlite3_value);\n}\nextern \"C\" {\n    pub fn sqlite3_result_pointer(\n        arg1: *mut sqlite3_context,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: *const ::std::os::raw::c_char,\n        arg4: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_zeroblob(arg1: *mut sqlite3_context, n: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_result_zeroblob64(\n        arg1: *mut sqlite3_context,\n        n: sqlite3_uint64,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_result_subtype(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_uint);\n}\nextern \"C\" {\n    pub fn sqlite3_create_collation_v2(\n        arg1: *mut sqlite3,\n        zName: *const ::std::os::raw::c_char,\n        eTextRep: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n        xCompare: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_void,\n                arg4: ::std::os::raw::c_int,\n                arg5: *const ::std::os::raw::c_void,\n            ) -> ::std::os::raw::c_int,\n        >,\n        xDestroy: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_collation_needed(\n        arg1: *mut sqlite3,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *mut sqlite3,\n                eTextRep: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_char,\n            ),\n        >,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_sleep(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub static mut sqlite3_temp_directory: *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub static mut sqlite3_data_directory: *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_win32_set_directory(\n        type_: ::std::os::raw::c_ulong,\n        zValue: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_win32_set_directory8(\n        type_: ::std::os::raw::c_ulong,\n        zValue: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_get_autocommit(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_handle(arg1: *mut sqlite3_stmt) -> *mut sqlite3;\n}\nextern \"C\" {\n    pub fn sqlite3_db_name(\n        db: *mut sqlite3,\n        N: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_db_filename(\n        db: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n    ) -> sqlite3_filename;\n}\nextern \"C\" {\n    pub fn sqlite3_db_readonly(\n        db: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_txn_state(\n        arg1: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_next_stmt(pDb: *mut sqlite3, pStmt: *mut sqlite3_stmt) -> *mut sqlite3_stmt;\n}\nextern \"C\" {\n    pub fn sqlite3_commit_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option<\n            unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n        >,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_rollback_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_autovacuum_pages(\n        db: *mut sqlite3,\n        arg1: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *const ::std::os::raw::c_char,\n                arg3: ::std::os::raw::c_uint,\n                arg4: ::std::os::raw::c_uint,\n                arg5: ::std::os::raw::c_uint,\n            ) -> ::std::os::raw::c_uint,\n        >,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_update_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_char,\n                arg4: *const ::std::os::raw::c_char,\n                arg5: sqlite3_int64,\n            ),\n        >,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_enable_shared_cache(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_release_memory(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_release_memory(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_soft_heap_limit64(N: sqlite3_int64) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_hard_heap_limit64(N: sqlite3_int64) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_soft_heap_limit(N: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_table_column_metadata(\n        db: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n        zTableName: *const ::std::os::raw::c_char,\n        zColumnName: *const ::std::os::raw::c_char,\n        pzDataType: *mut *const ::std::os::raw::c_char,\n        pzCollSeq: *mut *const ::std::os::raw::c_char,\n        pNotNull: *mut ::std::os::raw::c_int,\n        pPrimaryKey: *mut ::std::os::raw::c_int,\n        pAutoinc: *mut ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_load_extension(\n        db: *mut sqlite3,\n        zFile: *const ::std::os::raw::c_char,\n        zProc: *const ::std::os::raw::c_char,\n        pzErrMsg: *mut *mut ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_enable_load_extension(\n        db: *mut sqlite3,\n        onoff: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_reset_auto_extension();\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_module {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xCreate: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3,\n            pAux: *mut ::std::os::raw::c_void,\n            argc: ::std::os::raw::c_int,\n            argv: *const *const ::std::os::raw::c_char,\n            ppVTab: *mut *mut sqlite3_vtab,\n            arg2: *mut *mut ::std::os::raw::c_char,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xConnect: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3,\n            pAux: *mut ::std::os::raw::c_void,\n            argc: ::std::os::raw::c_int,\n            argv: *const *const ::std::os::raw::c_char,\n            ppVTab: *mut *mut sqlite3_vtab,\n            arg2: *mut *mut ::std::os::raw::c_char,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xBestIndex: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: *mut sqlite3_index_info,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xDisconnect: ::std::option::Option<\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,\n    >,\n    pub xDestroy: ::std::option::Option<\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,\n    >,\n    pub xOpen: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            ppCursor: *mut *mut sqlite3_vtab_cursor,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xClose: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vtab_cursor) -> ::std::os::raw::c_int,\n    >,\n    pub xFilter: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab_cursor,\n            idxNum: ::std::os::raw::c_int,\n            idxStr: *const ::std::os::raw::c_char,\n            argc: ::std::os::raw::c_int,\n            argv: *mut *mut sqlite3_value,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xNext: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vtab_cursor) -> ::std::os::raw::c_int,\n    >,\n    pub xEof: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vtab_cursor) -> ::std::os::raw::c_int,\n    >,\n    pub xColumn: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab_cursor,\n            arg2: *mut sqlite3_context,\n            arg3: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xRowid: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab_cursor,\n            pRowid: *mut sqlite3_int64,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xUpdate: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab,\n            arg2: ::std::os::raw::c_int,\n            arg3: *mut *mut sqlite3_value,\n            arg4: *mut sqlite3_int64,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xBegin: ::std::option::Option<\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,\n    >,\n    pub xSync: ::std::option::Option<\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,\n    >,\n    pub xCommit: ::std::option::Option<\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,\n    >,\n    pub xRollback: ::std::option::Option<\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,\n    >,\n    pub xFindFunction: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pVtab: *mut sqlite3_vtab,\n            nArg: ::std::os::raw::c_int,\n            zName: *const ::std::os::raw::c_char,\n            pxFunc: *mut ::std::option::Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: ::std::os::raw::c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            ppArg: *mut *mut ::std::os::raw::c_void,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xRename: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pVtab: *mut sqlite3_vtab,\n            zNew: *const ::std::os::raw::c_char,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xSavepoint: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xRelease: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xRollbackTo: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xShadowName: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,\n    >,\n    pub xIntegrity: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            zSchema: *const ::std::os::raw::c_char,\n            zTabName: *const ::std::os::raw::c_char,\n            mFlags: ::std::os::raw::c_int,\n            pzErr: *mut *mut ::std::os::raw::c_char,\n        ) -> ::std::os::raw::c_int,\n    >,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_info {\n    pub nConstraint: ::std::os::raw::c_int,\n    pub aConstraint: *mut sqlite3_index_constraint,\n    pub nOrderBy: ::std::os::raw::c_int,\n    pub aOrderBy: *mut sqlite3_index_orderby,\n    pub aConstraintUsage: *mut sqlite3_index_constraint_usage,\n    pub idxNum: ::std::os::raw::c_int,\n    pub idxStr: *mut ::std::os::raw::c_char,\n    pub needToFreeIdxStr: ::std::os::raw::c_int,\n    pub orderByConsumed: ::std::os::raw::c_int,\n    pub estimatedCost: f64,\n    pub estimatedRows: sqlite3_int64,\n    pub idxFlags: ::std::os::raw::c_int,\n    pub colUsed: sqlite3_uint64,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_constraint {\n    pub iColumn: ::std::os::raw::c_int,\n    pub op: ::std::os::raw::c_uchar,\n    pub usable: ::std::os::raw::c_uchar,\n    pub iTermOffset: ::std::os::raw::c_int,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_orderby {\n    pub iColumn: ::std::os::raw::c_int,\n    pub desc: ::std::os::raw::c_uchar,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_constraint_usage {\n    pub argvIndex: ::std::os::raw::c_int,\n    pub omit: ::std::os::raw::c_uchar,\n}\nextern \"C\" {\n    pub fn sqlite3_create_module_v2(\n        db: *mut sqlite3,\n        zName: *const ::std::os::raw::c_char,\n        p: *const sqlite3_module,\n        pClientData: *mut ::std::os::raw::c_void,\n        xDestroy: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_drop_modules(\n        db: *mut sqlite3,\n        azKeep: *mut *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_vtab {\n    pub pModule: *const sqlite3_module,\n    pub nRef: ::std::os::raw::c_int,\n    pub zErrMsg: *mut ::std::os::raw::c_char,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_vtab_cursor {\n    pub pVtab: *mut sqlite3_vtab,\n}\nextern \"C\" {\n    pub fn sqlite3_declare_vtab(\n        arg1: *mut sqlite3,\n        zSQL: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_overload_function(\n        arg1: *mut sqlite3,\n        zFuncName: *const ::std::os::raw::c_char,\n        nArg: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_blob {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_blob_open(\n        arg1: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        zTable: *const ::std::os::raw::c_char,\n        zColumn: *const ::std::os::raw::c_char,\n        iRow: sqlite3_int64,\n        flags: ::std::os::raw::c_int,\n        ppBlob: *mut *mut sqlite3_blob,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_reopen(\n        arg1: *mut sqlite3_blob,\n        arg2: sqlite3_int64,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_close(arg1: *mut sqlite3_blob) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_bytes(arg1: *mut sqlite3_blob) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_read(\n        arg1: *mut sqlite3_blob,\n        Z: *mut ::std::os::raw::c_void,\n        N: ::std::os::raw::c_int,\n        iOffset: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_write(\n        arg1: *mut sqlite3_blob,\n        z: *const ::std::os::raw::c_void,\n        n: ::std::os::raw::c_int,\n        iOffset: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vfs_find(zVfsName: *const ::std::os::raw::c_char) -> *mut sqlite3_vfs;\n}\nextern \"C\" {\n    pub fn sqlite3_vfs_register(\n        arg1: *mut sqlite3_vfs,\n        makeDflt: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vfs_unregister(arg1: *mut sqlite3_vfs) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_alloc(arg1: ::std::os::raw::c_int) -> *mut sqlite3_mutex;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_free(arg1: *mut sqlite3_mutex);\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_enter(arg1: *mut sqlite3_mutex);\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_try(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_leave(arg1: *mut sqlite3_mutex);\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_mutex_methods {\n    pub xMutexInit: ::std::option::Option<unsafe extern \"C\" fn() -> ::std::os::raw::c_int>,\n    pub xMutexEnd: ::std::option::Option<unsafe extern \"C\" fn() -> ::std::os::raw::c_int>,\n    pub xMutexAlloc: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: ::std::os::raw::c_int) -> *mut sqlite3_mutex,\n    >,\n    pub xMutexFree: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex)>,\n    pub xMutexEnter: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex)>,\n    pub xMutexTry: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int,\n    >,\n    pub xMutexLeave: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex)>,\n    pub xMutexHeld: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int,\n    >,\n    pub xMutexNotheld: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int,\n    >,\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_held(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_notheld(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_mutex(arg1: *mut sqlite3) -> *mut sqlite3_mutex;\n}\nextern \"C\" {\n    pub fn sqlite3_file_control(\n        arg1: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n        op: ::std::os::raw::c_int,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_test_control(op: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_keyword_count() -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_keyword_name(\n        arg1: ::std::os::raw::c_int,\n        arg2: *mut *const ::std::os::raw::c_char,\n        arg3: *mut ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_keyword_check(\n        arg1: *const ::std::os::raw::c_char,\n        arg2: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_str {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_str_new(arg1: *mut sqlite3) -> *mut sqlite3_str;\n}\nextern \"C\" {\n    pub fn sqlite3_str_finish(arg1: *mut sqlite3_str) -> *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_str_appendf(arg1: *mut sqlite3_str, zFormat: *const ::std::os::raw::c_char, ...);\n}\nextern \"C\" {\n    pub fn sqlite3_str_append(\n        arg1: *mut sqlite3_str,\n        zIn: *const ::std::os::raw::c_char,\n        N: ::std::os::raw::c_int,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_str_appendall(arg1: *mut sqlite3_str, zIn: *const ::std::os::raw::c_char);\n}\nextern \"C\" {\n    pub fn sqlite3_str_appendchar(\n        arg1: *mut sqlite3_str,\n        N: ::std::os::raw::c_int,\n        C: ::std::os::raw::c_char,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_str_reset(arg1: *mut sqlite3_str);\n}\nextern \"C\" {\n    pub fn sqlite3_str_errcode(arg1: *mut sqlite3_str) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_str_length(arg1: *mut sqlite3_str) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_str_value(arg1: *mut sqlite3_str) -> *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_status(\n        op: ::std::os::raw::c_int,\n        pCurrent: *mut ::std::os::raw::c_int,\n        pHighwater: *mut ::std::os::raw::c_int,\n        resetFlag: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_status64(\n        op: ::std::os::raw::c_int,\n        pCurrent: *mut sqlite3_int64,\n        pHighwater: *mut sqlite3_int64,\n        resetFlag: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_status(\n        arg1: *mut sqlite3,\n        op: ::std::os::raw::c_int,\n        pCur: *mut ::std::os::raw::c_int,\n        pHiwtr: *mut ::std::os::raw::c_int,\n        resetFlg: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_status(\n        arg1: *mut sqlite3_stmt,\n        op: ::std::os::raw::c_int,\n        resetFlg: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache_page {\n    pub pBuf: *mut ::std::os::raw::c_void,\n    pub pExtra: *mut ::std::os::raw::c_void,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache_methods2 {\n    pub iVersion: ::std::os::raw::c_int,\n    pub pArg: *mut ::std::os::raw::c_void,\n    pub xInit: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub xShutdown: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    pub xCreate: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            szPage: ::std::os::raw::c_int,\n            szExtra: ::std::os::raw::c_int,\n            bPurgeable: ::std::os::raw::c_int,\n        ) -> *mut sqlite3_pcache,\n    >,\n    pub xCachesize: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, nCachesize: ::std::os::raw::c_int),\n    >,\n    pub xPagecount: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache) -> ::std::os::raw::c_int,\n    >,\n    pub xFetch: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            key: ::std::os::raw::c_uint,\n            createFlag: ::std::os::raw::c_int,\n        ) -> *mut sqlite3_pcache_page,\n    >,\n    pub xUnpin: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut sqlite3_pcache_page,\n            discard: ::std::os::raw::c_int,\n        ),\n    >,\n    pub xRekey: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut sqlite3_pcache_page,\n            oldKey: ::std::os::raw::c_uint,\n            newKey: ::std::os::raw::c_uint,\n        ),\n    >,\n    pub xTruncate: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, iLimit: ::std::os::raw::c_uint),\n    >,\n    pub xDestroy: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache)>,\n    pub xShrink: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache)>,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache_methods {\n    pub pArg: *mut ::std::os::raw::c_void,\n    pub xInit: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,\n    >,\n    pub xShutdown: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    pub xCreate: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            szPage: ::std::os::raw::c_int,\n            bPurgeable: ::std::os::raw::c_int,\n        ) -> *mut sqlite3_pcache,\n    >,\n    pub xCachesize: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, nCachesize: ::std::os::raw::c_int),\n    >,\n    pub xPagecount: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache) -> ::std::os::raw::c_int,\n    >,\n    pub xFetch: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            key: ::std::os::raw::c_uint,\n            createFlag: ::std::os::raw::c_int,\n        ) -> *mut ::std::os::raw::c_void,\n    >,\n    pub xUnpin: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut ::std::os::raw::c_void,\n            discard: ::std::os::raw::c_int,\n        ),\n    >,\n    pub xRekey: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut ::std::os::raw::c_void,\n            oldKey: ::std::os::raw::c_uint,\n            newKey: ::std::os::raw::c_uint,\n        ),\n    >,\n    pub xTruncate: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, iLimit: ::std::os::raw::c_uint),\n    >,\n    pub xDestroy: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache)>,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_backup {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_backup_init(\n        pDest: *mut sqlite3,\n        zDestName: *const ::std::os::raw::c_char,\n        pSource: *mut sqlite3,\n        zSourceName: *const ::std::os::raw::c_char,\n    ) -> *mut sqlite3_backup;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_step(\n        p: *mut sqlite3_backup,\n        nPage: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_finish(p: *mut sqlite3_backup) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_remaining(p: *mut sqlite3_backup) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_pagecount(p: *mut sqlite3_backup) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_unlock_notify(\n        pBlocked: *mut sqlite3,\n        xNotify: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                apArg: *mut *mut ::std::os::raw::c_void,\n                nArg: ::std::os::raw::c_int,\n            ),\n        >,\n        pNotifyArg: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stricmp(\n        arg1: *const ::std::os::raw::c_char,\n        arg2: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_strnicmp(\n        arg1: *const ::std::os::raw::c_char,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_strglob(\n        zGlob: *const ::std::os::raw::c_char,\n        zStr: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_strlike(\n        zGlob: *const ::std::os::raw::c_char,\n        zStr: *const ::std::os::raw::c_char,\n        cEsc: ::std::os::raw::c_uint,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_log(\n        iErrCode: ::std::os::raw::c_int,\n        zFormat: *const ::std::os::raw::c_char,\n        ...\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_wal_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *mut sqlite3,\n                arg3: *const ::std::os::raw::c_char,\n                arg4: ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_wal_autocheckpoint(\n        db: *mut sqlite3,\n        N: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_wal_checkpoint(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_wal_checkpoint_v2(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        eMode: ::std::os::raw::c_int,\n        pnLog: *mut ::std::os::raw::c_int,\n        pnCkpt: *mut ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_config(\n        arg1: *mut sqlite3,\n        op: ::std::os::raw::c_int,\n        ...\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_on_conflict(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_nochange(arg1: *mut sqlite3_context) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_collation(\n        arg1: *mut sqlite3_index_info,\n        arg2: ::std::os::raw::c_int,\n    ) -> *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_distinct(arg1: *mut sqlite3_index_info) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_in(\n        arg1: *mut sqlite3_index_info,\n        iCons: ::std::os::raw::c_int,\n        bHandle: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_in_first(\n        pVal: *mut sqlite3_value,\n        ppOut: *mut *mut sqlite3_value,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_in_next(\n        pVal: *mut sqlite3_value,\n        ppOut: *mut *mut sqlite3_value,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_rhs_value(\n        arg1: *mut sqlite3_index_info,\n        arg2: ::std::os::raw::c_int,\n        ppVal: *mut *mut sqlite3_value,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_scanstatus(\n        pStmt: *mut sqlite3_stmt,\n        idx: ::std::os::raw::c_int,\n        iScanStatusOp: ::std::os::raw::c_int,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_scanstatus_v2(\n        pStmt: *mut sqlite3_stmt,\n        idx: ::std::os::raw::c_int,\n        iScanStatusOp: ::std::os::raw::c_int,\n        flags: ::std::os::raw::c_int,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_scanstatus_reset(arg1: *mut sqlite3_stmt);\n}\nextern \"C\" {\n    pub fn sqlite3_db_cacheflush(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_hook(\n        db: *mut sqlite3,\n        xPreUpdate: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                db: *mut sqlite3,\n                op: ::std::os::raw::c_int,\n                zDb: *const ::std::os::raw::c_char,\n                zName: *const ::std::os::raw::c_char,\n                iKey1: sqlite3_int64,\n                iKey2: sqlite3_int64,\n            ),\n        >,\n        arg1: *mut ::std::os::raw::c_void,\n    ) -> *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_old(\n        arg1: *mut sqlite3,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut *mut sqlite3_value,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_count(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_depth(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_new(\n        arg1: *mut sqlite3,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut *mut sqlite3_value,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_blobwrite(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_system_errno(arg1: *mut sqlite3) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_snapshot {\n    pub hidden: [::std::os::raw::c_uchar; 48usize],\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_get(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        ppSnapshot: *mut *mut sqlite3_snapshot,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_open(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        pSnapshot: *mut sqlite3_snapshot,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_free(arg1: *mut sqlite3_snapshot);\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_cmp(\n        p1: *mut sqlite3_snapshot,\n        p2: *mut sqlite3_snapshot,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_recover(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_serialize(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        piSize: *mut sqlite3_int64,\n        mFlags: ::std::os::raw::c_uint,\n    ) -> *mut ::std::os::raw::c_uchar;\n}\nextern \"C\" {\n    pub fn sqlite3_deserialize(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        pData: *mut ::std::os::raw::c_uchar,\n        szDb: sqlite3_int64,\n        szBuf: sqlite3_int64,\n        mFlags: ::std::os::raw::c_uint,\n    ) -> ::std::os::raw::c_int;\n}\npub type sqlite3_rtree_dbl = f64;\nextern \"C\" {\n    pub fn sqlite3_rtree_geometry_callback(\n        db: *mut sqlite3,\n        zGeom: *const ::std::os::raw::c_char,\n        xGeom: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_rtree_geometry,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut sqlite3_rtree_dbl,\n                arg4: *mut ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pContext: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_rtree_geometry {\n    pub pContext: *mut ::std::os::raw::c_void,\n    pub nParam: ::std::os::raw::c_int,\n    pub aParam: *mut sqlite3_rtree_dbl,\n    pub pUser: *mut ::std::os::raw::c_void,\n    pub xDelUser: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n}\nextern \"C\" {\n    pub fn sqlite3_rtree_query_callback(\n        db: *mut sqlite3,\n        zQueryFunc: *const ::std::os::raw::c_char,\n        xQueryFunc: ::std::option::Option<\n            unsafe extern \"C\" fn(arg1: *mut sqlite3_rtree_query_info) -> ::std::os::raw::c_int,\n        >,\n        pContext: *mut ::std::os::raw::c_void,\n        xDestructor: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_rtree_query_info {\n    pub pContext: *mut ::std::os::raw::c_void,\n    pub nParam: ::std::os::raw::c_int,\n    pub aParam: *mut sqlite3_rtree_dbl,\n    pub pUser: *mut ::std::os::raw::c_void,\n    pub xDelUser: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    pub aCoord: *mut sqlite3_rtree_dbl,\n    pub anQueue: *mut ::std::os::raw::c_uint,\n    pub nCoord: ::std::os::raw::c_int,\n    pub iLevel: ::std::os::raw::c_int,\n    pub mxLevel: ::std::os::raw::c_int,\n    pub iRowid: sqlite3_int64,\n    pub rParentScore: sqlite3_rtree_dbl,\n    pub eParentWithin: ::std::os::raw::c_int,\n    pub eWithin: ::std::os::raw::c_int,\n    pub rScore: sqlite3_rtree_dbl,\n    pub apSqlParam: *mut *mut sqlite3_value,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_session {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_changeset_iter {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3session_create(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        ppSession: *mut *mut sqlite3_session,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_delete(pSession: *mut sqlite3_session);\n}\nextern \"C\" {\n    pub fn sqlite3session_object_config(\n        arg1: *mut sqlite3_session,\n        op: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_enable(\n        pSession: *mut sqlite3_session,\n        bEnable: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_indirect(\n        pSession: *mut sqlite3_session,\n        bIndirect: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_attach(\n        pSession: *mut sqlite3_session,\n        zTab: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_table_filter(\n        pSession: *mut sqlite3_session,\n        xFilter: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pCtx: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3session_changeset(\n        pSession: *mut sqlite3_session,\n        pnChangeset: *mut ::std::os::raw::c_int,\n        ppChangeset: *mut *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_changeset_size(pSession: *mut sqlite3_session) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3session_diff(\n        pSession: *mut sqlite3_session,\n        zFromDb: *const ::std::os::raw::c_char,\n        zTbl: *const ::std::os::raw::c_char,\n        pzErrMsg: *mut *mut ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_patchset(\n        pSession: *mut sqlite3_session,\n        pnPatchset: *mut ::std::os::raw::c_int,\n        ppPatchset: *mut *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_isempty(pSession: *mut sqlite3_session) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_memory_used(pSession: *mut sqlite3_session) -> sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start(\n        pp: *mut *mut sqlite3_changeset_iter,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start_v2(\n        pp: *mut *mut sqlite3_changeset_iter,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n        flags: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_next(pIter: *mut sqlite3_changeset_iter) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_op(\n        pIter: *mut sqlite3_changeset_iter,\n        pzTab: *mut *const ::std::os::raw::c_char,\n        pnCol: *mut ::std::os::raw::c_int,\n        pOp: *mut ::std::os::raw::c_int,\n        pbIndirect: *mut ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_pk(\n        pIter: *mut sqlite3_changeset_iter,\n        pabPK: *mut *mut ::std::os::raw::c_uchar,\n        pnCol: *mut ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_old(\n        pIter: *mut sqlite3_changeset_iter,\n        iVal: ::std::os::raw::c_int,\n        ppValue: *mut *mut sqlite3_value,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_new(\n        pIter: *mut sqlite3_changeset_iter,\n        iVal: ::std::os::raw::c_int,\n        ppValue: *mut *mut sqlite3_value,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_conflict(\n        pIter: *mut sqlite3_changeset_iter,\n        iVal: ::std::os::raw::c_int,\n        ppValue: *mut *mut sqlite3_value,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_fk_conflicts(\n        pIter: *mut sqlite3_changeset_iter,\n        pnOut: *mut ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_finalize(pIter: *mut sqlite3_changeset_iter) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_invert(\n        nIn: ::std::os::raw::c_int,\n        pIn: *const ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_concat(\n        nA: ::std::os::raw::c_int,\n        pA: *mut ::std::os::raw::c_void,\n        nB: ::std::os::raw::c_int,\n        pB: *mut ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_upgrade(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        nIn: ::std::os::raw::c_int,\n        pIn: *const ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_changegroup {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_new(pp: *mut *mut sqlite3_changegroup) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_schema(\n        arg1: *mut sqlite3_changegroup,\n        arg2: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_add(\n        arg1: *mut sqlite3_changegroup,\n        nData: ::std::os::raw::c_int,\n        pData: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_add_change(\n        arg1: *mut sqlite3_changegroup,\n        arg2: *mut sqlite3_changeset_iter,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_output(\n        arg1: *mut sqlite3_changegroup,\n        pnData: *mut ::std::os::raw::c_int,\n        ppData: *mut *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_delete(arg1: *mut sqlite3_changegroup);\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply(\n        db: *mut sqlite3,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -> ::std::os::raw::c_int,\n        >,\n        xConflict: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pCtx: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply_v2(\n        db: *mut sqlite3,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -> ::std::os::raw::c_int,\n        >,\n        xConflict: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pCtx: *mut ::std::os::raw::c_void,\n        ppRebase: *mut *mut ::std::os::raw::c_void,\n        pnRebase: *mut ::std::os::raw::c_int,\n        flags: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_rebaser {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_create(ppNew: *mut *mut sqlite3_rebaser) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_configure(\n        arg1: *mut sqlite3_rebaser,\n        nRebase: ::std::os::raw::c_int,\n        pRebase: *const ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_rebase(\n        arg1: *mut sqlite3_rebaser,\n        nIn: ::std::os::raw::c_int,\n        pIn: *const ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_delete(p: *mut sqlite3_rebaser);\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply_strm(\n        db: *mut sqlite3,\n        xInput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pIn: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -> ::std::os::raw::c_int,\n        >,\n        xConflict: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pCtx: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply_v2_strm(\n        db: *mut sqlite3,\n        xInput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pIn: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -> ::std::os::raw::c_int,\n        >,\n        xConflict: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pCtx: *mut ::std::os::raw::c_void,\n        ppRebase: *mut *mut ::std::os::raw::c_void,\n        pnRebase: *mut ::std::os::raw::c_int,\n        flags: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_concat_strm(\n        xInputA: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pInA: *mut ::std::os::raw::c_void,\n        xInputB: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pInB: *mut ::std::os::raw::c_void,\n        xOutput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_invert_strm(\n        xInput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pIn: *mut ::std::os::raw::c_void,\n        xOutput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start_strm(\n        pp: *mut *mut sqlite3_changeset_iter,\n        xInput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pIn: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start_v2_strm(\n        pp: *mut *mut sqlite3_changeset_iter,\n        xInput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pIn: *mut ::std::os::raw::c_void,\n        flags: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_changeset_strm(\n        pSession: *mut sqlite3_session,\n        xOutput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_patchset_strm(\n        pSession: *mut sqlite3_session,\n        xOutput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_add_strm(\n        arg1: *mut sqlite3_changegroup,\n        xInput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pIn: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_output_strm(\n        arg1: *mut sqlite3_changegroup,\n        xOutput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_rebase_strm(\n        pRebaser: *mut sqlite3_rebaser,\n        xInput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pIn: *mut ::std::os::raw::c_void,\n        xOutput: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -> ::std::os::raw::c_int,\n        >,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_config(\n        op: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n    ) -> ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5Context {\n    _unused: [u8; 0],\n}\npub type fts5_extension_function = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        pApi: *const Fts5ExtensionApi,\n        pFts: *mut Fts5Context,\n        pCtx: *mut sqlite3_context,\n        nVal: ::std::os::raw::c_int,\n        apVal: *mut *mut sqlite3_value,\n    ),\n>;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5PhraseIter {\n    pub a: *const ::std::os::raw::c_uchar,\n    pub b: *const ::std::os::raw::c_uchar,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5ExtensionApi {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xUserData: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut Fts5Context) -> *mut ::std::os::raw::c_void,\n    >,\n    pub xColumnCount: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut Fts5Context) -> ::std::os::raw::c_int,\n    >,\n    pub xRowCount: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pnRow: *mut sqlite3_int64,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xColumnTotalSize: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iCol: ::std::os::raw::c_int,\n            pnToken: *mut sqlite3_int64,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xTokenize: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pText: *const ::std::os::raw::c_char,\n            nText: ::std::os::raw::c_int,\n            pCtx: *mut ::std::os::raw::c_void,\n            xToken: ::std::option::Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut ::std::os::raw::c_void,\n                    arg2: ::std::os::raw::c_int,\n                    arg3: *const ::std::os::raw::c_char,\n                    arg4: ::std::os::raw::c_int,\n                    arg5: ::std::os::raw::c_int,\n                    arg6: ::std::os::raw::c_int,\n                ) -> ::std::os::raw::c_int,\n            >,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xPhraseCount: ::std::option::Option<\n        unsafe extern \"C\" fn(arg1: *mut Fts5Context) -> ::std::os::raw::c_int,\n    >,\n    pub xPhraseSize: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xInstCount: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pnInst: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xInst: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iIdx: ::std::os::raw::c_int,\n            piPhrase: *mut ::std::os::raw::c_int,\n            piCol: *mut ::std::os::raw::c_int,\n            piOff: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xRowid:\n        ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut Fts5Context) -> sqlite3_int64>,\n    pub xColumnText: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iCol: ::std::os::raw::c_int,\n            pz: *mut *const ::std::os::raw::c_char,\n            pn: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xColumnSize: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iCol: ::std::os::raw::c_int,\n            pnToken: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xQueryPhrase: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            pUserData: *mut ::std::os::raw::c_void,\n            arg2: ::std::option::Option<\n                unsafe extern \"C\" fn(\n                    arg1: *const Fts5ExtensionApi,\n                    arg2: *mut Fts5Context,\n                    arg3: *mut ::std::os::raw::c_void,\n                ) -> ::std::os::raw::c_int,\n            >,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xSetAuxdata: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pAux: *mut ::std::os::raw::c_void,\n            xDelete: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xGetAuxdata: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            bClear: ::std::os::raw::c_int,\n        ) -> *mut ::std::os::raw::c_void,\n    >,\n    pub xPhraseFirst: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            arg2: *mut Fts5PhraseIter,\n            arg3: *mut ::std::os::raw::c_int,\n            arg4: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xPhraseNext: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            arg2: *mut Fts5PhraseIter,\n            piCol: *mut ::std::os::raw::c_int,\n            piOff: *mut ::std::os::raw::c_int,\n        ),\n    >,\n    pub xPhraseFirstColumn: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            arg2: *mut Fts5PhraseIter,\n            arg3: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xPhraseNextColumn: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            arg2: *mut Fts5PhraseIter,\n            piCol: *mut ::std::os::raw::c_int,\n        ),\n    >,\n    pub xQueryToken: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            iToken: ::std::os::raw::c_int,\n            ppToken: *mut *const ::std::os::raw::c_char,\n            pnToken: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xInstToken: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iIdx: ::std::os::raw::c_int,\n            iToken: ::std::os::raw::c_int,\n            arg2: *mut *const ::std::os::raw::c_char,\n            arg3: *mut ::std::os::raw::c_int,\n        ) -> ::std::os::raw::c_int,\n    >,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5Tokenizer {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct fts5_tokenizer {\n    pub xCreate: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            azArg: *mut *const ::std::os::raw::c_char,\n            nArg: ::std::os::raw::c_int,\n            ppOut: *mut *mut Fts5Tokenizer,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xDelete: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut Fts5Tokenizer)>,\n    pub xTokenize: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Tokenizer,\n            pCtx: *mut ::std::os::raw::c_void,\n            flags: ::std::os::raw::c_int,\n            pText: *const ::std::os::raw::c_char,\n            nText: ::std::os::raw::c_int,\n            xToken: ::std::option::Option<\n                unsafe extern \"C\" fn(\n                    pCtx: *mut ::std::os::raw::c_void,\n                    tflags: ::std::os::raw::c_int,\n                    pToken: *const ::std::os::raw::c_char,\n                    nToken: ::std::os::raw::c_int,\n                    iStart: ::std::os::raw::c_int,\n                    iEnd: ::std::os::raw::c_int,\n                ) -> ::std::os::raw::c_int,\n            >,\n        ) -> ::std::os::raw::c_int,\n    >,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct fts5_api {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xCreateTokenizer: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pApi: *mut fts5_api,\n            zName: *const ::std::os::raw::c_char,\n            pUserData: *mut ::std::os::raw::c_void,\n            pTokenizer: *mut fts5_tokenizer,\n            xDestroy: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xFindTokenizer: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pApi: *mut fts5_api,\n            zName: *const ::std::os::raw::c_char,\n            ppUserData: *mut *mut ::std::os::raw::c_void,\n            pTokenizer: *mut fts5_tokenizer,\n        ) -> ::std::os::raw::c_int,\n    >,\n    pub xCreateFunction: ::std::option::Option<\n        unsafe extern \"C\" fn(\n            pApi: *mut fts5_api,\n            zName: *const ::std::os::raw::c_char,\n            pUserData: *mut ::std::os::raw::c_void,\n            xFunction: fts5_extension_function,\n            xDestroy: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n        ) -> ::std::os::raw::c_int,\n    >,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","target-cov","debug","build","serde-f7d0cdb76999b6da","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private226 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private226 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","target-cov","debug","build","serde_core-b3e3c7d16bccdbb0","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private226 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","target-cov","debug","build","typenum-8bcb70e47c3b8750","out","tests.rs"],"content":"\nuse typenum::*;\nuse core::ops::*;\nuse core::cmp::Ordering;\n\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU0 = <<A as BitOr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitOrU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU0 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitXorU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU0 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU0 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU0 = <<A as Add<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0AddU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU0 = <<A as Max<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MaxU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU0 = <<A as Gcd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0GcdU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Sub_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0SubU0 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0SubU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_0() {\n    type A = UTerm;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU0 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU1 = <<A as BitOr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0BitOrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU1 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0BitXorU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU1 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU1 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU1 = <<A as Add<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0AddU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU1 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU1 = <<A as Pow<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PowU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU1 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU1 = <<A as Max<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0MaxU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU1 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0DivU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PartialDivU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU2 = <<A as BitOr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U0BitOrU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU2 = <<A as BitXor<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U0BitXorU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU2 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU2 = <<A as Add<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U0AddU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU2 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU2 = <<A as Pow<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PowU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU2 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U0MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U0GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU2 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0DivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PartialDivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU3 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U0BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU3 = <<A as BitXor<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U0BitXorU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU3 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU3 = <<A as Add<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U0AddU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU3 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU3 = <<A as Pow<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PowU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU3 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U0MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU3 = <<A as Gcd<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U0GcdU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU3 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0RemU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU3 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PartialDivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU4 = <<A as BitOr<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U0BitOrU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU4 = <<A as BitXor<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U0BitXorU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU4 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU4 = <<A as Add<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U0AddU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU4 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU4 = <<A as Pow<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PowU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU4 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U0MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU4 = <<A as Gcd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U0GcdU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU4 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0RemU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU4 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PartialDivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU5 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U0BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU5 = <<A as BitXor<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U0BitXorU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU5 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU5 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U0AddU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU5 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU5 = <<A as Pow<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PowU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU5 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U0MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU5 = <<A as Gcd<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U0GcdU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU5 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0RemU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU5 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PartialDivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU0 = <<A as BitOr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitOrU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU0 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitXorU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU0 = <<A as Shl<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1ShlU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU0 = <<A as Shr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1ShrU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU0 = <<A as Add<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1AddU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU0 = <<A as Max<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MaxU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU0 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU0 = <<A as Sub<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1SubU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU1 = <<A as BitOr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitOrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU1 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1BitXorU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU1 = <<A as Shl<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U1ShlU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU1 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1ShrU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU1 = <<A as Add<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U1AddU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU1 = <<A as Mul<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MulU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU1 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU1 = <<A as Max<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MaxU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU1 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1SubU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU1 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1DivU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_PartialDiv_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PartialDivU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU1 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU2 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1BitOrU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU2 = <<A as BitXor<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1BitXorU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU2 = <<A as Shl<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U1ShlU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU2 = <<A as Add<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1AddU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU2 = <<A as Mul<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U1MulU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU2 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU2 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MinU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U1MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU2 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1DivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU3 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitAndU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU3 = <<A as BitXor<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U1BitXorU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU3 = <<A as Shl<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U1ShlU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU3 = <<A as Add<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U1AddU3 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU3 = <<A as Mul<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1MulU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU3 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU3 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MinU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU3 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1RemU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU4 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1BitOrU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU4 = <<A as BitXor<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1BitXorU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU4 = <<A as Shl<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U1ShlU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU4 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1AddU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU4 = <<A as Mul<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U1MulU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU4 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU4 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MinU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U1MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU4 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1RemU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU5 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitAndU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU5 = <<A as BitXor<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U1BitXorU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU5 = <<A as Shl<B>>::Output as Same<U32>>::Output;\n\n    assert_eq!(<U1ShlU5 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU5 = <<A as Add<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U1AddU5 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU5 = <<A as Mul<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1MulU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU5 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU5 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MinU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU5 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1RemU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU0 = <<A as BitOr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2BitOrU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU0 = <<A as BitXor<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2BitXorU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU0 = <<A as Shl<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2ShlU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU0 = <<A as Shr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2ShrU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU0 = <<A as Add<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2AddU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU0 = <<A as Max<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MaxU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU0 = <<A as Gcd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2GcdU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU0 = <<A as Sub<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2SubU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU1 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U2BitOrU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU1 = <<A as BitXor<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U2BitXorU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU1 = <<A as Shl<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U2ShlU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU1 = <<A as Shr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2ShrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU1 = <<A as Add<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U2AddU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU1 = <<A as Mul<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MulU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU1 = <<A as Pow<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2PowU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU1 = <<A as Max<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MaxU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU1 = <<A as Sub<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2SubU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU1 = <<A as Div<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2DivU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2PartialDivU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU2 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2BitAndU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU2 = <<A as BitOr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2BitOrU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU2 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2BitXorU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU2 = <<A as Shl<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U2ShlU2 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU2 = <<A as Add<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U2AddU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU2 = <<A as Mul<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U2MulU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU2 = <<A as Pow<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U2PowU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU2 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2SubU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU2 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2DivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2PartialDivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU2 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU3 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2BitAndU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U2BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU3 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2BitXorU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU3 = <<A as Shl<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U2ShlU3 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU3 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U2AddU3 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU3 = <<A as Mul<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U2MulU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU3 = <<A as Pow<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U2PowU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU3 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MinU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U2MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU3 = <<A as Rem<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2RemU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU4 = <<A as BitOr<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U2BitOrU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU4 = <<A as BitXor<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U2BitXorU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU4 = <<A as Shl<B>>::Output as Same<U32>>::Output;\n\n    assert_eq!(<U2ShlU4 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU4 = <<A as Add<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U2AddU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU4 = <<A as Mul<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U2MulU4 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU4 = <<A as Pow<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U2PowU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU4 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MinU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U2MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU4 = <<A as Gcd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2GcdU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU4 = <<A as Rem<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2RemU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU5 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2BitAndU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU5 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U2BitOrU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU5 = <<A as BitXor<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U2BitXorU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU5 = <<A as Shl<B>>::Output as Same<U64>>::Output;\n\n    assert_eq!(<U2ShlU5 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU5 = <<A as Add<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U2AddU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU5 = <<A as Mul<B>>::Output as Same<U10>>::Output;\n\n    assert_eq!(<U2MulU5 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU5 = <<A as Pow<B>>::Output as Same<U32>>::Output;\n\n    assert_eq!(<U2PowU5 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU5 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MinU5 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U2MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU5 = <<A as Rem<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2RemU5 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU0 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitOrU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU0 = <<A as BitXor<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitXorU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU0 = <<A as Shl<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3ShlU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU0 = <<A as Shr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3ShrU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU0 = <<A as Add<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3AddU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU0 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MaxU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU0 = <<A as Gcd<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3GcdU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU0 = <<A as Sub<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3SubU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU1 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitOrU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU1 = <<A as BitXor<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U3BitXorU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU1 = <<A as Shl<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U3ShlU1 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU1 = <<A as Shr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3ShrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU1 = <<A as Add<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U3AddU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU1 = <<A as Mul<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MulU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU1 = <<A as Pow<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3PowU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU1 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MaxU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU1 = <<A as Sub<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U3SubU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU1 = <<A as Div<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3DivU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3PartialDivU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU2 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U3BitAndU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU2 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitOrU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU2 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3BitXorU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU2 = <<A as Shl<B>>::Output as Same<U12>>::Output;\n\n    assert_eq!(<U3ShlU2 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU2 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U3AddU2 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU2 = <<A as Mul<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U3MulU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU2 = <<A as Pow<B>>::Output as Same<U9>>::Output;\n\n    assert_eq!(<U3PowU2 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U3MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU2 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MaxU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU2 = <<A as Sub<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3SubU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU2 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3DivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU3 = <<A as BitAnd<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitAndU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU3 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3BitXorU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U24 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU3 = <<A as Shl<B>>::Output as Same<U24>>::Output;\n\n    assert_eq!(<U3ShlU3 as Unsigned>::to_u64(), <U24 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU3 = <<A as Add<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U3AddU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU3 = <<A as Mul<B>>::Output as Same<U9>>::Output;\n\n    assert_eq!(<U3MulU3 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U27 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU3 = <<A as Pow<B>>::Output as Same<U27>>::Output;\n\n    assert_eq!(<U3PowU3 as Unsigned>::to_u64(), <U27 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU3 = <<A as Gcd<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3GcdU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU3 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3SubU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU3 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3RemU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU3 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3PartialDivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU3 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU4 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U3BitOrU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU4 = <<A as BitXor<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U3BitXorU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U48 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU4 = <<A as Shl<B>>::Output as Same<U48>>::Output;\n\n    assert_eq!(<U3ShlU4 as Unsigned>::to_u64(), <U48 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU4 = <<A as Add<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U3AddU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU4 = <<A as Mul<B>>::Output as Same<U12>>::Output;\n\n    assert_eq!(<U3MulU4 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U81 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU4 = <<A as Pow<B>>::Output as Same<U81>>::Output;\n\n    assert_eq!(<U3PowU4 as Unsigned>::to_u64(), <U81 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU4 = <<A as Min<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MinU4 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U3MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU4 = <<A as Rem<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3RemU4 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU5 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3BitAndU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU5 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U3BitOrU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU5 = <<A as BitXor<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U3BitXorU5 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U96 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU5 = <<A as Shl<B>>::Output as Same<U96>>::Output;\n\n    assert_eq!(<U3ShlU5 as Unsigned>::to_u64(), <U96 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU5 = <<A as Add<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U3AddU5 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U15 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU5 = <<A as Mul<B>>::Output as Same<U15>>::Output;\n\n    assert_eq!(<U3MulU5 as Unsigned>::to_u64(), <U15 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U243 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU5 = <<A as Pow<B>>::Output as Same<U243>>::Output;\n\n    assert_eq!(<U3PowU5 as Unsigned>::to_u64(), <U243 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU5 = <<A as Min<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MinU5 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U3MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU5 = <<A as Rem<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3RemU5 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU0 = <<A as BitOr<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4BitOrU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU0 = <<A as BitXor<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4BitXorU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU0 = <<A as Shl<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4ShlU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU0 = <<A as Shr<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4ShrU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU0 = <<A as Add<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4AddU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU0 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MaxU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU0 = <<A as Gcd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4GcdU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU0 = <<A as Sub<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4SubU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU1 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U4BitOrU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU1 = <<A as BitXor<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U4BitXorU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU1 = <<A as Shl<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U4ShlU1 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU1 = <<A as Shr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4ShrU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU1 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U4AddU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU1 = <<A as Mul<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MulU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU1 = <<A as Pow<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4PowU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU1 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MaxU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU1 = <<A as Sub<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U4SubU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU1 = <<A as Div<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4DivU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4PartialDivU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU2 = <<A as BitOr<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U4BitOrU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU2 = <<A as BitXor<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U4BitXorU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU2 = <<A as Shl<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U4ShlU2 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU2 = <<A as Shr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4ShrU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU2 = <<A as Add<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U4AddU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU2 = <<A as Mul<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U4MulU2 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU2 = <<A as Pow<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U4PowU2 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU2 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MaxU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU2 = <<A as Sub<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4SubU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU2 = <<A as Div<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4DivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4PartialDivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU3 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4BitAndU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU3 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U4BitOrU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU3 = <<A as BitXor<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U4BitXorU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU3 = <<A as Shl<B>>::Output as Same<U32>>::Output;\n\n    assert_eq!(<U4ShlU3 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU3 = <<A as Add<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U4AddU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU3 = <<A as Mul<B>>::Output as Same<U12>>::Output;\n\n    assert_eq!(<U4MulU3 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU3 = <<A as Pow<B>>::Output as Same<U64>>::Output;\n\n    assert_eq!(<U4PowU3 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U4MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU3 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MaxU3 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU3 = <<A as Sub<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4SubU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU3 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4RemU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU4 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4BitAndU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU4 = <<A as BitOr<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4BitOrU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU4 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4BitXorU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU4 = <<A as Shl<B>>::Output as Same<U64>>::Output;\n\n    assert_eq!(<U4ShlU4 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU4 = <<A as Add<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U4AddU4 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU4 = <<A as Mul<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U4MulU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U256 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU4 = <<A as Pow<B>>::Output as Same<U256>>::Output;\n\n    assert_eq!(<U4PowU4 as Unsigned>::to_u64(), <U256 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU4 = <<A as Min<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MinU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU4 = <<A as Gcd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4GcdU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU4 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4SubU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU4 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4DivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU4 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4RemU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU4 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4PartialDivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU4 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU5 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4BitAndU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U4BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU5 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4BitXorU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U128 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU5 = <<A as Shl<B>>::Output as Same<U128>>::Output;\n\n    assert_eq!(<U4ShlU5 as Unsigned>::to_u64(), <U128 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU5 = <<A as Add<B>>::Output as Same<U9>>::Output;\n\n    assert_eq!(<U4AddU5 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU5 = <<A as Mul<B>>::Output as Same<U20>>::Output;\n\n    assert_eq!(<U4MulU5 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1024 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU5 = <<A as Pow<B>>::Output as Same<U1024>>::Output;\n\n    assert_eq!(<U4PowU5 as Unsigned>::to_u64(), <U1024 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU5 = <<A as Min<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MinU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U4MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU5 = <<A as Rem<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4RemU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU0 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitOrU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU0 = <<A as BitXor<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitXorU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU0 = <<A as Shl<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5ShlU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU0 = <<A as Shr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5ShrU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU0 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5AddU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU0 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU0 = <<A as Gcd<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5GcdU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU0 = <<A as Sub<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5SubU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU1 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitOrU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU1 = <<A as BitXor<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U5BitXorU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU1 = <<A as Shl<B>>::Output as Same<U10>>::Output;\n\n    assert_eq!(<U5ShlU1 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU1 = <<A as Shr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U5ShrU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU1 = <<A as Add<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U5AddU1 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU1 = <<A as Mul<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MulU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU1 = <<A as Pow<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5PowU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU1 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU1 = <<A as Sub<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U5SubU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU1 = <<A as Div<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5DivU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5PartialDivU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU2 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U5BitOrU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU2 = <<A as BitXor<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U5BitXorU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU2 = <<A as Shl<B>>::Output as Same<U20>>::Output;\n\n    assert_eq!(<U5ShlU2 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU2 = <<A as Shr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5ShrU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU2 = <<A as Add<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U5AddU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU2 = <<A as Mul<B>>::Output as Same<U10>>::Output;\n\n    assert_eq!(<U5MulU2 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U25 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU2 = <<A as Pow<B>>::Output as Same<U25>>::Output;\n\n    assert_eq!(<U5PowU2 as Unsigned>::to_u64(), <U25 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U5MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU2 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU2 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU2 = <<A as Sub<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U5SubU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU2 = <<A as Div<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U5DivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU3 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5BitAndU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU3 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U5BitOrU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU3 = <<A as BitXor<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U5BitXorU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U40 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU3 = <<A as Shl<B>>::Output as Same<U40>>::Output;\n\n    assert_eq!(<U5ShlU3 as Unsigned>::to_u64(), <U40 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU3 = <<A as Add<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U5AddU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U15 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU3 = <<A as Mul<B>>::Output as Same<U15>>::Output;\n\n    assert_eq!(<U5MulU3 as Unsigned>::to_u64(), <U15 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U125 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU3 = <<A as Pow<B>>::Output as Same<U125>>::Output;\n\n    assert_eq!(<U5PowU3 as Unsigned>::to_u64(), <U125 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U5MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU3 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU3 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU3 = <<A as Sub<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U5SubU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU3 = <<A as Rem<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U5RemU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU4 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U5BitAndU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU4 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitOrU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU4 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5BitXorU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U80 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU4 = <<A as Shl<B>>::Output as Same<U80>>::Output;\n\n    assert_eq!(<U5ShlU4 as Unsigned>::to_u64(), <U80 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU4 = <<A as Add<B>>::Output as Same<U9>>::Output;\n\n    assert_eq!(<U5AddU4 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU4 = <<A as Mul<B>>::Output as Same<U20>>::Output;\n\n    assert_eq!(<U5MulU4 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U625 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU4 = <<A as Pow<B>>::Output as Same<U625>>::Output;\n\n    assert_eq!(<U5PowU4 as Unsigned>::to_u64(), <U625 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU4 = <<A as Min<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U5MinU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU4 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU4 = <<A as Sub<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5SubU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU4 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5DivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU4 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5RemU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU5 = <<A as BitAnd<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitAndU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU5 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5BitXorU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U160 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU5 = <<A as Shl<B>>::Output as Same<U160>>::Output;\n\n    assert_eq!(<U5ShlU5 as Unsigned>::to_u64(), <U160 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU5 = <<A as Add<B>>::Output as Same<U10>>::Output;\n\n    assert_eq!(<U5AddU5 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U25 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU5 = <<A as Mul<B>>::Output as Same<U25>>::Output;\n\n    assert_eq!(<U5MulU5 as Unsigned>::to_u64(), <U25 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U3125 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU5 = <<A as Pow<B>>::Output as Same<U3125>>::Output;\n\n    assert_eq!(<U5PowU5 as Unsigned>::to_u64(), <U3125 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU5 = <<A as Min<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MinU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU5 = <<A as Gcd<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5GcdU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU5 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5SubU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU5 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5DivU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU5 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5RemU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU5 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5PartialDivU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU5 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN5 = <<A as Add<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<N5AddN5 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN5 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5SubN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN5 = <<A as Mul<B>>::Output as Same<P25>>::Output;\n\n    assert_eq!(<N5MulN5 as Integer>::to_i64(), <P25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN5 = <<A as Max<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MaxN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN5 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5DivN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5PartialDivN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpN5 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN4 = <<A as Add<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<N5AddN4 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN4 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5SubN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN4 = <<A as Mul<B>>::Output as Same<P20>>::Output;\n\n    assert_eq!(<N5MulN4 as Integer>::to_i64(), <P20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN4 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinN4 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN4 = <<A as Max<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N5MaxN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN4 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5DivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN4 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5RemN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpN4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN3 = <<A as Add<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N5AddN3 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN3 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5SubN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN3 = <<A as Mul<B>>::Output as Same<P15>>::Output;\n\n    assert_eq!(<N5MulN3 as Integer>::to_i64(), <P15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN3 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinN3 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N5MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN3 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5RemN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpN3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN2 = <<A as Add<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N5AddN2 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN2 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N5SubN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN2 = <<A as Mul<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<N5MulN2 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN2 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinN2 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN2 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N5DivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpN2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN1 = <<A as Add<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N5AddN1 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN1 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N5SubN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN1 = <<A as Mul<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5MulN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN1 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN1 = <<A as Div<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5DivN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5PartialDivN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpN1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5Add_0 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5Add_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5Sub_0 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5Sub_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5Min_0 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5Min_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5Gcd_0 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5Gcd_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5Cmp_0 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP1 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N5AddP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP1 = <<A as Sub<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N5SubP1 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP1 = <<A as Mul<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MulP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP1 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP1 = <<A as Div<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5DivP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5PartialDivP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP1 = <<A as Pow<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5PowP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP2 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N5AddP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP2 = <<A as Sub<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N5SubP2 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP2 = <<A as Mul<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<N5MulP2 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP2 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinP2 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N5MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP2 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5DivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP2 = <<A as Pow<B>>::Output as Same<P25>>::Output;\n\n    assert_eq!(<N5PowP2 as Integer>::to_i64(), <P25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP3 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5AddP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP3 = <<A as Sub<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N5SubP3 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP3 = <<A as Mul<B>>::Output as Same<N15>>::Output;\n\n    assert_eq!(<N5MulP3 as Integer>::to_i64(), <N15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP3 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinP3 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N5MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP3 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5RemP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N125 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP3 = <<A as Pow<B>>::Output as Same<N125>>::Output;\n\n    assert_eq!(<N5PowP3 as Integer>::to_i64(), <N125 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP4 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5AddP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP4 = <<A as Sub<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<N5SubP4 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP4 = <<A as Mul<B>>::Output as Same<N20>>::Output;\n\n    assert_eq!(<N5MulP4 as Integer>::to_i64(), <N20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP4 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinP4 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N5MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP4 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5DivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP4 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5RemP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P625 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP4 = <<A as Pow<B>>::Output as Same<P625>>::Output;\n\n    assert_eq!(<N5PowP4 as Integer>::to_i64(), <P625 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP5 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5AddP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP5 = <<A as Sub<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<N5SubP5 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N25 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP5 = <<A as Mul<B>>::Output as Same<N25>>::Output;\n\n    assert_eq!(<N5MulP5 as Integer>::to_i64(), <N25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP5 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5DivP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5PartialDivP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3125 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP5 = <<A as Pow<B>>::Output as Same<N3125>>::Output;\n\n    assert_eq!(<N5PowP5 as Integer>::to_i64(), <N3125 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN5 = <<A as Add<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<N4AddN5 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN5 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4SubN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN5 = <<A as Mul<B>>::Output as Same<P20>>::Output;\n\n    assert_eq!(<N4MulN5 as Integer>::to_i64(), <P20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N4MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN5 = <<A as Max<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MaxN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN5 = <<A as Rem<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4RemN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN4 = <<A as Add<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N4AddN4 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN4 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4SubN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN4 = <<A as Mul<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<N4MulN4 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN4 = <<A as Max<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MaxN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN4 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4DivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4PartialDivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpN4 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN3 = <<A as Add<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N4AddN3 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN3 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4SubN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN3 = <<A as Mul<B>>::Output as Same<P12>>::Output;\n\n    assert_eq!(<N4MulN3 as Integer>::to_i64(), <P12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN3 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinN3 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N4MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN3 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4RemN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpN3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN2 = <<A as Add<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N4AddN2 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN2 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N4SubN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN2 = <<A as Mul<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<N4MulN2 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN2 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N4MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N4GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN2 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N4DivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N4PartialDivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpN2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN1 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N4AddN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN1 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N4SubN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN1 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4MulN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN1 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN1 = <<A as Div<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4DivN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4PartialDivN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpN1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4Add_0 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4Add_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4Sub_0 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4Sub_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4Min_0 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4Min_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4Gcd_0 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4Gcd_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4Cmp_0 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP1 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N4AddP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP1 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N4SubP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP1 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MulP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP1 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP1 = <<A as Div<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4DivP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4PartialDivP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP1 = <<A as Pow<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4PowP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP2 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N4AddP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP2 = <<A as Sub<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N4SubP2 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP2 = <<A as Mul<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N4MulP2 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP2 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N4MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N4GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP2 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N4DivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N4PartialDivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP2 = <<A as Pow<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<N4PowP2 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP3 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4AddP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP3 = <<A as Sub<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N4SubP3 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP3 = <<A as Mul<B>>::Output as Same<N12>>::Output;\n\n    assert_eq!(<N4MulP3 as Integer>::to_i64(), <N12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP3 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinP3 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N4MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP3 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4RemP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N64 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP3 = <<A as Pow<B>>::Output as Same<N64>>::Output;\n\n    assert_eq!(<N4PowP3 as Integer>::to_i64(), <N64 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP4 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4AddP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP4 = <<A as Sub<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N4SubP4 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N16 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP4 = <<A as Mul<B>>::Output as Same<N16>>::Output;\n\n    assert_eq!(<N4MulP4 as Integer>::to_i64(), <N16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP4 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4DivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4PartialDivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P256 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP4 = <<A as Pow<B>>::Output as Same<P256>>::Output;\n\n    assert_eq!(<N4PowP4 as Integer>::to_i64(), <P256 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP5 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4AddP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP5 = <<A as Sub<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<N4SubP5 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP5 = <<A as Mul<B>>::Output as Same<N20>>::Output;\n\n    assert_eq!(<N4MulP5 as Integer>::to_i64(), <N20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP5 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N4MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP5 = <<A as Rem<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4RemP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1024 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP5 = <<A as Pow<B>>::Output as Same<N1024>>::Output;\n\n    assert_eq!(<N4PowP5 as Integer>::to_i64(), <N1024 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN5 = <<A as Add<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N3AddN5 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN5 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N3SubN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN5 = <<A as Mul<B>>::Output as Same<P15>>::Output;\n\n    assert_eq!(<N3MulN5 as Integer>::to_i64(), <P15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N3MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN5 = <<A as Max<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MaxN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN5 = <<A as Rem<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3RemN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN4 = <<A as Add<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N3AddN4 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN4 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3SubN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN4 = <<A as Mul<B>>::Output as Same<P12>>::Output;\n\n    assert_eq!(<N3MulN4 as Integer>::to_i64(), <P12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N3MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN4 = <<A as Max<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MaxN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN4 = <<A as Rem<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3RemN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN3 = <<A as Add<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N3AddN3 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN3 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3SubN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN3 = <<A as Mul<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<N3MulN3 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3PartialDivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpN3 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN2 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N3AddN2 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN2 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3SubN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN2 = <<A as Mul<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<N3MulN2 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN2 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N3MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN2 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3DivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpN2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN1 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N3AddN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN1 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N3SubN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN1 = <<A as Mul<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3MulN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN1 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN1 = <<A as Div<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3DivN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3PartialDivN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpN1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3Add_0 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3Add_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3Sub_0 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3Sub_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3Min_0 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3Min_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3Gcd_0 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3Gcd_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3Cmp_0 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP1 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N3AddP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP1 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N3SubP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP1 = <<A as Mul<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MulP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP1 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP1 = <<A as Div<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3DivP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3PartialDivP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP1 = <<A as Pow<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3PowP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP2 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3AddP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP2 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N3SubP2 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP2 = <<A as Mul<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N3MulP2 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP2 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N3MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP2 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3DivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP2 = <<A as Pow<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<N3PowP2 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP3 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3AddP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP3 = <<A as Sub<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N3SubP3 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP3 = <<A as Mul<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<N3MulP3 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3PartialDivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N27 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP3 = <<A as Pow<B>>::Output as Same<N27>>::Output;\n\n    assert_eq!(<N3PowP3 as Integer>::to_i64(), <N27 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP4 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3AddP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP4 = <<A as Sub<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N3SubP4 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP4 = <<A as Mul<B>>::Output as Same<N12>>::Output;\n\n    assert_eq!(<N3MulP4 as Integer>::to_i64(), <N12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP4 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N3MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP4 = <<A as Rem<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3RemP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P81 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP4 = <<A as Pow<B>>::Output as Same<P81>>::Output;\n\n    assert_eq!(<N3PowP4 as Integer>::to_i64(), <P81 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP5 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N3AddP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP5 = <<A as Sub<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N3SubP5 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP5 = <<A as Mul<B>>::Output as Same<N15>>::Output;\n\n    assert_eq!(<N3MulP5 as Integer>::to_i64(), <N15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP5 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N3MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP5 = <<A as Rem<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3RemP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N243 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP5 = <<A as Pow<B>>::Output as Same<N243>>::Output;\n\n    assert_eq!(<N3PowP5 as Integer>::to_i64(), <N243 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN5 = <<A as Add<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N2AddN5 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN5 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N2SubN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN5 = <<A as Mul<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<N2MulN5 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N2MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN5 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MaxN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN5 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN4 = <<A as Add<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N2AddN4 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN4 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2SubN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN4 = <<A as Mul<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<N2MulN4 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N2MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN4 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MaxN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2GcdN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN4 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN3 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N2AddN3 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN3 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2SubN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN3 = <<A as Mul<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<N2MulN3 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N2MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN3 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MaxN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN3 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN2 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N2AddN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN2 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2SubN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN2 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N2MulN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN2 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2DivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2PartialDivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpN2 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN1 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N2AddN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN1 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N2SubN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN1 = <<A as Mul<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2MulN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN1 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N2MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN1 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2DivN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2PartialDivN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpN1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2Add_0 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2Add_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2Sub_0 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2Sub_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2Min_0 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2Min_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2Gcd_0 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2Gcd_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2Cmp_0 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP1 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N2AddP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP1 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N2SubP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP1 = <<A as Mul<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MulP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP1 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP1 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2DivP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2PartialDivP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP1 = <<A as Pow<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2PowP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP2 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2AddP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP2 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N2SubP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP2 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N2MulP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP2 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N2DivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N2PartialDivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP2 = <<A as Pow<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N2PowP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP3 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2AddP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP3 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N2SubP3 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP3 = <<A as Mul<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N2MulP3 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP3 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N2MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP3 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP3 = <<A as Pow<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N2PowP3 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP4 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2AddP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP4 = <<A as Sub<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N2SubP4 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP4 = <<A as Mul<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N2MulP4 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP4 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N2MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2GcdP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP4 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP4 = <<A as Pow<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<N2PowP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP5 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N2AddP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP5 = <<A as Sub<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N2SubP5 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP5 = <<A as Mul<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<N2MulP5 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP5 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N2MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP5 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N32 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP5 = <<A as Pow<B>>::Output as Same<N32>>::Output;\n\n    assert_eq!(<N2PowP5 as Integer>::to_i64(), <N32 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN5 = <<A as Add<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N1AddN5 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN5 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N1SubN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN5 = <<A as Mul<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N1MulN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N1MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN5 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MaxN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN5 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN5 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN4 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N1AddN4 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN4 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N1SubN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN4 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N1MulN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N1MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN4 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MaxN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN4 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN4 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1PowN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN3 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N1AddN3 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN3 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N1SubN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN3 = <<A as Mul<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N1MulN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N1MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN3 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MaxN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN3 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN3 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN2 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N1AddN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN2 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1SubN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN2 = <<A as Mul<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N1MulN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N1MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN2 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MaxN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN2 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1PowN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN1 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N1AddN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN1 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1SubN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN1 = <<A as Mul<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1MulN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN1 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1DivN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1PartialDivN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN1 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpN1 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1Add_0 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1Add_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1Sub_0 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1Sub_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1Min_0 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1Min_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1Gcd_0 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1Gcd_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1Cmp_0 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP1 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1AddP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP1 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N1SubP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP1 = <<A as Mul<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MulP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP1 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1DivP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PartialDivP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP1 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP2 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1AddP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP2 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N1SubP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP2 = <<A as Mul<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N1MulP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP2 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N1MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP2 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1PowP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP3 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N1AddP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP3 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N1SubP3 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP3 = <<A as Mul<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N1MulP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP3 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N1MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP3 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP3 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP4 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N1AddP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP4 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N1SubP4 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP4 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N1MulP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP4 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N1MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP4 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP4 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1PowP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP5 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N1AddP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP5 = <<A as Sub<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N1SubP5 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP5 = <<A as Mul<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N1MulP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP5 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N1MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP5 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP5 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN5 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<_0AddN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN5 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<_0SubN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN5 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<_0MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN5 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MaxN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<_0GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN4 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<_0AddN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN4 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<_0SubN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN4 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<_0MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN4 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MaxN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<_0GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN3 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<_0AddN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN3 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<_0SubN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN3 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<_0MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN3 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MaxN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<_0GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN2 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<_0AddN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN2 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<_0SubN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN2 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<_0MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN2 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MaxN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<_0GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN1 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<_0AddN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN1 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0SubN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN1 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<_0MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN1 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MaxN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN1 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Add_0 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Add_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Sub_0 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Sub_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Gcd_0 = <<A as Gcd<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Gcd_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow__0() {\n    type A = Z0;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp__0() {\n    type A = Z0;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0Cmp_0 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP1 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0AddP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP1 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<_0SubP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP1 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP1 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MinP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP1 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP1 = <<A as Pow<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PowP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP2 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<_0AddP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP2 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<_0SubP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP2 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP2 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MinP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<_0MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<_0GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP2 = <<A as Pow<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PowP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP3 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<_0AddP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP3 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<_0SubP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP3 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP3 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MinP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<_0MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<_0GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP3 = <<A as Pow<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PowP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP4 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<_0AddP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP4 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<_0SubP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP4 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP4 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MinP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<_0MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<_0GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP4 = <<A as Pow<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PowP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP5 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<_0AddP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP5 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<_0SubP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP5 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP5 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MinP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<_0MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<_0GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP5 = <<A as Pow<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PowP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN5 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P1AddN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN5 = <<A as Sub<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P1SubN5 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN5 = <<A as Mul<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P1MulN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P1MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN5 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN5 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN5 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN4 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P1AddN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN4 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P1SubN4 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN4 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P1MulN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P1MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN4 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN4 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN4 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN3 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P1AddN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN3 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P1SubN3 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN3 = <<A as Mul<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P1MulN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P1MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN3 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN3 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN3 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN2 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1AddN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN2 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P1SubN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN2 = <<A as Mul<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P1MulN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P1MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN2 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN2 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN1 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1AddN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN1 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P1SubN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN1 = <<A as Mul<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1MulN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN1 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1DivN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1PartialDivN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN1 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1Add_0 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1Add_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1Sub_0 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1Sub_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1Max_0 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1Max_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1Gcd_0 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1Gcd_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1Cmp_0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP1 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P1AddP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP1 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1SubP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP1 = <<A as Mul<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MulP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP1 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1DivP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PartialDivP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP1 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpP1 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP2 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P1AddP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP2 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1SubP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP2 = <<A as Mul<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P1MulP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP2 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MinP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P1MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP2 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP3 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P1AddP3 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP3 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P1SubP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP3 = <<A as Mul<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P1MulP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP3 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MinP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P1MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP3 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP3 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP4 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P1AddP4 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP4 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P1SubP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP4 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P1MulP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP4 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MinP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P1MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP4 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP4 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP5 = <<A as Add<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P1AddP5 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP5 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P1SubP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP5 = <<A as Mul<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P1MulP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP5 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MinP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P1MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP5 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP5 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN5 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P2AddN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN5 = <<A as Sub<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P2SubN5 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN5 = <<A as Mul<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<P2MulN5 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P2MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN5 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN5 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN4 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2AddN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN4 = <<A as Sub<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P2SubN4 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN4 = <<A as Mul<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<P2MulN4 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P2MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN4 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2GcdN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN4 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN3 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P2AddN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN3 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P2SubN3 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN3 = <<A as Mul<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<P2MulN3 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P2MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN3 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN3 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN2 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2AddN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN2 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P2SubN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN2 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P2MulN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN2 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P2DivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P2PartialDivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN1 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2AddN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN1 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P2SubN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN1 = <<A as Mul<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2MulN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P2MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN1 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN1 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2DivN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2PartialDivN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2Add_0 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2Add_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2Sub_0 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2Sub_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2Max_0 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2Max_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2Gcd_0 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2Gcd_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2Cmp_0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP1 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P2AddP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP1 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2SubP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP1 = <<A as Mul<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MulP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP1 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP1 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2DivP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2PartialDivP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP1 = <<A as Pow<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2PowP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpP1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP2 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P2AddP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP2 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2SubP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP2 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P2MulP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP2 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2DivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2PartialDivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP2 = <<A as Pow<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P2PowP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpP2 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP3 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P2AddP3 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP3 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P2SubP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP3 = <<A as Mul<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P2MulP3 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP3 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MinP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P2MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP3 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP3 = <<A as Pow<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P2PowP3 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP4 = <<A as Add<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P2AddP4 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP4 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2SubP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP4 = <<A as Mul<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P2MulP4 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP4 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MinP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P2MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2GcdP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP4 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP4 = <<A as Pow<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<P2PowP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP5 = <<A as Add<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P2AddP5 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP5 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P2SubP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP5 = <<A as Mul<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<P2MulP5 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP5 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MinP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P2MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP5 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P32 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP5 = <<A as Pow<B>>::Output as Same<P32>>::Output;\n\n    assert_eq!(<P2PowP5 as Integer>::to_i64(), <P32 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN5 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P3AddN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN5 = <<A as Sub<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P3SubN5 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN5 = <<A as Mul<B>>::Output as Same<N15>>::Output;\n\n    assert_eq!(<P3MulN5 as Integer>::to_i64(), <N15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P3MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN5 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN5 = <<A as Rem<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3RemN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN4 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3AddN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN4 = <<A as Sub<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P3SubN4 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN4 = <<A as Mul<B>>::Output as Same<N12>>::Output;\n\n    assert_eq!(<P3MulN4 as Integer>::to_i64(), <N12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P3MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN4 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN4 = <<A as Rem<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3RemN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN3 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3AddN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN3 = <<A as Sub<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P3SubN3 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN3 = <<A as Mul<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<P3MulN3 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P3MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3PartialDivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN2 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3AddN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN2 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P3SubN2 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN2 = <<A as Mul<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<P3MulN2 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P3MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN2 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN2 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3DivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN1 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P3AddN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN1 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P3SubN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN1 = <<A as Mul<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P3MulN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN1 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN1 = <<A as Div<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P3DivN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P3PartialDivN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3Add_0 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3Add_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3Sub_0 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3Sub_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3Max_0 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3Max_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3Gcd_0 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3Gcd_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3Cmp_0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP1 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P3AddP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP1 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P3SubP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP1 = <<A as Mul<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MulP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP1 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP1 = <<A as Div<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3DivP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3PartialDivP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP1 = <<A as Pow<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3PowP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpP1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP2 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P3AddP2 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP2 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3SubP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP2 = <<A as Mul<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P3MulP2 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P3MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP2 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP2 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3DivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP2 = <<A as Pow<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P3PowP2 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpP2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP3 = <<A as Add<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P3AddP3 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP3 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3SubP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP3 = <<A as Mul<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P3MulP3 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3PartialDivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P27 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP3 = <<A as Pow<B>>::Output as Same<P27>>::Output;\n\n    assert_eq!(<P3PowP3 as Integer>::to_i64(), <P27 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpP3 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP4 = <<A as Add<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P3AddP4 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP4 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3SubP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP4 = <<A as Mul<B>>::Output as Same<P12>>::Output;\n\n    assert_eq!(<P3MulP4 as Integer>::to_i64(), <P12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP4 = <<A as Min<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MinP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P3MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP4 = <<A as Rem<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3RemP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P81 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP4 = <<A as Pow<B>>::Output as Same<P81>>::Output;\n\n    assert_eq!(<P3PowP4 as Integer>::to_i64(), <P81 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP5 = <<A as Add<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P3AddP5 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP5 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P3SubP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP5 = <<A as Mul<B>>::Output as Same<P15>>::Output;\n\n    assert_eq!(<P3MulP5 as Integer>::to_i64(), <P15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP5 = <<A as Min<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MinP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P3MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP5 = <<A as Rem<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3RemP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P243 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP5 = <<A as Pow<B>>::Output as Same<P243>>::Output;\n\n    assert_eq!(<P3PowP5 as Integer>::to_i64(), <P243 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN5 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4AddN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN5 = <<A as Sub<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P4SubN5 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN5 = <<A as Mul<B>>::Output as Same<N20>>::Output;\n\n    assert_eq!(<P4MulN5 as Integer>::to_i64(), <N20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P4MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN5 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN5 = <<A as Rem<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4RemN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN4 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4AddN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN4 = <<A as Sub<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P4SubN4 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N16 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN4 = <<A as Mul<B>>::Output as Same<N16>>::Output;\n\n    assert_eq!(<P4MulN4 as Integer>::to_i64(), <N16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P4MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN4 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4DivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4PartialDivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN3 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4AddN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN3 = <<A as Sub<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P4SubN3 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN3 = <<A as Mul<B>>::Output as Same<N12>>::Output;\n\n    assert_eq!(<P4MulN3 as Integer>::to_i64(), <N12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P4MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN3 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxN3 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN3 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4RemN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN2 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4AddN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN2 = <<A as Sub<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P4SubN2 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN2 = <<A as Mul<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<P4MulN2 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P4MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN2 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN2 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P4DivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P4PartialDivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN1 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P4AddN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN1 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P4SubN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN1 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P4MulN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN1 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN1 = <<A as Div<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P4DivN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P4PartialDivN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4Add_0 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4Add_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4Sub_0 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4Sub_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4Max_0 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4Max_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4Gcd_0 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4Gcd_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4Cmp_0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP1 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P4AddP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP1 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P4SubP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP1 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MulP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP1 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP1 = <<A as Div<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4DivP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4PartialDivP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP1 = <<A as Pow<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4PowP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpP1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP2 = <<A as Add<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P4AddP2 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP2 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4SubP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP2 = <<A as Mul<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P4MulP2 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP2 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP2 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4DivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4PartialDivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP2 = <<A as Pow<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<P4PowP2 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpP2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP3 = <<A as Add<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P4AddP3 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP3 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4SubP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP3 = <<A as Mul<B>>::Output as Same<P12>>::Output;\n\n    assert_eq!(<P4MulP3 as Integer>::to_i64(), <P12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P4MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP3 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxP3 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP3 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4RemP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P64 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP3 = <<A as Pow<B>>::Output as Same<P64>>::Output;\n\n    assert_eq!(<P4PowP3 as Integer>::to_i64(), <P64 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpP3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP4 = <<A as Add<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P4AddP4 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP4 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4SubP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP4 = <<A as Mul<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<P4MulP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP4 = <<A as Min<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MinP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP4 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4DivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4PartialDivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P256 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP4 = <<A as Pow<B>>::Output as Same<P256>>::Output;\n\n    assert_eq!(<P4PowP4 as Integer>::to_i64(), <P256 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpP4 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP5 = <<A as Add<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P4AddP5 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP5 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4SubP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP5 = <<A as Mul<B>>::Output as Same<P20>>::Output;\n\n    assert_eq!(<P4MulP5 as Integer>::to_i64(), <P20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP5 = <<A as Min<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MinP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P4MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP5 = <<A as Rem<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4RemP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1024 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP5 = <<A as Pow<B>>::Output as Same<P1024>>::Output;\n\n    assert_eq!(<P4PowP5 as Integer>::to_i64(), <P1024 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN5 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5AddN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN5 = <<A as Sub<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<P5SubN5 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N25 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN5 = <<A as Mul<B>>::Output as Same<N25>>::Output;\n\n    assert_eq!(<P5MulN5 as Integer>::to_i64(), <N25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P5MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN5 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P5DivN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P5PartialDivN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN4 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5AddN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN4 = <<A as Sub<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P5SubN4 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN4 = <<A as Mul<B>>::Output as Same<N20>>::Output;\n\n    assert_eq!(<P5MulN4 as Integer>::to_i64(), <N20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P5MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN4 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxN4 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN4 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P5DivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN4 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5RemN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN3 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5AddN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN3 = <<A as Sub<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P5SubN3 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN3 = <<A as Mul<B>>::Output as Same<N15>>::Output;\n\n    assert_eq!(<P5MulN3 as Integer>::to_i64(), <N15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P5MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN3 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxN3 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P5DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN3 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5RemN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN2 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P5AddN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN2 = <<A as Sub<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P5SubN2 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN2 = <<A as Mul<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<P5MulN2 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P5MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN2 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxN2 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN2 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P5DivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN1 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P5AddN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN1 = <<A as Sub<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P5SubN1 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN1 = <<A as Mul<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P5MulN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P5MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN1 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN1 = <<A as Div<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P5DivN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P5PartialDivN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5Add_0 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5Add_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5Sub_0 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5Sub_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5Max_0 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5Max_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5Gcd_0 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5Gcd_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5Cmp_0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP1 = <<A as Add<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P5AddP1 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP1 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P5SubP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP1 = <<A as Mul<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MulP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP1 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP1 = <<A as Div<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5DivP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5PartialDivP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP1 = <<A as Pow<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5PowP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpP1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP2 = <<A as Add<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P5AddP2 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP2 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P5SubP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP2 = <<A as Mul<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<P5MulP2 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP2 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxP2 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP2 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5DivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP2 = <<A as Pow<B>>::Output as Same<P25>>::Output;\n\n    assert_eq!(<P5PowP2 as Integer>::to_i64(), <P25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpP2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP3 = <<A as Add<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P5AddP3 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP3 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5SubP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP3 = <<A as Mul<B>>::Output as Same<P15>>::Output;\n\n    assert_eq!(<P5MulP3 as Integer>::to_i64(), <P15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P5MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP3 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxP3 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP3 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5RemP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P125 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP3 = <<A as Pow<B>>::Output as Same<P125>>::Output;\n\n    assert_eq!(<P5PowP3 as Integer>::to_i64(), <P125 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpP3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP4 = <<A as Add<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P5AddP4 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP4 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5SubP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP4 = <<A as Mul<B>>::Output as Same<P20>>::Output;\n\n    assert_eq!(<P5MulP4 as Integer>::to_i64(), <P20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP4 = <<A as Min<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P5MinP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP4 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxP4 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP4 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5DivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP4 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5RemP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P625 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP4 = <<A as Pow<B>>::Output as Same<P625>>::Output;\n\n    assert_eq!(<P5PowP4 as Integer>::to_i64(), <P625 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpP4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP5 = <<A as Add<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<P5AddP5 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP5 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5SubP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP5 = <<A as Mul<B>>::Output as Same<P25>>::Output;\n\n    assert_eq!(<P5MulP5 as Integer>::to_i64(), <P25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP5 = <<A as Min<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MinP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP5 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5DivP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5PartialDivP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3125 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP5 = <<A as Pow<B>>::Output as Same<P3125>>::Output;\n\n    assert_eq!(<P5PowP5 as Integer>::to_i64(), <P3125 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpP5 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Neg() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegN5 = <<A as Neg>::Output as Same<P5>>::Output;\n    assert_eq!(<NegN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Abs() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsN5 = <<A as Abs>::Output as Same<P5>>::Output;\n    assert_eq!(<AbsN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Neg() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type NegN4 = <<A as Neg>::Output as Same<P4>>::Output;\n    assert_eq!(<NegN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Abs() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsN4 = <<A as Abs>::Output as Same<P4>>::Output;\n    assert_eq!(<AbsN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Neg() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegN3 = <<A as Neg>::Output as Same<P3>>::Output;\n    assert_eq!(<NegN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Abs() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsN3 = <<A as Abs>::Output as Same<P3>>::Output;\n    assert_eq!(<AbsN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Neg() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type NegN2 = <<A as Neg>::Output as Same<P2>>::Output;\n    assert_eq!(<NegN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Abs() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsN2 = <<A as Abs>::Output as Same<P2>>::Output;\n    assert_eq!(<AbsN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Neg() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegN1 = <<A as Neg>::Output as Same<P1>>::Output;\n    assert_eq!(<NegN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Abs() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsN1 = <<A as Abs>::Output as Same<P1>>::Output;\n    assert_eq!(<AbsN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Neg() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Neg_0 = <<A as Neg>::Output as Same<_0>>::Output;\n    assert_eq!(<Neg_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Abs() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Abs_0 = <<A as Abs>::Output as Same<_0>>::Output;\n    assert_eq!(<Abs_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Neg() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegP1 = <<A as Neg>::Output as Same<N1>>::Output;\n    assert_eq!(<NegP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Abs() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsP1 = <<A as Abs>::Output as Same<P1>>::Output;\n    assert_eq!(<AbsP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Neg() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type NegP2 = <<A as Neg>::Output as Same<N2>>::Output;\n    assert_eq!(<NegP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Abs() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsP2 = <<A as Abs>::Output as Same<P2>>::Output;\n    assert_eq!(<AbsP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Neg() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegP3 = <<A as Neg>::Output as Same<N3>>::Output;\n    assert_eq!(<NegP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Abs() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsP3 = <<A as Abs>::Output as Same<P3>>::Output;\n    assert_eq!(<AbsP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Neg() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type NegP4 = <<A as Neg>::Output as Same<N4>>::Output;\n    assert_eq!(<NegP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Abs() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsP4 = <<A as Abs>::Output as Same<P4>>::Output;\n    assert_eq!(<AbsP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Neg() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegP5 = <<A as Neg>::Output as Same<N5>>::Output;\n    assert_eq!(<NegP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Abs() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsP5 = <<A as Abs>::Output as Same<P5>>::Output;\n    assert_eq!(<AbsP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","tests","basic_coverage.rs"],"content":"//! Basic coverage tests for Rust engine components\n//! These tests provide basic coverage measurement without complex protobuf interactions\n\nuse workspace_qdrant_daemon::config::*;\nuse workspace_qdrant_daemon::error::*;\n\n#[test]\nfn test_daemon_config_creation() {\n    let config = DaemonConfig::default();\n    assert_eq!(config.server.host, \"127.0.0.1\");\n    assert_eq!(config.server.port, 50051);\n    assert_eq!(config.database.max_connections, 10);\n    assert_eq!(config.qdrant.url, \"http://localhost:6333\");\n}\n\n#[test]\nfn test_server_config_creation() {\n    let config = ServerConfig {\n        host: \"0.0.0.0\".to_string(),\n        port: 8080,\n        max_connections: 500,\n        connection_timeout_secs: 60,\n        request_timeout_secs: 300,\n        enable_tls: true,\n    };\n\n    assert_eq!(config.host, \"0.0.0.0\");\n    assert_eq!(config.port, 8080);\n    assert!(config.enable_tls);\n}\n\n#[test]\nfn test_database_config_creation() {\n    let config = DatabaseConfig {\n        sqlite_path: \"/tmp/test.db\".to_string(),\n        max_connections: 20,\n        connection_timeout_secs: 45,\n        enable_wal: false,\n    };\n\n    assert_eq!(config.sqlite_path, \"/tmp/test.db\");\n    assert_eq!(config.max_connections, 20);\n    assert!(!config.enable_wal);\n}\n\n#[test]\nfn test_qdrant_config_creation() {\n    let collection_config = CollectionConfig {\n        vector_size: 768,\n        distance_metric: \"Euclidean\".to_string(),\n        enable_indexing: false,\n        replication_factor: 2,\n        shard_number: 3,\n    };\n\n    let config = QdrantConfig {\n        url: \"http://remote:6333\".to_string(),\n        api_key: Some(\"test-key\".to_string()),\n        timeout_secs: 60,\n        max_retries: 5,\n        default_collection: collection_config,\n    };\n\n    assert_eq!(config.url, \"http://remote:6333\");\n    assert_eq!(config.api_key, Some(\"test-key\".to_string()));\n    assert_eq!(config.max_retries, 5);\n    assert_eq!(config.default_collection.vector_size, 768);\n}\n\n#[test]\nfn test_processing_config_creation() {\n    let config = ProcessingConfig {\n        max_concurrent_tasks: 8,\n        default_chunk_size: 2000,\n        default_chunk_overlap: 400,\n        max_file_size_bytes: 200_000_000,\n        supported_extensions: vec![\"rs\".to_string(), \"py\".to_string()],\n        enable_lsp: false,\n        lsp_timeout_secs: 20,\n    };\n\n    assert_eq!(config.max_concurrent_tasks, 8);\n    assert_eq!(config.default_chunk_size, 2000);\n    assert!(!config.enable_lsp);\n    assert!(config.supported_extensions.contains(&\"rs\".to_string()));\n}\n\n#[test]\nfn test_file_watcher_config_creation() {\n    let config = FileWatcherConfig {\n        enabled: true,\n        debounce_ms: 1000,\n        max_watched_dirs: 50,\n        ignore_patterns: vec![\"*.log\".to_string(), \"target/**\".to_string()],\n        recursive: false,\n    };\n\n    assert!(config.enabled);\n    assert_eq!(config.debounce_ms, 1000);\n    assert!(!config.recursive);\n    assert!(config.ignore_patterns.contains(&\"*.log\".to_string()));\n}\n\n#[test]\nfn test_metrics_config_creation() {\n    let config = MetricsConfig {\n        enabled: false,\n        collection_interval_secs: 120,\n        retention_days: 60,\n        enable_prometheus: false,\n        prometheus_port: 9091,\n    };\n\n    assert!(!config.enabled);\n    assert_eq!(config.collection_interval_secs, 120);\n    assert_eq!(config.retention_days, 60);\n    assert!(!config.enable_prometheus);\n}\n\n#[test]\nfn test_logging_config_creation() {\n    let config = LoggingConfig {\n        level: \"debug\".to_string(),\n        file_path: Some(\"/custom/log.log\".to_string()),\n        json_format: true,\n        max_file_size_mb: 200,\n        max_files: 10,\n    };\n\n    assert_eq!(config.level, \"debug\");\n    assert_eq!(config.file_path, Some(\"/custom/log.log\".to_string()));\n    assert!(config.json_format);\n    assert_eq!(config.max_file_size_mb, 200);\n}\n\n#[test]\nfn test_config_validation_valid() {\n    let config = DaemonConfig::default();\n    assert!(config.validate().is_ok());\n}\n\n#[test]\nfn test_config_validation_invalid_port() {\n    let mut config = DaemonConfig::default();\n    config.server.port = 0;\n\n    let result = config.validate();\n    assert!(result.is_err());\n\n    match result {\n        Err(DaemonError::Config(_)) => {\n            // Expected error type\n        },\n        _ => panic!(\"Expected Config error for invalid port\"),\n    }\n}\n\n#[test]\nfn test_config_validation_empty_qdrant_url() {\n    let mut config = DaemonConfig::default();\n    config.qdrant.url = String::new();\n\n    let result = config.validate();\n    assert!(result.is_err());\n\n    match result {\n        Err(DaemonError::Config(_)) => {\n            // Expected error type\n        },\n        _ => panic!(\"Expected Config error for empty Qdrant URL\"),\n    }\n}\n\n#[test]\nfn test_config_validation_empty_database_path() {\n    let mut config = DaemonConfig::default();\n    config.database.sqlite_path = String::new();\n\n    let result = config.validate();\n    assert!(result.is_err());\n\n    match result {\n        Err(DaemonError::Config(_)) => {\n            // Expected error type\n        },\n        _ => panic!(\"Expected Config error for empty database path\"),\n    }\n}\n\n#[test]\nfn test_config_validation_zero_chunk_size() {\n    let mut config = DaemonConfig::default();\n    config.processing.default_chunk_size = 0;\n\n    let result = config.validate();\n    assert!(result.is_err());\n\n    match result {\n        Err(DaemonError::Config(_)) => {\n            // Expected error type\n        },\n        _ => panic!(\"Expected Config error for zero chunk size\"),\n    }\n}\n\n#[test]\nfn test_config_clone_debug() {\n    let config = DaemonConfig::default();\n    let cloned = config.clone();\n\n    assert_eq!(config.server.host, cloned.server.host);\n    assert_eq!(config.qdrant.url, cloned.qdrant.url);\n\n    // Test debug format\n    let debug_str = format!(\"{:?}\", config);\n    assert!(debug_str.contains(\"DaemonConfig\"));\n    assert!(debug_str.contains(\"ServerConfig\"));\n}\n\n#[test]\nfn test_collection_config_standalone() {\n    let collection_config = CollectionConfig {\n        vector_size: 768,\n        distance_metric: \"Dot\".to_string(),\n        enable_indexing: false,\n        replication_factor: 3,\n        shard_number: 2,\n    };\n\n    let debug_str = format!(\"{:?}\", collection_config);\n    assert!(debug_str.contains(\"CollectionConfig\"));\n    assert!(debug_str.contains(\"768\"));\n    assert!(debug_str.contains(\"Dot\"));\n\n    let cloned = collection_config.clone();\n    assert_eq!(collection_config.vector_size, cloned.vector_size);\n    assert_eq!(collection_config.distance_metric, cloned.distance_metric);\n}\n\n#[test]\nfn test_error_types() {\n    // Test that we can create different error types\n    let config_error = DaemonError::Config(\n        config::ConfigError::Message(\"Test config error\".to_string())\n    );\n\n    let io_error = DaemonError::Io(std::io::Error::new(\n        std::io::ErrorKind::NotFound,\n        \"Test IO error\"\n    ));\n\n    // Test that they can be formatted\n    let config_msg = format!(\"{}\", config_error);\n    assert!(config_msg.contains(\"Configuration error\"));\n\n    let io_msg = format!(\"{}\", io_error);\n    assert!(io_msg.contains(\"IO error\"));\n}\n\n#[test]\nfn test_config_structs_are_send_sync() {\n    fn assert_send_sync<T: Send + Sync>() {}\n\n    assert_send_sync::<DaemonConfig>();\n    assert_send_sync::<ServerConfig>();\n    assert_send_sync::<DatabaseConfig>();\n    assert_send_sync::<QdrantConfig>();\n    assert_send_sync::<CollectionConfig>();\n    assert_send_sync::<ProcessingConfig>();\n    assert_send_sync::<FileWatcherConfig>();\n    assert_send_sync::<MetricsConfig>();\n    assert_send_sync::<LoggingConfig>();\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","tests","daemon_coverage.rs"],"content":"//! Additional test coverage for daemon modules\n//! Targeting daemon/core.rs, daemon/processing.rs, daemon/state.rs, daemon/watcher.rs\n\nuse workspace_qdrant_daemon::config::*;\nuse workspace_qdrant_daemon::daemon::core::*;\nuse workspace_qdrant_daemon::daemon::processing::*;\nuse workspace_qdrant_daemon::daemon::state::*;\nuse workspace_qdrant_daemon::daemon::watcher::*;\nuse std::sync::Arc;\nuse tempfile::TempDir;\nuse sqlx::Row;\n\n// ================================\n// DAEMON CORE TESTS\n// ================================\n\n#[test]\nfn test_daemon_core_initialization() {\n    let core = DaemonCore::new();\n    assert_eq!(std::mem::size_of::<DaemonCore>(), 0);\n\n    // Test debug representation\n    let debug_str = format!(\"{:?}\", core);\n    assert!(debug_str.contains(\"DaemonCore\"));\n}\n\n#[test]\nfn test_system_info_creation() {\n    let info = SystemInfo {\n        cpu_count: 8,\n        memory_total: 16 * 1024 * 1024 * 1024, // 16GB\n        hostname: \"test-machine\".to_string(),\n    };\n\n    assert_eq!(info.cpu_count, 8);\n    assert_eq!(info.memory_total, 16 * 1024 * 1024 * 1024);\n    assert_eq!(info.hostname, \"test-machine\");\n\n    // Test clone implementation\n    let cloned = info.clone();\n    assert_eq!(info.cpu_count, cloned.cpu_count);\n    assert_eq!(info.memory_total, cloned.memory_total);\n    assert_eq!(info.hostname, cloned.hostname);\n}\n\n#[test]\nfn test_system_info_debug_formatting() {\n    let info = SystemInfo {\n        cpu_count: 4,\n        memory_total: 8_000_000_000,\n        hostname: \"debug-host\".to_string(),\n    };\n\n    let debug_str = format!(\"{:?}\", info);\n    assert!(debug_str.contains(\"SystemInfo\"));\n    assert!(debug_str.contains(\"4\"));\n    assert!(debug_str.contains(\"8000000000\"));\n    assert!(debug_str.contains(\"debug-host\"));\n}\n\n#[test]\nfn test_get_system_info_success() {\n    let result = DaemonCore::get_system_info();\n    assert!(result.is_ok());\n\n    let info = result.unwrap();\n    assert!(info.cpu_count > 0);\n    assert!(info.memory_total > 0);\n    assert!(!info.hostname.is_empty());\n}\n\n// Note: get_total_memory is private, so we can't test it directly\n\n#[test]\nfn test_daemon_core_multiple_instances() {\n    let core1 = DaemonCore::new();\n    let core2 = DaemonCore::new();\n\n    // Both should be identical (unit struct)\n    assert_eq!(std::mem::size_of_val(&core1), std::mem::size_of_val(&core2));\n    assert_eq!(std::mem::size_of_val(&core1), 0);\n}\n\n#[test]\nfn test_system_info_send_sync() {\n    fn assert_send<T: Send>() {}\n    fn assert_sync<T: Sync>() {}\n\n    assert_send::<SystemInfo>();\n    assert_sync::<SystemInfo>();\n}\n\n// ================================\n// DOCUMENT PROCESSOR TESTS\n// ================================\n\nfn create_test_configs() -> (ProcessingConfig, QdrantConfig) {\n    let processing_config = ProcessingConfig {\n        max_concurrent_tasks: 3,\n        default_chunk_size: 1500,\n        default_chunk_overlap: 300,\n        max_file_size_bytes: 2 * 1024 * 1024,\n        supported_extensions: vec![\"txt\".to_string(), \"md\".to_string(), \"rs\".to_string()],\n        enable_lsp: true,\n        lsp_timeout_secs: 15,\n    };\n\n    let qdrant_config = QdrantConfig {\n        url: \"http://localhost:6333\".to_string(),\n        api_key: Some(\"test-api-key\".to_string()),\n        timeout_secs: 45,\n        max_retries: 5,\n        default_collection: CollectionConfig {\n            vector_size: 512,\n            distance_metric: \"Cosine\".to_string(),\n            enable_indexing: true,\n            replication_factor: 2,\n            shard_number: 2,\n        },\n    };\n\n    (processing_config, qdrant_config)\n}\n\nasync fn create_test_processor() -> Arc<DocumentProcessor> {\n    let (processing_config, qdrant_config) = create_test_configs();\n    Arc::new(DocumentProcessor::new(&processing_config, &qdrant_config).await.unwrap())\n}\n\n#[tokio::test]\nasync fn test_document_processor_creation() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let result = DocumentProcessor::new(&processing_config, &qdrant_config).await;\n\n    assert!(result.is_ok());\n    let processor = result.unwrap();\n\n    assert_eq!(processor.config().max_concurrent_tasks, 3);\n    assert_eq!(processor.config().default_chunk_size, 1500);\n    assert_eq!(processor.config().default_chunk_overlap, 300);\n    assert_eq!(processor.config().max_file_size_bytes, 2 * 1024 * 1024);\n    assert!(processor.config().enable_lsp);\n    assert_eq!(processor.config().lsp_timeout_secs, 15);\n    assert_eq!(processor.config().supported_extensions.len(), 3);\n    assert!(processor.config().supported_extensions.contains(&\"rs\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_document_processor_config_values() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(&processing_config, &qdrant_config).await.unwrap();\n\n    // Test that config values match what we set\n    assert_eq!(processor.config().max_concurrent_tasks, 3);\n    assert_eq!(processor.config().default_chunk_size, 1500);\n    assert_eq!(processor.config().default_chunk_overlap, 300);\n    assert_eq!(processor.config().max_file_size_bytes, 2 * 1024 * 1024);\n    assert!(processor.config().enable_lsp);\n    assert_eq!(processor.config().lsp_timeout_secs, 15);\n    assert!(processor.config().supported_extensions.contains(&\"txt\".to_string()));\n    assert!(processor.config().supported_extensions.contains(&\"rs\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_document_processor_debug_format() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(&processing_config, &qdrant_config).await.unwrap();\n\n    let debug_str = format!(\"{:?}\", processor);\n    assert!(debug_str.contains(\"DocumentProcessor\"));\n    assert!(!debug_str.is_empty());\n}\n\n#[tokio::test]\nasync fn test_document_processing_single_file() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(&processing_config, &qdrant_config).await.unwrap();\n\n    let result = processor.process_document(\"test_file.txt\").await;\n    assert!(result.is_ok());\n\n    let document_id = result.unwrap();\n    assert_eq!(document_id.len(), 36); // UUID v4 length\n    assert!(document_id.contains('-'));\n}\n\n#[tokio::test]\nasync fn test_document_processing_different_extensions() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(&processing_config, &qdrant_config).await.unwrap();\n\n    let test_files = vec![\n        \"document.txt\",\n        \"readme.md\",\n        \"script.rs\",\n        \"config.yaml\",\n        \"data.json\",\n    ];\n\n    for file in test_files {\n        let result = processor.process_document(file).await;\n        assert!(result.is_ok(), \"Failed to process file: {}\", file);\n\n        let document_id = result.unwrap();\n        assert_eq!(document_id.len(), 36);\n    }\n}\n\n#[tokio::test]\nasync fn test_document_processor_config_access() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(&processing_config, &qdrant_config).await.unwrap();\n\n    let config = processor.config();\n    assert_eq!(config.max_concurrent_tasks, 3);\n    assert!(config.supported_extensions.contains(&\"txt\".to_string()));\n    assert!(config.enable_lsp);\n}\n\n// ================================\n// DAEMON STATE TESTS\n// ================================\n\nfn create_test_database_config() -> DatabaseConfig {\n    DatabaseConfig {\n        sqlite_path: \"sqlite::memory:\".to_string(),\n        max_connections: 3,\n        connection_timeout_secs: 10,\n        enable_wal: false,\n    }\n}\n\n#[tokio::test]\nasync fn test_daemon_state_creation() {\n    let config = create_test_database_config();\n    let result = DaemonState::new(&config).await;\n\n    assert!(result.is_ok());\n    let state = result.unwrap();\n\n    // Test debug formatting\n    let debug_str = format!(\"{:?}\", state);\n    assert!(debug_str.contains(\"DaemonState\"));\n}\n\n#[tokio::test]\nasync fn test_daemon_state_pool_access() {\n    let config = create_test_database_config();\n    let state = DaemonState::new(&config).await.unwrap();\n\n    let pool = state.pool();\n    assert!(!pool.is_closed());\n}\n\n#[tokio::test]\nasync fn test_daemon_state_health_check() {\n    let config = create_test_database_config();\n    let state = DaemonState::new(&config).await.unwrap();\n\n    let result = state.health_check().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_daemon_state_invalid_path() {\n    let config = DatabaseConfig {\n        sqlite_path: \"/invalid/nonexistent/path/test.db\".to_string(),\n        max_connections: 1,\n        connection_timeout_secs: 5,\n        enable_wal: false,\n    };\n\n    let result = DaemonState::new(&config).await;\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_daemon_state_migrations() {\n    let config = create_test_database_config();\n    let state = DaemonState::new(&config).await.unwrap();\n\n    // Check that tables were created\n    let tables_query = \"SELECT name FROM sqlite_master WHERE type='table'\";\n    let rows = sqlx::query(tables_query)\n        .fetch_all(state.pool())\n        .await\n        .unwrap();\n\n    let table_names: Vec<String> = rows.iter()\n        .map(|row| row.get::<String, _>(\"name\"))\n        .collect();\n\n    assert!(table_names.contains(&\"projects\".to_string()));\n    assert!(table_names.contains(&\"collections\".to_string()));\n    assert!(table_names.contains(&\"processing_operations\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_daemon_state_multiple_instances() {\n    let config1 = create_test_database_config();\n    let config2 = create_test_database_config();\n\n    let state1 = DaemonState::new(&config1).await.unwrap();\n    let state2 = DaemonState::new(&config2).await.unwrap();\n\n    // Both should work independently\n    state1.health_check().await.unwrap();\n    state2.health_check().await.unwrap();\n}\n\n// ================================\n// FILE WATCHER TESTS\n// ================================\n\nfn create_test_watcher_config(enabled: bool) -> FileWatcherConfig {\n    FileWatcherConfig {\n        enabled,\n        debounce_ms: 500,\n        max_watched_dirs: 20,\n        ignore_patterns: vec![\n            \"*.tmp\".to_string(),\n            \"*.log\".to_string(),\n            \"target/**\".to_string(),\n            \".git/**\".to_string(),\n        ],\n        recursive: true,\n    }\n}\n\n#[tokio::test]\nasync fn test_file_watcher_creation_enabled() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n\n    let result = FileWatcher::new(&config, processor).await;\n    assert!(result.is_ok());\n\n    let _watcher = result.unwrap();\n    // Note: config fields are private, so we just test creation success\n}\n\n#[tokio::test]\nasync fn test_file_watcher_creation_disabled() {\n    let config = create_test_watcher_config(false);\n    let processor = create_test_processor().await;\n\n    let result = FileWatcher::new(&config, processor).await;\n    assert!(result.is_ok());\n\n    let _watcher = result.unwrap();\n    // Note: config fields are private, so we just test creation success\n}\n\n#[tokio::test]\nasync fn test_file_watcher_start_enabled() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n    let result = watcher.start().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_file_watcher_start_disabled() {\n    let config = create_test_watcher_config(false);\n    let processor = create_test_processor().await;\n    let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n    let result = watcher.start().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_file_watcher_stop() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n    watcher.start().await.unwrap();\n    let result = watcher.stop().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_file_watcher_directory_operations() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n    let temp_dir = TempDir::new().unwrap();\n\n    // Test watching directory\n    let result = watcher.watch_directory(temp_dir.path()).await;\n    assert!(result.is_ok());\n\n    // Test unwatching directory\n    let result = watcher.unwatch_directory(temp_dir.path()).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_file_watcher_watch_string_path() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let mut watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n    let result = watcher.watch_directory(\"/tmp\").await;\n    assert!(result.is_ok());\n\n    let result = watcher.unwatch_directory(\"/tmp\").await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_file_watcher_debug_format() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n    let debug_str = format!(\"{:?}\", watcher);\n    assert!(debug_str.contains(\"FileWatcher\"));\n    assert!(debug_str.contains(\"config\"));\n    assert!(debug_str.contains(\"processor\"));\n}\n\n#[tokio::test]\nasync fn test_file_watcher_processor_sharing() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let processor_clone = Arc::clone(&processor);\n\n    let _watcher = FileWatcher::new(&config, processor_clone).await.unwrap();\n\n    // Verify Arc sharing\n    assert!(Arc::strong_count(&processor) >= 2);\n}\n\n#[tokio::test]\nasync fn test_file_watcher_ignore_patterns() {\n    let mut config = create_test_watcher_config(true);\n    config.ignore_patterns = vec![\n        \"*.log\".to_string(),\n        \"node_modules/**\".to_string(),\n        \"*.tmp\".to_string(),\n    ];\n\n    let processor = create_test_processor().await;\n    let _watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n    // Config fields are private, so we just test that creation succeeds with custom patterns\n    assert_eq!(config.ignore_patterns.len(), 3);\n    assert!(config.ignore_patterns.contains(&\"*.log\".to_string()));\n    assert!(config.ignore_patterns.contains(&\"node_modules/**\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_file_watcher_multiple_start_stop() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let watcher = FileWatcher::new(&config, processor).await.unwrap();\n\n    // Multiple start/stop cycles should work\n    for _ in 0..3 {\n        watcher.start().await.unwrap();\n        watcher.stop().await.unwrap();\n    }\n}\n\n#[test]\nfn test_file_watcher_send_sync() {\n    fn assert_send<T: Send>() {}\n    fn assert_sync<T: Sync>() {}\n\n    assert_send::<FileWatcher>();\n    assert_sync::<FileWatcher>();\n}\n\n// ================================\n// CROSS-MODULE INTEGRATION TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_processor_and_state_integration() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(&processing_config, &qdrant_config).await.unwrap();\n\n    let db_config = create_test_database_config();\n    let state = DaemonState::new(&db_config).await.unwrap();\n\n    // Both should be functional\n    let doc_result = processor.process_document(\"integration_test.txt\").await;\n    assert!(doc_result.is_ok());\n\n    let health_result = state.health_check().await;\n    assert!(health_result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_watcher_and_processor_integration() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let processor_clone = Arc::clone(&processor);\n\n    let watcher = FileWatcher::new(&config, processor_clone).await.unwrap();\n\n    // Both components should be functional\n    watcher.start().await.unwrap();\n\n    let doc_result = processor.process_document(\"watcher_test.txt\").await;\n    assert!(doc_result.is_ok());\n\n    watcher.stop().await.unwrap();\n}\n\n#[test]\nfn test_all_components_send_sync() {\n    fn assert_send<T: Send>() {}\n    fn assert_sync<T: Sync>() {}\n\n    // All main daemon components should be Send + Sync\n    assert_send::<DaemonCore>();\n    assert_sync::<DaemonCore>();\n    assert_send::<SystemInfo>();\n    assert_sync::<SystemInfo>();\n    assert_send::<FileWatcher>();\n    assert_sync::<FileWatcher>();\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","tests","functional","test_service_integration.rs"],"content":"use proptest::prelude::*;\nuse serial_test::serial;\nuse std::time::Duration;\nuse testcontainers::{clients, images, Container, Docker};\nuse tokio::time::sleep;\n\n/// Property-based test for document content validation\n#[cfg(test)]\nmod property_tests {\n    use super::*;\n\n    proptest! {\n        #[test]\n        fn test_document_content_properties(\n            content in \"\\\\PC{1,10000}\", // Any Unicode string 1-10k chars\n            metadata in prop::collection::hash_map(\"\\\\PC{1,100}\", \"\\\\PC{1,1000}\", 0..10)\n        ) {\n            // Property: processed content should never be empty if input isn't empty\n            if !content.is_empty() {\n                let processed = process_document_content(&content);\n                prop_assert!(!processed.is_empty(), \"Processed content should not be empty\");\n            }\n\n            // Property: metadata keys should be preserved\n            let processed_metadata = process_metadata(metadata.clone());\n            for key in metadata.keys() {\n                prop_assert!(processed_metadata.contains_key(key), \"Metadata key should be preserved\");\n            }\n        }\n\n        #[test]\n        fn test_search_score_properties(\n            scores in prop::collection::vec(0.0f32..1.0f32, 1..100)\n        ) {\n            // Property: fusion scores should be in valid range\n            let fused_scores = reciprocal_rank_fusion(&scores, &scores);\n            for score in &fused_scores {\n                prop_assert!(*score >= 0.0, \"Fused score should be non-negative\");\n                prop_assert!(*score <= 2.0, \"Fused score should not exceed reasonable bounds\");\n            }\n\n            // Property: number of results should be preserved\n            prop_assert_eq!(fused_scores.len(), scores.len(), \"Result count should be preserved\");\n        }\n    }\n\n    // Mock implementations for testing\n    fn process_document_content(content: &str) -> String {\n        // Simple processing that preserves non-empty content\n        content.trim().to_string()\n    }\n\n    fn process_metadata(metadata: std::collections::HashMap<String, String>) -> std::collections::HashMap<String, String> {\n        // Simple passthrough processing\n        metadata\n    }\n\n    fn reciprocal_rank_fusion(dense_scores: &[f32], sparse_scores: &[f32]) -> Vec<f32> {\n        dense_scores\n            .iter()\n            .zip(sparse_scores.iter())\n            .enumerate()\n            .map(|(rank, (&dense, &sparse))| {\n                let rrf_dense = 1.0 / (60.0 + rank as f32 + 1.0);\n                let rrf_sparse = 1.0 / (60.0 + rank as f32 + 1.0);\n                dense * rrf_dense + sparse * rrf_sparse\n            })\n            .collect()\n    }\n}\n\n/// Integration tests using testcontainers\n#[cfg(test)]\nmod integration_tests {\n    use super::*;\n\n    #[tokio::test]\n    #[serial]\n    async fn test_qdrant_container_integration() {\n        // Note: This is a template - actual testcontainers integration would require\n        // implementing a custom Qdrant image or using HTTP calls\n\n        let docker = clients::Cli::default();\n\n        // For demonstration, using a generic container\n        // In real implementation, this would be a Qdrant container\n        let container = docker.run(images::generic::GenericImage::new(\"hello-world\", \"latest\"));\n\n        // Wait for container to be ready\n        sleep(Duration::from_secs(2)).await;\n\n        // Test basic container functionality\n        assert!(container.get_host_port_ipv4(6333).is_err()); // hello-world doesn't expose ports\n\n        // In a real test, you would:\n        // 1. Start Qdrant container\n        // 2. Wait for health check\n        // 3. Create collections\n        // 4. Test document ingestion\n        // 5. Test search operations\n        // 6. Verify isolation between tests\n    }\n\n    #[tokio::test]\n    #[serial]\n    async fn test_isolated_service_operations() {\n        // Template for isolated service testing\n        // Each test gets a fresh container instance\n\n        let docker = clients::Cli::default();\n\n        // Start service container\n        let _container = docker.run(images::generic::GenericImage::new(\"hello-world\", \"latest\"));\n\n        // Test specific service operations in isolation\n        test_document_upload().await;\n        test_search_functionality().await;\n        test_collection_management().await;\n\n        // Container automatically cleaned up when dropped\n    }\n\n    async fn test_document_upload() {\n        // Mock document upload test\n        let document = \"Test document content\";\n        let result = simulate_document_upload(document).await;\n        assert!(result.is_ok(), \"Document upload should succeed\");\n    }\n\n    async fn test_search_functionality() {\n        // Mock search test\n        let query = \"test query\";\n        let results = simulate_search(query).await;\n        assert!(!results.is_empty(), \"Search should return results\");\n    }\n\n    async fn test_collection_management() {\n        // Mock collection management test\n        let collection_name = \"test_collection\";\n        let created = simulate_create_collection(collection_name).await;\n        assert!(created, \"Collection creation should succeed\");\n\n        let deleted = simulate_delete_collection(collection_name).await;\n        assert!(deleted, \"Collection deletion should succeed\");\n    }\n\n    // Mock implementations for testing\n    async fn simulate_document_upload(_content: &str) -> Result<(), Box<dyn std::error::Error>> {\n        sleep(Duration::from_millis(10)).await;\n        Ok(())\n    }\n\n    async fn simulate_search(_query: &str) -> Vec<String> {\n        sleep(Duration::from_millis(5)).await;\n        vec![\"result1\".to_string(), \"result2\".to_string()]\n    }\n\n    async fn simulate_create_collection(_name: &str) -> bool {\n        sleep(Duration::from_millis(10)).await;\n        true\n    }\n\n    async fn simulate_delete_collection(_name: &str) -> bool {\n        sleep(Duration::from_millis(10)).await;\n        true\n    }\n}\n\n/// Performance tests using criterion-like patterns\n#[cfg(test)]\nmod performance_tests {\n    use super::*;\n    use std::time::Instant;\n\n    #[tokio::test]\n    async fn test_bulk_operations_performance() {\n        let document_count = 1000;\n        let documents: Vec<String> = (0..document_count)\n            .map(|i| format!(\"Document content {}\", i))\n            .collect();\n\n        let start = Instant::now();\n\n        // Simulate bulk document processing\n        for doc in &documents {\n            simulate_process_document(doc).await;\n        }\n\n        let duration = start.elapsed();\n        let docs_per_second = document_count as f64 / duration.as_secs_f64();\n\n        // Performance assertion\n        assert!(\n            docs_per_second > 100.0,\n            \"Processing rate should exceed 100 docs/second, got: {:.2}\",\n            docs_per_second\n        );\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_operations_performance() {\n        let concurrent_requests = 10;\n        let documents_per_request = 100;\n\n        let start = Instant::now();\n\n        let handles: Vec<_> = (0..concurrent_requests)\n            .map(|batch| {\n                tokio::spawn(async move {\n                    for i in 0..documents_per_request {\n                        let doc = format!(\"Batch {} Document {}\", batch, i);\n                        simulate_process_document(&doc).await;\n                    }\n                })\n            })\n            .collect();\n\n        // Wait for all concurrent operations to complete\n        for handle in handles {\n            handle.await.expect(\"Task should complete successfully\");\n        }\n\n        let duration = start.elapsed();\n        let total_docs = concurrent_requests * documents_per_request;\n        let docs_per_second = total_docs as f64 / duration.as_secs_f64();\n\n        // Performance assertion for concurrent processing\n        assert!(\n            docs_per_second > 500.0,\n            \"Concurrent processing rate should exceed 500 docs/second, got: {:.2}\",\n            docs_per_second\n        );\n    }\n\n    async fn simulate_process_document(_content: &str) {\n        // Simulate minimal processing time\n        sleep(Duration::from_micros(100)).await;\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","tests","grpc_middleware.rs"],"content":"//! Comprehensive unit tests for grpc/middleware.rs - targeting 90%+ coverage\n//!\n//! This test suite provides comprehensive coverage for:\n//! - ConnectionManager with all edge cases and error conditions\n//! - ConnectionInterceptor request/response handling\n//! - Retry mechanisms with backoff and timeout scenarios\n//! - Rate limiting edge cases and cleanup\n//! - Connection pool configuration\n//! - Concurrent operations and thread safety\n\nuse workspace_qdrant_daemon::grpc::middleware::*;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse tonic::{Request, Response, metadata::MetadataValue};\n\n// =============================================================================\n// CONNECTION MANAGER COMPREHENSIVE TESTS\n// =============================================================================\n\n#[test]\nfn test_connection_manager_creation_variants() {\n    // Test with different parameter combinations\n    let manager1 = ConnectionManager::new(0, 0);\n    assert_eq!(manager1.get_stats().max_connections, 0);\n\n    let manager2 = ConnectionManager::new(u64::MAX, u32::MAX);\n    assert_eq!(manager2.get_stats().max_connections, u64::MAX);\n\n    let manager3 = ConnectionManager::new(1, 1);\n    assert_eq!(manager3.get_stats().max_connections, 1);\n}\n\n#[test]\nfn test_connection_manager_register_edge_cases() {\n    let manager = ConnectionManager::new(1, 10);\n\n    // Test empty client ID\n    let result = manager.register_connection(\"\".to_string());\n    assert!(result.is_ok());\n    assert_eq!(manager.get_stats().active_connections, 1);\n\n    // Test duplicate registration (should succeed creating new connection)\n    let result2 = manager.register_connection(\"\".to_string());\n    assert!(result2.is_err()); // Should fail due to max_connections = 1\n\n    manager.unregister_connection(\"\");\n\n    // Test very long client ID\n    let long_id = \"a\".repeat(1000);\n    let result3 = manager.register_connection(long_id.clone());\n    assert!(result3.is_ok());\n\n    manager.unregister_connection(&long_id);\n\n    // Test special characters in client ID\n    let special_id = \"client-with/special\\\\chars:123\";\n    let result4 = manager.register_connection(special_id.to_string());\n    assert!(result4.is_ok());\n\n    manager.unregister_connection(special_id);\n}\n\n#[test]\nfn test_connection_manager_unregister_edge_cases() {\n    let manager = ConnectionManager::new(5, 10);\n\n    // Unregister non-existent connection multiple times\n    manager.unregister_connection(\"non_existent_1\");\n    manager.unregister_connection(\"non_existent_1\"); // Should not panic\n    manager.unregister_connection(\"different_non_existent\");\n\n    // Register and unregister same client multiple times\n    manager.register_connection(\"test_client\".to_string()).unwrap();\n    manager.unregister_connection(\"test_client\");\n    manager.unregister_connection(\"test_client\"); // Should not panic\n\n    assert_eq!(manager.get_stats().active_connections, 0);\n}\n\n#[test]\nfn test_connection_manager_rate_limiting_edge_cases() {\n    // Test with zero rate limit\n    let manager = ConnectionManager::new(10, 0);\n\n    let result = manager.check_rate_limit(\"client\");\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err().code(), tonic::Code::ResourceExhausted);\n\n    // Test with high rate limit\n    let manager2 = ConnectionManager::new(10, 1000);\n    for i in 0..999 {\n        let result = manager2.check_rate_limit(\"high_rate_client\");\n        assert!(result.is_ok(), \"Failed on request {}\", i);\n    }\n\n    // Should fail on 1000th request (at limit)\n    let result = manager2.check_rate_limit(\"high_rate_client\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_connection_manager_rate_limiting_cleanup() {\n    let manager = ConnectionManager::new(10, 2);\n\n    // Add some requests\n    manager.check_rate_limit(\"cleanup_client\").unwrap();\n    manager.check_rate_limit(\"cleanup_client\").unwrap();\n\n    // Next should fail\n    assert!(manager.check_rate_limit(\"cleanup_client\").is_err());\n\n    // Wait a bit and then add more requests to trigger cleanup path\n    std::thread::sleep(Duration::from_millis(10));\n\n    // Add requests for different clients to trigger the cleanup logic\n    for i in 0..10 {\n        let client_id = format!(\"temp_client_{}\", i);\n        let _ = manager.check_rate_limit(&client_id);\n    }\n}\n\n#[test]\nfn test_connection_manager_rate_limiting_time_window() {\n    let manager = ConnectionManager::new(10, 2);\n\n    // Use up rate limit\n    assert!(manager.check_rate_limit(\"time_test\").is_ok());\n    assert!(manager.check_rate_limit(\"time_test\").is_ok());\n    assert!(manager.check_rate_limit(\"time_test\").is_err());\n\n    // Wait for time window to pass (slightly more than 1 second)\n    std::thread::sleep(Duration::from_millis(1100));\n\n    // Should be able to make requests again\n    assert!(manager.check_rate_limit(\"time_test\").is_ok());\n    assert!(manager.check_rate_limit(\"time_test\").is_ok());\n    assert!(manager.check_rate_limit(\"time_test\").is_err());\n}\n\n#[test]\nfn test_connection_manager_update_activity_edge_cases() {\n    let manager = ConnectionManager::new(5, 10);\n\n    // Update activity for non-existent connection\n    manager.update_activity(\"non_existent\", 100, 200);\n\n    // Register connection and update with zero values\n    manager.register_connection(\"zero_activity\".to_string()).unwrap();\n    manager.update_activity(\"zero_activity\", 0, 0);\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.total_requests, 1); // From register + update_activity call\n\n    // Update with large values\n    manager.update_activity(\"zero_activity\", u64::MAX, u64::MAX);\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.total_requests, 2);\n    assert_eq!(stats.total_bytes_sent, u64::MAX);\n    assert_eq!(stats.total_bytes_received, u64::MAX);\n}\n\n#[test]\nfn test_connection_manager_cleanup_expired_edge_cases() {\n    let manager = ConnectionManager::new(10, 10);\n\n    // Cleanup with no connections\n    manager.cleanup_expired_connections(Duration::from_secs(0));\n    manager.cleanup_expired_connections(Duration::from_secs(3600));\n\n    // Register multiple connections\n    for i in 0..5 {\n        manager.register_connection(format!(\"client_{}\", i)).unwrap();\n    }\n\n    assert_eq!(manager.get_stats().active_connections, 5);\n\n    // Update activity for some connections\n    manager.update_activity(\"client_0\", 100, 100);\n    manager.update_activity(\"client_2\", 100, 100);\n    manager.update_activity(\"client_4\", 100, 100);\n\n    // Cleanup with zero timeout (should remove all)\n    manager.cleanup_expired_connections(Duration::from_secs(0));\n    assert_eq!(manager.get_stats().active_connections, 0);\n}\n\n#[test]\nfn test_connection_manager_get_stats_accuracy() {\n    let manager = ConnectionManager::new(10, 10);\n\n    // Test with no connections\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n    assert_eq!(stats.total_bytes_sent, 0);\n    assert_eq!(stats.total_bytes_received, 0);\n    assert_eq!(stats.max_connections, 10);\n\n    // Add connections with different activity levels\n    manager.register_connection(\"stats_client_1\".to_string()).unwrap();\n    manager.register_connection(\"stats_client_2\".to_string()).unwrap();\n\n    manager.update_activity(\"stats_client_1\", 1000, 500);\n    manager.update_activity(\"stats_client_1\", 2000, 1000);\n    manager.update_activity(\"stats_client_2\", 500, 250);\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 2);\n    assert_eq!(stats.total_requests, 5); // 2 registrations + 3 activity updates\n    assert_eq!(stats.total_bytes_sent, 3500);\n    assert_eq!(stats.total_bytes_received, 1750);\n}\n\n// =============================================================================\n// CONNECTION INTERCEPTOR COMPREHENSIVE TESTS\n// =============================================================================\n\n#[test]\nfn test_connection_interceptor_intercept_metadata_parsing() {\n    let manager = Arc::new(ConnectionManager::new(10, 10));\n    let interceptor = ConnectionInterceptor::new(manager);\n\n    // Test with static metadata (simpler case)\n    let mut request: Request<()> = Request::new(());\n    request.metadata_mut().insert(\n        \"client-id\",\n        MetadataValue::from_static(\"test_client\")\n    );\n\n    // Should handle gracefully\n    let result = interceptor.intercept(request);\n    assert!(result.is_ok());\n\n    // Test with empty metadata value\n    let mut request2: Request<()> = Request::new(());\n    request2.metadata_mut().insert(\"client-id\", MetadataValue::from_static(\"\"));\n\n    let result2 = interceptor.intercept(request2);\n    assert!(result2.is_ok());\n\n    // Test with whitespace-only client ID\n    let mut request3: Request<()> = Request::new(());\n    request3.metadata_mut().insert(\"client-id\", MetadataValue::from_static(\"   \"));\n\n    let result3 = interceptor.intercept(request3);\n    assert!(result3.is_ok());\n}\n\n#[test]\nfn test_connection_interceptor_rate_limiting_integration() {\n    let manager = Arc::new(ConnectionManager::new(10, 1)); // Very restrictive rate limit\n    let interceptor = ConnectionInterceptor::new(manager);\n\n    // First request should succeed\n    let mut request1: Request<()> = Request::new(());\n    request1.metadata_mut().insert(\"client-id\", MetadataValue::from_static(\"rate_limited_client\"));\n\n    let result1 = interceptor.intercept(request1);\n    assert!(result1.is_ok());\n\n    // Second request should fail due to rate limiting\n    let mut request2: Request<()> = Request::new(());\n    request2.metadata_mut().insert(\"client-id\", MetadataValue::from_static(\"rate_limited_client\"));\n\n    let result2 = interceptor.intercept(request2);\n    assert!(result2.is_err());\n    assert_eq!(result2.unwrap_err().code(), tonic::Code::ResourceExhausted);\n}\n\n#[test]\nfn test_connection_interceptor_response_handling() {\n    let manager = Arc::new(ConnectionManager::new(10, 10));\n    let interceptor = ConnectionInterceptor::new(manager.clone());\n\n    // Register a client first\n    manager.register_connection(\"response_client\".to_string()).unwrap();\n\n    // Test response interception with various response types\n    let response1: Response<String> = Response::new(\"test_response\".to_string());\n    let result1 = interceptor.intercept_response(response1, \"response_client\");\n    assert_eq!(result1.get_ref(), \"test_response\");\n\n    // Test with unit response\n    let response2: Response<()> = Response::new(());\n    let result2 = interceptor.intercept_response(response2, \"response_client\");\n    assert_eq!(result2.get_ref(), &());\n\n    // Test with non-existent client (should not panic)\n    let response3: Response<i32> = Response::new(42);\n    let result3 = interceptor.intercept_response(response3, \"non_existent_client\");\n    assert_eq!(result3.get_ref(), &42);\n}\n\n// =============================================================================\n// RETRY MECHANISM COMPREHENSIVE TESTS\n// =============================================================================\n\n#[tokio::test]\nasync fn test_with_retry_zero_retries() {\n    let config = RetryConfig {\n        max_retries: 0,\n        initial_delay: Duration::from_millis(1),\n        max_delay: Duration::from_secs(1),\n        backoff_multiplier: 2.0,\n    };\n\n    // Should fail immediately with zero retries\n    let result = with_retry(\n        || Box::pin(async { Err::<i32, &'static str>(\"immediate failure\") }),\n        &config,\n    ).await;\n\n    assert_eq!(result.unwrap_err(), \"immediate failure\");\n}\n\n#[tokio::test]\nasync fn test_with_retry_backoff_progression() {\n    let config = RetryConfig {\n        max_retries: 4,\n        initial_delay: Duration::from_millis(1),\n        max_delay: Duration::from_millis(10),\n        backoff_multiplier: 2.0,\n    };\n\n    let start_time = Instant::now();\n    let attempt_count = Arc::new(AtomicU64::new(0));\n    let attempt_clone = Arc::clone(&attempt_count);\n\n    let result = with_retry(\n        move || {\n            attempt_clone.fetch_add(1, Ordering::SeqCst);\n            Box::pin(async { Err::<i32, &'static str>(\"always fail\") })\n        },\n        &config,\n    ).await;\n\n    let elapsed = start_time.elapsed();\n\n    // Should have made max_retries attempts\n    assert_eq!(attempt_count.load(Ordering::SeqCst), 4);\n    assert!(result.is_err());\n\n    // Should have taken some time due to backoff delays\n    // Total expected delay: 1ms + 2ms + 4ms = 7ms (capped at max_delay)\n    assert!(elapsed >= Duration::from_millis(5));\n}\n\n#[tokio::test]\nasync fn test_with_retry_max_delay_capping() {\n    let config = RetryConfig {\n        max_retries: 3,\n        initial_delay: Duration::from_millis(10),\n        max_delay: Duration::from_millis(15), // Cap below expected exponential growth\n        backoff_multiplier: 10.0, // High multiplier\n    };\n\n    let start_time = Instant::now();\n\n    let result = with_retry(\n        || Box::pin(async { Err::<i32, &'static str>(\"capped delay test\") }),\n        &config,\n    ).await;\n\n    let elapsed = start_time.elapsed();\n\n    // With multiplier 10.0, delays would be: 10ms, 100ms, 1000ms\n    // But capped at 15ms each, so total should be around 30ms\n    assert!(elapsed < Duration::from_millis(100)); // Much less than uncapped\n    assert!(elapsed >= Duration::from_millis(25)); // But still some delay\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_with_retry_success_after_retries() {\n    let config = RetryConfig {\n        max_retries: 5,\n        initial_delay: Duration::from_millis(1),\n        max_delay: Duration::from_secs(1),\n        backoff_multiplier: 1.5,\n    };\n\n    let attempt_count = Arc::new(AtomicU64::new(0));\n    let attempt_clone = Arc::clone(&attempt_count);\n\n    let result = with_retry(\n        move || {\n            let current_attempt = attempt_clone.fetch_add(1, Ordering::SeqCst) + 1;\n            Box::pin(async move {\n                if current_attempt < 4 {\n                    Err(\"not yet\")\n                } else {\n                    Ok::<i32, &'static str>(42)\n                }\n            })\n        },\n        &config,\n    ).await;\n\n    assert_eq!(result.unwrap(), 42);\n    assert_eq!(attempt_count.load(Ordering::SeqCst), 4);\n}\n\n#[tokio::test]\nasync fn test_with_retry_different_error_types() {\n    let config = RetryConfig::default();\n\n    // Test with String error\n    let result1 = with_retry(\n        || Box::pin(async { Err::<i32, String>(\"string error\".to_string()) }),\n        &config,\n    ).await;\n    assert!(result1.is_err());\n\n    // Test with custom error type\n    #[derive(Debug, PartialEq)]\n    struct CustomError(&'static str);\n\n    let result2 = with_retry(\n        || Box::pin(async { Err::<i32, CustomError>(CustomError(\"custom error\")) }),\n        &config,\n    ).await;\n    assert_eq!(result2.unwrap_err(), CustomError(\"custom error\"));\n}\n\n// =============================================================================\n// CONFIGURATION TESTS\n// =============================================================================\n\n#[test]\nfn test_pool_config_comprehensive() {\n    // Test default values\n    let default_config = PoolConfig::default();\n    assert_eq!(default_config.max_size, 10);\n    assert_eq!(default_config.min_idle, Some(2));\n    assert_eq!(default_config.max_lifetime, Some(Duration::from_secs(3600)));\n    assert_eq!(default_config.idle_timeout, Some(Duration::from_secs(600)));\n    assert_eq!(default_config.connection_timeout, Duration::from_secs(30));\n\n    // Test custom configuration with edge values\n    let custom_config = PoolConfig {\n        max_size: 0,\n        min_idle: None,\n        max_lifetime: None,\n        idle_timeout: None,\n        connection_timeout: Duration::from_millis(1),\n    };\n\n    assert_eq!(custom_config.max_size, 0);\n    assert_eq!(custom_config.min_idle, None);\n    assert_eq!(custom_config.max_lifetime, None);\n    assert_eq!(custom_config.idle_timeout, None);\n    assert_eq!(custom_config.connection_timeout, Duration::from_millis(1));\n\n    // Test extreme values\n    let extreme_config = PoolConfig {\n        max_size: usize::MAX,\n        min_idle: Some(usize::MAX),\n        max_lifetime: Some(Duration::from_secs(u64::MAX)),\n        idle_timeout: Some(Duration::from_nanos(1)),\n        connection_timeout: Duration::from_secs(0),\n    };\n\n    assert_eq!(extreme_config.max_size, usize::MAX);\n    assert_eq!(extreme_config.min_idle, Some(usize::MAX));\n}\n\n#[test]\nfn test_retry_config_comprehensive() {\n    // Test default values\n    let default_config = RetryConfig::default();\n    assert_eq!(default_config.max_retries, 3);\n    assert_eq!(default_config.initial_delay, Duration::from_millis(100));\n    assert_eq!(default_config.max_delay, Duration::from_secs(30));\n    assert_eq!(default_config.backoff_multiplier, 2.0);\n\n    // Test custom configuration with edge values\n    let custom_config = RetryConfig {\n        max_retries: 0,\n        initial_delay: Duration::from_nanos(1),\n        max_delay: Duration::from_nanos(1),\n        backoff_multiplier: 0.0,\n    };\n\n    assert_eq!(custom_config.max_retries, 0);\n    assert_eq!(custom_config.initial_delay, Duration::from_nanos(1));\n    assert_eq!(custom_config.max_delay, Duration::from_nanos(1));\n    assert_eq!(custom_config.backoff_multiplier, 0.0);\n\n    // Test extreme values\n    let extreme_config = RetryConfig {\n        max_retries: u32::MAX,\n        initial_delay: Duration::from_secs(u64::MAX),\n        max_delay: Duration::from_secs(u64::MAX),\n        backoff_multiplier: f64::MAX,\n    };\n\n    assert_eq!(extreme_config.max_retries, u32::MAX);\n    assert_eq!(extreme_config.backoff_multiplier, f64::MAX);\n}\n\n// =============================================================================\n// CONCURRENCY AND THREAD SAFETY TESTS\n// =============================================================================\n\n#[tokio::test]\nasync fn test_connection_manager_concurrent_operations() {\n    let manager = Arc::new(ConnectionManager::new(50, 100));\n    let mut handles = vec![];\n\n    // Spawn tasks for concurrent registration/unregistration\n    for i in 0..20 {\n        let manager_clone = Arc::clone(&manager);\n        let handle = tokio::spawn(async move {\n            let client_id = format!(\"concurrent_client_{}\", i);\n\n            // Register\n            manager_clone.register_connection(client_id.clone()).unwrap();\n\n            // Update activity multiple times\n            for j in 0..10 {\n                manager_clone.update_activity(&client_id, j * 10, j * 5);\n                tokio::time::sleep(Duration::from_micros(1)).await;\n            }\n\n            // Check rate limits\n            for _ in 0..5 {\n                let _ = manager_clone.check_rate_limit(&client_id);\n            }\n\n            // Unregister\n            manager_clone.unregister_connection(&client_id);\n        });\n        handles.push(handle);\n    }\n\n    // Wait for all tasks to complete\n    for handle in handles {\n        handle.await.unwrap();\n    }\n\n    // All connections should be cleaned up\n    assert_eq!(manager.get_stats().active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_connection_manager_concurrent_rate_limiting() {\n    let manager = Arc::new(ConnectionManager::new(100, 5)); // 5 requests per second\n    let mut handles = vec![];\n\n    // Spawn multiple tasks hitting rate limits simultaneously\n    for i in 0..10 {\n        let manager_clone = Arc::clone(&manager);\n        let handle = tokio::spawn(async move {\n            let client_id = format!(\"rate_client_{}\", i);\n\n            // Each client should be able to make 5 requests before hitting limit\n            let mut success_count = 0;\n            let mut error_count = 0;\n\n            for _ in 0..10 {\n                match manager_clone.check_rate_limit(&client_id) {\n                    Ok(()) => success_count += 1,\n                    Err(_) => error_count += 1,\n                }\n            }\n\n            (success_count, error_count)\n        });\n        handles.push(handle);\n    }\n\n    // Collect results\n    let mut total_success = 0;\n    let mut total_errors = 0;\n\n    for handle in handles {\n        let (success, errors) = handle.await.unwrap();\n        total_success += success;\n        total_errors += errors;\n    }\n\n    // Each client should have been rate limited\n    assert!(total_success > 0);\n    assert!(total_errors > 0);\n    assert_eq!(total_success + total_errors, 100); // 10 clients * 10 requests each\n}\n\n#[tokio::test]\nasync fn test_connection_interceptor_concurrent_requests() {\n    let manager = Arc::new(ConnectionManager::new(100, 50));\n    let interceptor = ConnectionInterceptor::new(manager.clone());\n    let mut handles = vec![];\n\n    // Register some clients\n    for i in 0..10 {\n        manager.register_connection(format!(\"interceptor_client_{}\", i)).unwrap();\n    }\n\n    // Spawn concurrent request interceptions\n    for i in 0..20 {\n        let interceptor_clone = interceptor.clone();\n        let handle = tokio::spawn(async move {\n            let mut request: Request<String> = Request::new(format!(\"request_{}\", i));\n            let _client_id = format!(\"interceptor_client_{}\", i % 10);\n            request.metadata_mut().insert(\n                \"client-id\",\n                MetadataValue::from_static(\"interceptor_client_0\")\n            );\n\n            let result = interceptor_clone.intercept(request);\n            result.is_ok()\n        });\n        handles.push(handle);\n    }\n\n    // Wait for all interceptions to complete\n    let mut success_count = 0;\n    for handle in handles {\n        if handle.await.unwrap() {\n            success_count += 1;\n        }\n    }\n\n    // Some should succeed (before rate limits hit)\n    assert!(success_count > 0);\n}\n\n// =============================================================================\n// DEBUG AND TRAIT IMPLEMENTATION TESTS\n// =============================================================================\n\n#[test]\nfn test_debug_implementations() {\n    let manager = ConnectionManager::new(10, 5);\n    let debug_str = format!(\"{:?}\", manager);\n    assert!(debug_str.contains(\"ConnectionManager\"));\n\n    let stats = manager.get_stats();\n    let _stats_debug = format!(\"{:?}\", stats);\n    assert!(debug_str.contains(\"ConnectionStats\"));\n\n    let config = PoolConfig::default();\n    let config_debug = format!(\"{:?}\", config);\n    assert!(config_debug.contains(\"PoolConfig\"));\n\n    let retry_config = RetryConfig::default();\n    let retry_debug = format!(\"{:?}\", retry_config);\n    assert!(retry_debug.contains(\"RetryConfig\"));\n\n    let interceptor = ConnectionInterceptor::new(Arc::new(manager));\n    let interceptor_debug = format!(\"{:?}\", interceptor);\n    assert!(interceptor_debug.contains(\"ConnectionInterceptor\"));\n}\n\n#[test]\nfn test_clone_implementations() {\n    let stats = ConnectionStats {\n        active_connections: 5,\n        max_connections: 10,\n        total_requests: 100,\n        total_bytes_sent: 1000,\n        total_bytes_received: 2000,\n    };\n    let cloned_stats = stats.clone();\n    assert_eq!(stats.active_connections, cloned_stats.active_connections);\n\n    let config = PoolConfig::default();\n    let cloned_config = config.clone();\n    assert_eq!(config.max_size, cloned_config.max_size);\n\n    let retry_config = RetryConfig::default();\n    let cloned_retry = retry_config.clone();\n    assert_eq!(retry_config.max_retries, cloned_retry.max_retries);\n\n    let manager = Arc::new(ConnectionManager::new(10, 5));\n    let interceptor = ConnectionInterceptor::new(manager);\n    let cloned_interceptor = interceptor.clone();\n\n    // Should be able to use both interceptors\n    let _ = format!(\"{:?}\", interceptor);\n    let _ = format!(\"{:?}\", cloned_interceptor);\n}\n\n#[test]\nfn test_send_sync_traits() {\n    fn assert_send_sync<T: Send + Sync>() {}\n\n    assert_send_sync::<ConnectionManager>();\n    assert_send_sync::<ConnectionStats>();\n    assert_send_sync::<PoolConfig>();\n    assert_send_sync::<RetryConfig>();\n    assert_send_sync::<ConnectionInterceptor>();\n}\n\n// =============================================================================\n// ERROR HANDLING AND EDGE CASE TESTS\n// =============================================================================\n\n#[test]\nfn test_connection_info_clone_atomics() {\n    let info = ConnectionInfo {\n        client_id: \"test_atomic_clone\".to_string(),\n        connected_at: Instant::now(),\n        last_activity: Instant::now(),\n        request_count: AtomicU64::new(42),\n        bytes_sent: AtomicU64::new(1000),\n        bytes_received: AtomicU64::new(2000),\n    };\n\n    // Modify original atomics\n    info.request_count.store(100, Ordering::SeqCst);\n    info.bytes_sent.store(5000, Ordering::SeqCst);\n    info.bytes_received.store(10000, Ordering::SeqCst);\n\n    // Clone should capture the current values\n    let cloned = info.clone();\n\n    assert_eq!(cloned.client_id, info.client_id);\n    assert_eq!(cloned.request_count.load(Ordering::SeqCst), 100);\n    assert_eq!(cloned.bytes_sent.load(Ordering::SeqCst), 5000);\n    assert_eq!(cloned.bytes_received.load(Ordering::SeqCst), 10000);\n\n    // Modifying original should not affect clone\n    info.request_count.store(999, Ordering::SeqCst);\n    assert_eq!(cloned.request_count.load(Ordering::SeqCst), 100);\n}\n\n#[test]\nfn test_connection_manager_stats_edge_cases() {\n    let manager = ConnectionManager::new(3, 10);\n\n    // Register connections with various activity levels\n    manager.register_connection(\"stats_test_1\".to_string()).unwrap();\n    manager.register_connection(\"stats_test_2\".to_string()).unwrap();\n\n    // Create overflow conditions for bytes counting\n    manager.update_activity(\"stats_test_1\", u64::MAX / 2, u64::MAX / 2);\n    manager.update_activity(\"stats_test_2\", u64::MAX / 2, u64::MAX / 2);\n\n    let stats = manager.get_stats();\n\n    // Should handle large numbers correctly\n    assert_eq!(stats.active_connections, 2);\n    assert!(stats.total_bytes_sent >= u64::MAX / 2);\n    assert!(stats.total_bytes_received >= u64::MAX / 2);\n}\n\n#[tokio::test]\nasync fn test_with_retry_unreachable_path() {\n    // This test ensures that the unreachable!() path in with_retry is never hit\n    // by testing the loop termination logic\n\n    let config = RetryConfig {\n        max_retries: 1,\n        initial_delay: Duration::from_millis(1),\n        max_delay: Duration::from_secs(1),\n        backoff_multiplier: 2.0,\n    };\n\n    let result = with_retry(\n        || Box::pin(async { Err::<i32, &'static str>(\"test error\") }),\n        &config,\n    ).await;\n\n    // Should return error, not hit unreachable!()\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_rate_limiter_cleanup_retention() {\n    let manager = ConnectionManager::new(10, 10);\n\n    // Add requests for multiple clients\n    for i in 0..5 {\n        let client_id = format!(\"retention_client_{}\", i);\n        let _ = manager.check_rate_limit(&client_id);\n    }\n\n    // Force cleanup by waiting and making more requests to trigger the cleanup interval\n    std::thread::sleep(Duration::from_millis(10));\n\n    // Adding requests for new clients should potentially trigger cleanup\n    for i in 5..10 {\n        let client_id = format!(\"retention_client_{}\", i);\n        let _ = manager.check_rate_limit(&client_id);\n    }\n\n    // The internal state should be maintained correctly\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 0); // No connections registered yet\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","tests","grpc_server.rs"],"content":"//! Comprehensive unit tests for grpc/server.rs achieving 90%+ coverage\n//! Tests cover server creation, service registration, connection management, and configuration\n\nuse workspace_qdrant_daemon::config::*;\nuse workspace_qdrant_daemon::daemon::WorkspaceDaemon;\nuse workspace_qdrant_daemon::grpc::server::GrpcServer;\nuse std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};\nuse std::sync::Arc;\nuse std::time::Duration;\n// Unused imports removed for cleaner test output\n\n// ================================\n// TEST CONFIGURATION HELPERS\n// ================================\n\nfn create_test_daemon_config() -> DaemonConfig {\n    // Use in-memory SQLite database for tests\n    let db_path = \":memory:\";\n\n    DaemonConfig {\n        server: ServerConfig {\n            host: \"127.0.0.1\".to_string(),\n            port: 50052, // Use different port for testing\n            max_connections: 100,\n            connection_timeout_secs: 30,\n            request_timeout_secs: 60,\n            enable_tls: false,\n        },\n        database: DatabaseConfig {\n            sqlite_path: db_path.to_string(),\n            max_connections: 5,\n            connection_timeout_secs: 30,\n            enable_wal: true,\n        },\n        qdrant: QdrantConfig {\n            url: \"http://localhost:6333\".to_string(),\n            api_key: None,\n            timeout_secs: 30,\n            max_retries: 3,\n            default_collection: CollectionConfig {\n                vector_size: 384,\n                distance_metric: \"Cosine\".to_string(),\n                enable_indexing: true,\n                replication_factor: 1,\n                shard_number: 1,\n            },\n        },\n        processing: ProcessingConfig {\n            max_concurrent_tasks: 2,\n            default_chunk_size: 1000,\n            default_chunk_overlap: 200,\n            max_file_size_bytes: 1024 * 1024,\n            supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n            enable_lsp: false,\n            lsp_timeout_secs: 10,\n        },\n        file_watcher: FileWatcherConfig {\n            enabled: false,\n            debounce_ms: 500,\n            max_watched_dirs: 10,\n            ignore_patterns: vec![],\n            recursive: true,\n        },\n        metrics: MetricsConfig {\n            enabled: false,\n            collection_interval_secs: 60,\n            retention_days: 30,\n            enable_prometheus: false,\n            prometheus_port: 9090,\n        },\n        logging: LoggingConfig {\n            level: \"info\".to_string(),\n            file_path: None,\n            json_format: false,\n            max_file_size_mb: 100,\n            max_files: 5,\n        },\n    }\n}\n\nfn create_test_daemon_config_with_tls() -> DaemonConfig {\n    let mut config = create_test_daemon_config();\n    config.server.enable_tls = true;\n    config.server.connection_timeout_secs = 60; // Different timeout\n    config.server.request_timeout_secs = 120;\n    config\n}\n\nfn create_test_daemon_config_large_limits() -> DaemonConfig {\n    let mut config = create_test_daemon_config();\n    config.server.max_connections = 1000;\n    config.server.connection_timeout_secs = 300;\n    config.server.request_timeout_secs = 600;\n    config\n}\n\nasync fn create_test_daemon() -> WorkspaceDaemon {\n    let config = create_test_daemon_config();\n    WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\")\n}\n\nasync fn create_test_daemon_with_config(config: DaemonConfig) -> WorkspaceDaemon {\n    WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\")\n}\n\n// ================================\n// SERVER CREATION TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_new_basic() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that we can access connection manager (public API)\n    assert!(Arc::strong_count(server.connection_manager()) >= 1);\n\n    // Test that connection stats are accessible\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_new_with_different_addresses() {\n    let daemon = create_test_daemon().await;\n\n    // Test IPv4 loopback\n    let ipv4_loopback = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 8080);\n    let server1 = GrpcServer::new(daemon.clone(), ipv4_loopback);\n    let stats1 = server1.get_connection_stats();\n    assert_eq!(stats1.active_connections, 0);\n\n    // Test IPv4 any\n    let ipv4_any = SocketAddr::new(IpAddr::V4(Ipv4Addr::UNSPECIFIED), 8081);\n    let server2 = GrpcServer::new(daemon.clone(), ipv4_any);\n    let stats2 = server2.get_connection_stats();\n    assert_eq!(stats2.active_connections, 0);\n\n    // Test IPv6 loopback\n    let ipv6_loopback = SocketAddr::new(IpAddr::V6(Ipv6Addr::LOCALHOST), 8082);\n    let server3 = GrpcServer::new(daemon.clone(), ipv6_loopback);\n    let stats3 = server3.get_connection_stats();\n    assert_eq!(stats3.active_connections, 0);\n\n    // Test different port ranges\n    let high_port = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 65535);\n    let server4 = GrpcServer::new(daemon.clone(), high_port);\n    let stats4 = server4.get_connection_stats();\n    assert_eq!(stats4.active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_new_with_config_variations() {\n    // Test with TLS enabled config\n    let tls_config = create_test_daemon_config_with_tls();\n    let daemon_tls = create_test_daemon_with_config(tls_config).await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8443);\n    let server_tls = GrpcServer::new(daemon_tls, address);\n    let stats_tls = server_tls.get_connection_stats();\n    assert_eq!(stats_tls.active_connections, 0);\n\n    // Test with large connection limits\n    let large_config = create_test_daemon_config_large_limits();\n    let daemon_large = create_test_daemon_with_config(large_config).await;\n    let server_large = GrpcServer::new(daemon_large, address);\n    let stats_large = server_large.get_connection_stats();\n    assert_eq!(stats_large.max_connections, 1000);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_connection_manager_initialization() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let connection_manager = server.connection_manager();\n\n    // Test that connection manager is properly initialized\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n    assert_eq!(stats.total_bytes_sent, 0);\n    assert_eq!(stats.total_bytes_received, 0);\n    assert_eq!(stats.max_connections, 100); // From test config\n}\n\n// ================================\n// SERVER CONFIGURATION TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_configuration_validation() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that server is properly configured\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.max_connections, 100); // From test config\n}\n\n#[tokio::test]\nasync fn test_grpc_server_with_different_configs() {\n    // Test with TLS config\n    let tls_config = create_test_daemon_config_with_tls();\n    let daemon_tls = create_test_daemon_with_config(tls_config).await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    let server_tls = GrpcServer::new(daemon_tls, address);\n    let stats_tls = server_tls.get_connection_stats();\n    assert_eq!(stats_tls.active_connections, 0);\n\n    // Test with large limits config\n    let large_config = create_test_daemon_config_large_limits();\n    let daemon_large = create_test_daemon_with_config(large_config).await;\n    let server_large = GrpcServer::new(daemon_large, address);\n    let stats_large = server_large.get_connection_stats();\n    assert_eq!(stats_large.max_connections, 1000);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_service_registration() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that server is properly initialized with services\n    // We can't call build_server directly, but we can verify the server exists\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.active_connections, 0);\n\n    // Test connection manager is properly initialized\n    let connection_manager = server.connection_manager();\n    assert!(Arc::strong_count(connection_manager) >= 1);\n}\n\n// ================================\n// CONNECTION MANAGEMENT TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_get_connection_stats() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let stats = server.get_connection_stats();\n\n    // Initially should have no active connections\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n    assert_eq!(stats.max_connections, 100);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_connection_manager_access() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let connection_manager1 = server.connection_manager();\n    let connection_manager2 = server.connection_manager();\n\n    // Should return the same Arc instance\n    assert!(Arc::ptr_eq(connection_manager1, connection_manager2));\n\n    // Test that we can access connection manager methods\n    let stats = connection_manager1.get_stats();\n    assert_eq!(stats.active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_connection_manager_with_rate_limiting() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let connection_manager = server.connection_manager();\n\n    // Test rate limiting is initialized (100 requests per second from server.rs)\n    // Register a connection first\n    let register_result = connection_manager.register_connection(\"test_client\".to_string());\n    assert!(register_result.is_ok());\n\n    // Check that connection is registered\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Test rate limiting check\n    let rate_check = connection_manager.check_rate_limit(\"test_client\");\n    assert!(rate_check.is_ok());\n}\n\n// ================================\n// SERVER INITIALIZATION TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_initialization() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0); // Use port 0 for auto-assignment\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that server is properly initialized\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_ready_state() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that server is in ready state for serving\n    let connection_manager = server.connection_manager();\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n\n    // Test that connection manager is properly configured\n    assert_eq!(stats.max_connections, 100); // From test config\n}\n\n// ================================\n// CONFIGURATION EDGE CASES\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_address_types_and_parsing() {\n    let daemon = create_test_daemon().await;\n\n    // Test IPv4 address\n    let ipv4 = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1)), 8080);\n    let server_ipv4 = GrpcServer::new(daemon.clone(), ipv4);\n    let stats_ipv4 = server_ipv4.get_connection_stats();\n    assert_eq!(stats_ipv4.active_connections, 0);\n\n    // Test IPv6 address\n    let ipv6 = \"[::1]:9090\".parse::<SocketAddr>().unwrap();\n    let server_ipv6 = GrpcServer::new(daemon.clone(), ipv6);\n    let stats_ipv6 = server_ipv6.get_connection_stats();\n    assert_eq!(stats_ipv6.active_connections, 0);\n\n    // Test wildcard addresses\n    let ipv4_any = SocketAddr::new(IpAddr::V4(Ipv4Addr::UNSPECIFIED), 8080);\n    let server_any = GrpcServer::new(daemon.clone(), ipv4_any);\n    let stats_any = server_any.get_connection_stats();\n    assert_eq!(stats_any.active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_with_different_ports() {\n    let daemon = create_test_daemon().await;\n\n    let ports = [8080, 8081, 8082, 50051, 443, 65535];\n    for port in ports {\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);\n        let server = GrpcServer::new(daemon.clone(), address);\n\n        // Test that connection manager is properly initialized for each\n        let stats = server.get_connection_stats();\n        assert_eq!(stats.active_connections, 0);\n        assert_eq!(stats.max_connections, 100);\n    }\n}\n\n// ================================\n// ARC SHARING AND MEMORY TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_arc_sharing() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let connection_manager = server.connection_manager();\n\n    // Verify connection manager is properly shared via Arc\n    assert!(Arc::strong_count(connection_manager) >= 1);\n\n    // Test accessing connection manager methods\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.max_connections, 100);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_memory_efficiency() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Verify that server doesn't hold unnecessary references\n    let initial_manager_count = Arc::strong_count(server.connection_manager());\n\n    assert_eq!(initial_manager_count, 1);\n\n    // Test that accessing methods doesn't increase reference counts unexpectedly\n    let _stats = server.get_connection_stats();\n    let _manager = server.connection_manager();\n\n    assert_eq!(Arc::strong_count(server.connection_manager()), initial_manager_count);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_config_integration() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that connection manager was initialized with correct values from config\n    let connection_manager = server.connection_manager();\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.max_connections, 100);\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n}\n\n// ================================\n// CONCURRENT ACCESS TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_concurrent_access() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = Arc::new(GrpcServer::new(daemon, address));\n\n    let server1 = Arc::clone(&server);\n    let server2 = Arc::clone(&server);\n    let server3 = Arc::clone(&server);\n\n    let handle1 = tokio::spawn(async move {\n        let _stats = server1.get_connection_stats();\n        let _manager = server1.connection_manager();\n    });\n\n    let handle2 = tokio::spawn(async move {\n        let _stats = server2.get_connection_stats();\n        let _manager = server2.connection_manager();\n    });\n\n    let handle3 = tokio::spawn(async move {\n        let _stats = server3.get_connection_stats();\n        let _manager = server3.connection_manager();\n    });\n\n    let (r1, r2, r3) = tokio::join!(handle1, handle2, handle3);\n    assert!(r1.is_ok());\n    assert!(r2.is_ok());\n    assert!(r3.is_ok());\n}\n\n// ================================\n// CONNECTION CLEANUP TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_connection_cleanup_simulation() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let connection_manager = server.connection_manager();\n\n    // Simulate the cleanup task that would run in serve() and serve_daemon()\n    // Register some connections\n    assert!(connection_manager.register_connection(\"client1\".to_string()).is_ok());\n    assert!(connection_manager.register_connection(\"client2\".to_string()).is_ok());\n\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.active_connections, 2);\n\n    // Test cleanup with various timeouts (simulating the 60-second interval cleanup)\n    connection_manager.cleanup_expired_connections(Duration::from_secs(300));\n    let stats_after = connection_manager.get_stats();\n    assert_eq!(stats_after.active_connections, 2); // Should still be there (not expired)\n\n    // Test cleanup with very short timeout\n    connection_manager.cleanup_expired_connections(Duration::from_millis(1));\n    let stats_short = connection_manager.get_stats();\n    assert_eq!(stats_short.active_connections, 2); // Still there (fresh connections)\n}\n\n// ================================\n// SOCKET ADDRESS VALIDATION TESTS\n// ================================\n\n#[test]\nfn test_socket_addr_parsing_comprehensive() {\n    // Test various socket address formats that the server should handle\n    let addrs = [\n        \"127.0.0.1:8080\",\n        \"0.0.0.0:8080\",\n        \"192.168.1.1:8080\",\n        \"[::1]:8080\",\n        \"[::]:8080\",\n        \"[2001:db8::1]:8080\",\n    ];\n\n    for addr_str in addrs {\n        let result = addr_str.parse::<SocketAddr>();\n        assert!(result.is_ok(), \"Failed to parse address: {}\", addr_str);\n\n        let addr = result.unwrap();\n        assert_eq!(addr.port(), 8080);\n    }\n\n    // Test port ranges\n    let port_tests = [\n        (\"127.0.0.1:1\", 1),\n        (\"127.0.0.1:80\", 80),\n        (\"127.0.0.1:443\", 443),\n        (\"127.0.0.1:8080\", 8080),\n        (\"127.0.0.1:50051\", 50051),\n        (\"127.0.0.1:65535\", 65535),\n    ];\n\n    for (addr_str, expected_port) in port_tests {\n        let result = addr_str.parse::<SocketAddr>();\n        assert!(result.is_ok(), \"Failed to parse address: {}\", addr_str);\n        assert_eq!(result.unwrap().port(), expected_port);\n    }\n}\n\n// ================================\n// TRAIT IMPLEMENTATION TESTS\n// ================================\n\n#[test]\nfn test_grpc_server_send_sync() {\n    fn assert_send<T: Send>() {}\n    fn assert_sync<T: Sync>() {}\n\n    assert_send::<GrpcServer>();\n    assert_sync::<GrpcServer>();\n}\n\n// ================================\n// ERROR HANDLING TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_with_edge_case_configs() {\n    // Test with minimal connection limits\n    let mut config = create_test_daemon_config();\n    config.server.max_connections = 1;\n    config.server.connection_timeout_secs = 1;\n\n    let daemon = create_test_daemon_with_config(config).await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    let server = GrpcServer::new(daemon, address);\n\n    // Should still work with minimal limits\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.max_connections, 1);\n    assert_eq!(stats.active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_service_readiness() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that server is ready to serve (all services would be registered)\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.active_connections, 0);\n\n    // Test connection manager is properly initialized for serving\n    let connection_manager = server.connection_manager();\n    assert!(Arc::strong_count(connection_manager) >= 1);\n}\n\n// ================================\n// COMPREHENSIVE INTEGRATION TEST\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_full_lifecycle_simulation() {\n    // Test the complete server lifecycle without actually binding to ports\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test connection manager initialization\n    let initial_stats = server.get_connection_stats();\n    assert_eq!(initial_stats.active_connections, 0);\n    assert_eq!(initial_stats.max_connections, 100);\n\n    // Test connection management operations\n    let connection_manager = server.connection_manager();\n    assert!(connection_manager.register_connection(\"test_client\".to_string()).is_ok());\n\n    let updated_stats = server.get_connection_stats();\n    assert_eq!(updated_stats.active_connections, 1);\n\n    // Test connection cleanup\n    connection_manager.cleanup_expired_connections(Duration::from_secs(300));\n    let final_stats = server.get_connection_stats();\n    assert_eq!(final_stats.active_connections, 1); // Should still be active\n\n    // Test rate limiting\n    let rate_result = connection_manager.check_rate_limit(\"test_client\");\n    assert!(rate_result.is_ok());\n\n    // Test activity updates\n    connection_manager.update_activity(\"test_client\", 100, 50);\n\n    // Test unregistration\n    connection_manager.unregister_connection(\"test_client\");\n    let end_stats = server.get_connection_stats();\n    assert_eq!(end_stats.active_connections, 0);\n}\n\n// ================================\n// CONFIGURATION COVERAGE TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_all_config_paths() {\n    // Test different server configurations to ensure all code paths are covered\n\n    // Standard config\n    let config1 = create_test_daemon_config();\n    let daemon1 = create_test_daemon_with_config(config1).await;\n    let server1 = GrpcServer::new(daemon1, \"127.0.0.1:8080\".parse().unwrap());\n    let stats1 = server1.get_connection_stats();\n    assert_eq!(stats1.max_connections, 100);\n\n    // TLS config\n    let config2 = create_test_daemon_config_with_tls();\n    let daemon2 = create_test_daemon_with_config(config2).await;\n    let server2 = GrpcServer::new(daemon2, \"127.0.0.1:8081\".parse().unwrap());\n    let stats2 = server2.get_connection_stats();\n    assert_eq!(stats2.max_connections, 100);\n\n    // Large limits config\n    let config3 = create_test_daemon_config_large_limits();\n    let daemon3 = create_test_daemon_with_config(config3).await;\n    let server3 = GrpcServer::new(daemon3, \"127.0.0.1:8082\".parse().unwrap());\n    let stats3 = server3.get_connection_stats();\n    assert_eq!(stats3.max_connections, 1000);\n\n    // All servers should start with zero connections\n    assert_eq!(stats1.active_connections, 0);\n    assert_eq!(stats2.active_connections, 0);\n    assert_eq!(stats3.active_connections, 0);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","tests","middleware_simple.rs"],"content":"//! Simple middleware test coverage\n//! Testing the actual APIs that exist in the middleware module\n\nuse workspace_qdrant_daemon::grpc::middleware::*;\nuse std::sync::Arc;\nuse std::time::Duration;\n\n// ================================\n// CONNECTION MANAGER TESTS\n// ================================\n\n#[test]\nfn test_connection_manager_creation() {\n    let manager = ConnectionManager::new(100, 50);\n    let stats = manager.get_stats();\n\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n    assert_eq!(stats.max_connections, 100);\n}\n\n#[test]\nfn test_connection_manager_debug_format() {\n    let manager = ConnectionManager::new(10, 5);\n    let debug_str = format!(\"{:?}\", manager);\n    assert!(debug_str.contains(\"ConnectionManager\"));\n}\n\n#[test]\nfn test_connection_stats_fields() {\n    let manager = ConnectionManager::new(50, 20);\n    let stats = manager.get_stats();\n\n    // Test that all fields are accessible\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.max_connections, 50);\n    assert_eq!(stats.total_requests, 0);\n    assert_eq!(stats.total_bytes_sent, 0);\n    assert_eq!(stats.total_bytes_received, 0);\n}\n\n#[test]\nfn test_connection_stats_clone() {\n    let manager = ConnectionManager::new(30, 15);\n    let original = manager.get_stats();\n    let cloned = original.clone();\n\n    assert_eq!(original.active_connections, cloned.active_connections);\n    assert_eq!(original.max_connections, cloned.max_connections);\n    assert_eq!(original.total_requests, cloned.total_requests);\n    assert_eq!(original.total_bytes_sent, cloned.total_bytes_sent);\n    assert_eq!(original.total_bytes_received, cloned.total_bytes_received);\n}\n\n#[test]\nfn test_connection_stats_debug_format() {\n    let manager = ConnectionManager::new(25, 10);\n    let stats = manager.get_stats();\n\n    let debug_str = format!(\"{:?}\", stats);\n    assert!(debug_str.contains(\"ConnectionStats\"));\n    assert!(debug_str.contains(\"25\")); // max_connections\n}\n\n#[test]\nfn test_connection_manager_register_connection() {\n    let manager = ConnectionManager::new(2, 10);\n\n    // First connection should succeed\n    let result1 = manager.register_connection(\"client1\".to_string());\n    assert!(result1.is_ok());\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Second connection should succeed\n    let result2 = manager.register_connection(\"client2\".to_string());\n    assert!(result2.is_ok());\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 2);\n\n    // Third connection should fail (exceeds limit)\n    let result3 = manager.register_connection(\"client3\".to_string());\n    assert!(result3.is_err());\n}\n\n#[test]\nfn test_connection_manager_unregister_connection() {\n    let manager = ConnectionManager::new(5, 10);\n\n    // Register a connection\n    manager.register_connection(\"test_client\".to_string()).unwrap();\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Unregister the connection\n    manager.unregister_connection(\"test_client\");\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n\n    // Unregistering non-existent connection should not panic\n    manager.unregister_connection(\"non_existent\");\n}\n\n#[test]\nfn test_connection_manager_rate_limiting() {\n    let manager = ConnectionManager::new(10, 2); // 2 requests per second\n\n    // Register a client first\n    manager.register_connection(\"rate_test_client\".to_string()).unwrap();\n\n    // First request should be allowed\n    let result1 = manager.check_rate_limit(\"rate_test_client\");\n    assert!(result1.is_ok());\n\n    // Second request should be allowed\n    let result2 = manager.check_rate_limit(\"rate_test_client\");\n    assert!(result2.is_ok());\n\n    // Third request should be rate limited\n    let result3 = manager.check_rate_limit(\"rate_test_client\");\n    assert!(result3.is_err());\n}\n\n#[test]\nfn test_connection_manager_update_activity() {\n    let manager = ConnectionManager::new(5, 10);\n\n    // Register a connection\n    manager.register_connection(\"activity_client\".to_string()).unwrap();\n\n    // Update activity (should not panic)\n    manager.update_activity(\"activity_client\", 100, 50);\n\n    // Check that the connection still exists\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Update activity for non-existent client (should not panic)\n    manager.update_activity(\"non_existent\", 10, 5);\n}\n\n#[test]\nfn test_connection_manager_cleanup_expired() {\n    let manager = ConnectionManager::new(5, 10);\n\n    // Register a connection\n    manager.register_connection(\"cleanup_client\".to_string()).unwrap();\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Cleanup with very short timeout (should not remove fresh connections)\n    manager.cleanup_expired_connections(Duration::from_millis(1));\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Cleanup with very long timeout (should not remove anything)\n    manager.cleanup_expired_connections(Duration::from_secs(3600));\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n}\n\n// ================================\n// CONNECTION INTERCEPTOR TESTS\n// ================================\n\n#[test]\nfn test_connection_interceptor_creation() {\n    let manager = Arc::new(ConnectionManager::new(10, 5));\n    let interceptor = ConnectionInterceptor::new(manager);\n\n    // Test that we can create it\n    let debug_str = format!(\"{:?}\", interceptor);\n    assert!(debug_str.contains(\"ConnectionInterceptor\"));\n}\n\n#[test]\nfn test_connection_interceptor_clone() {\n    let manager = Arc::new(ConnectionManager::new(10, 5));\n    let interceptor1 = ConnectionInterceptor::new(manager);\n    let interceptor2 = interceptor1.clone();\n\n    // Both should be valid\n    let debug1 = format!(\"{:?}\", interceptor1);\n    let debug2 = format!(\"{:?}\", interceptor2);\n\n    assert!(debug1.contains(\"ConnectionInterceptor\"));\n    assert!(debug2.contains(\"ConnectionInterceptor\"));\n}\n\n// ================================\n// POOL CONFIG TESTS\n// ================================\n\n#[test]\nfn test_pool_config_default() {\n    let config = PoolConfig::default();\n\n    assert_eq!(config.max_size, 10);\n    assert_eq!(config.min_idle, Some(2));\n    assert!(config.max_lifetime.is_some());\n    assert!(config.idle_timeout.is_some());\n    assert!(config.connection_timeout > Duration::from_secs(0));\n}\n\n#[test]\nfn test_pool_config_debug() {\n    let config = PoolConfig::default();\n    let debug_str = format!(\"{:?}\", config);\n\n    assert!(debug_str.contains(\"PoolConfig\"));\n    assert!(debug_str.contains(\"10\")); // max_size\n}\n\n#[test]\nfn test_pool_config_clone() {\n    let original = PoolConfig::default();\n    let cloned = original.clone();\n\n    assert_eq!(original.max_size, cloned.max_size);\n    assert_eq!(original.min_idle, cloned.min_idle);\n    assert_eq!(original.max_lifetime, cloned.max_lifetime);\n    assert_eq!(original.idle_timeout, cloned.idle_timeout);\n    assert_eq!(original.connection_timeout, cloned.connection_timeout);\n}\n\n#[test]\nfn test_pool_config_custom() {\n    let config = PoolConfig {\n        max_size: 20,\n        min_idle: Some(5),\n        max_lifetime: Some(Duration::from_secs(7200)),\n        idle_timeout: Some(Duration::from_secs(1200)),\n        connection_timeout: Duration::from_secs(60),\n    };\n\n    assert_eq!(config.max_size, 20);\n    assert_eq!(config.min_idle, Some(5));\n    assert_eq!(config.max_lifetime, Some(Duration::from_secs(7200)));\n    assert_eq!(config.idle_timeout, Some(Duration::from_secs(1200)));\n    assert_eq!(config.connection_timeout, Duration::from_secs(60));\n}\n\n// ================================\n// INTEGRATION TESTS\n// ================================\n\n#[test]\nfn test_connection_manager_and_interceptor_integration() {\n    let manager = Arc::new(ConnectionManager::new(10, 5));\n    let manager_clone = Arc::clone(&manager);\n    let _interceptor = ConnectionInterceptor::new(manager_clone);\n\n    // Manager should still be functional\n    let result = manager.register_connection(\"integration_client\".to_string());\n    assert!(result.is_ok());\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n}\n\n#[test]\nfn test_multi_client_registration() {\n    let manager = ConnectionManager::new(5, 10);\n    let client_names = vec![\"client1\", \"client2\", \"client3\"];\n\n    for client in &client_names {\n        let result = manager.register_connection(client.to_string());\n        assert!(result.is_ok(), \"Failed to register client: {}\", client);\n    }\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 3);\n\n    // Unregister all clients\n    for client in &client_names {\n        manager.unregister_connection(client);\n    }\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n}\n\n#[test]\nfn test_connection_manager_full_lifecycle() {\n    let manager = ConnectionManager::new(3, 5);\n\n    // Register up to limit\n    for i in 1..=3 {\n        let client_id = format!(\"client{}\", i);\n        let result = manager.register_connection(client_id);\n        assert!(result.is_ok());\n    }\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 3);\n\n    // Try to register beyond limit\n    let result = manager.register_connection(\"overflow_client\".to_string());\n    assert!(result.is_err());\n\n    // Update activity for existing clients\n    manager.update_activity(\"client1\", 100, 50);\n    manager.update_activity(\"client2\", 200, 100);\n\n    // Unregister one client\n    manager.unregister_connection(\"client1\");\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 2);\n\n    // Now we should be able to register a new client\n    let result = manager.register_connection(\"new_client\".to_string());\n    assert!(result.is_ok());\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 3);\n}\n\n// ================================\n// SEND/SYNC TRAIT TESTS\n// ================================\n\n#[test]\nfn test_middleware_components_send_sync() {\n    fn assert_send<T: Send>() {}\n    fn assert_sync<T: Sync>() {}\n\n    assert_send::<ConnectionManager>();\n    assert_sync::<ConnectionManager>();\n    assert_send::<ConnectionStats>();\n    assert_sync::<ConnectionStats>();\n    assert_send::<PoolConfig>();\n    assert_sync::<PoolConfig>();\n    assert_send::<ConnectionInterceptor>();\n    assert_sync::<ConnectionInterceptor>();\n}\n\n// ================================\n// ERROR CONDITION TESTS\n// ================================\n\n#[test]\nfn test_connection_manager_with_zero_max_connections() {\n    let manager = ConnectionManager::new(0, 10);\n\n    // Should immediately fail with zero max connections\n    let result = manager.register_connection(\"test_client\".to_string());\n    assert!(result.is_err());\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.max_connections, 0);\n}\n\n#[test]\nfn test_connection_manager_rate_limiting_with_zero_rate() {\n    let manager = ConnectionManager::new(5, 0); // Zero requests per second\n\n    // Register a client first\n    manager.register_connection(\"zero_rate_client\".to_string()).unwrap();\n\n    // Any request should be rate limited with zero rate\n    let result = manager.check_rate_limit(\"zero_rate_client\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_connection_manager_multiple_managers() {\n    let manager1 = ConnectionManager::new(2, 5);\n    let manager2 = ConnectionManager::new(3, 10);\n\n    // Register clients in different managers\n    assert!(manager1.register_connection(\"client1\".to_string()).is_ok());\n    assert!(manager2.register_connection(\"client2\".to_string()).is_ok());\n\n    // Each manager should track separately\n    assert_eq!(manager1.get_stats().active_connections, 1);\n    assert_eq!(manager2.get_stats().active_connections, 1);\n\n    // Fill up manager1\n    assert!(manager1.register_connection(\"client3\".to_string()).is_ok());\n    assert!(manager1.register_connection(\"client4\".to_string()).is_err()); // Should fail\n\n    // manager2 should still accept connections\n    assert!(manager2.register_connection(\"client5\".to_string()).is_ok());\n}\n\n#[test]\nfn test_connection_interceptor_with_different_managers() {\n    let manager1 = Arc::new(ConnectionManager::new(5, 10));\n    let manager2 = Arc::new(ConnectionManager::new(10, 20));\n\n    let interceptor1 = ConnectionInterceptor::new(manager1);\n    let interceptor2 = ConnectionInterceptor::new(manager2);\n\n    // Both should be valid and independent\n    let debug1 = format!(\"{:?}\", interceptor1);\n    let debug2 = format!(\"{:?}\", interceptor2);\n\n    assert!(debug1.contains(\"ConnectionInterceptor\"));\n    assert!(debug2.contains(\"ConnectionInterceptor\"));\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","tests","simple_error_coverage.rs"],"content":"//! Simple error handling coverage tests\n\nuse workspace_qdrant_daemon::error::*;\nuse std::io::{Error as IoError, ErrorKind};\n\n#[test]\nfn test_daemon_error_creation_and_display() {\n    // Test Config error\n    let config_error = DaemonError::Config(\n        config::ConfigError::Message(\"Invalid configuration\".to_string())\n    );\n    let config_msg = format!(\"{}\", config_error);\n    assert!(config_msg.contains(\"Configuration error\"));\n    assert!(config_msg.contains(\"Invalid configuration\"));\n\n    // Test IO error\n    let io_error = DaemonError::Io(IoError::new(ErrorKind::NotFound, \"File not found\"));\n    let io_msg = format!(\"{}\", io_error);\n    assert!(io_msg.contains(\"I/O error\"));\n    assert!(io_msg.contains(\"File not found\"));\n\n    // Test Database error\n    let db_error = DaemonError::Database(sqlx::Error::PoolClosed);\n    let db_msg = format!(\"{}\", db_error);\n    assert!(db_msg.contains(\"Database error\"));\n\n    // Test Document Processing error\n    let proc_error = DaemonError::DocumentProcessing {\n        message: \"Failed to process document\".to_string()\n    };\n    let proc_msg = format!(\"{}\", proc_error);\n    assert!(proc_msg.contains(\"Document processing error\"));\n    assert!(proc_msg.contains(\"Failed to process document\"));\n\n    // Test Search error\n    let search_error = DaemonError::Search {\n        message: \"Search failed\".to_string()\n    };\n    let search_msg = format!(\"{}\", search_error);\n    assert!(search_msg.contains(\"Search error\"));\n    assert!(search_msg.contains(\"Search failed\"));\n\n    // Test Memory error\n    let memory_error = DaemonError::Memory {\n        message: \"Memory operation failed\".to_string()\n    };\n    let memory_msg = format!(\"{}\", memory_error);\n    assert!(memory_msg.contains(\"Memory management error\"));\n    assert!(memory_msg.contains(\"Memory operation failed\"));\n\n    // Test System error\n    let system_error = DaemonError::System {\n        message: \"System call failed\".to_string()\n    };\n    let system_msg = format!(\"{}\", system_error);\n    assert!(system_msg.contains(\"System error\"));\n    assert!(system_msg.contains(\"System call failed\"));\n}\n\n#[test]\nfn test_daemon_error_debug() {\n    let error = DaemonError::DocumentProcessing {\n        message: \"Test error\".to_string()\n    };\n    let debug_str = format!(\"{:?}\", error);\n    assert!(debug_str.contains(\"DocumentProcessing\"));\n    assert!(debug_str.contains(\"Test error\"));\n}\n\n#[test]\nfn test_daemon_error_from_conversions() {\n    // Test From<std::io::Error>\n    let io_error = IoError::new(ErrorKind::PermissionDenied, \"Permission denied\");\n    let daemon_error: DaemonError = io_error.into();\n    match daemon_error {\n        DaemonError::Io(e) => {\n            assert_eq!(e.kind(), ErrorKind::PermissionDenied);\n        },\n        _ => panic!(\"Expected IO error conversion\"),\n    }\n\n    // Test From<config::ConfigError>\n    let config_error = config::ConfigError::Message(\"Invalid config\".to_string());\n    let daemon_error: DaemonError = config_error.into();\n    match daemon_error {\n        DaemonError::Config(_) => {\n            // Expected conversion\n        },\n        _ => panic!(\"Expected Config error conversion\"),\n    }\n\n    // Test From<sqlx::Error>\n    let sql_error = sqlx::Error::RowNotFound;\n    let daemon_error: DaemonError = sql_error.into();\n    match daemon_error {\n        DaemonError::Database(_) => {\n            // Expected conversion\n        },\n        _ => panic!(\"Expected Database error conversion\"),\n    }\n}\n\n#[test]\nfn test_daemon_error_std_error_trait() {\n    let error = DaemonError::DocumentProcessing {\n        message: \"Test processing error\".to_string()\n    };\n\n    // Test that it implements std::error::Error\n    let std_error: &dyn std::error::Error = &error;\n    assert!(std_error.to_string().contains(\"Document processing error\"));\n}\n\n#[test]\nfn test_daemon_error_chain() {\n    // Create a chain of errors to test error handling\n    let io_error = IoError::new(ErrorKind::NotFound, \"Config file not found\");\n    let daemon_error = DaemonError::Io(io_error);\n\n    let error_string = format!(\"{}\", daemon_error);\n    assert!(error_string.contains(\"I/O error\"));\n    assert!(error_string.contains(\"Config file not found\"));\n}\n\n#[test]\nfn test_daemon_result_type() {\n    // Test successful result\n    let success: DaemonResult<i32> = Ok(42);\n    assert_eq!(success.unwrap(), 42);\n\n    // Test error result\n    let error: DaemonResult<i32> = Err(DaemonError::DocumentProcessing {\n        message: \"Test error\".to_string()\n    });\n    assert!(error.is_err());\n\n    match error {\n        Err(DaemonError::DocumentProcessing { message }) => {\n            assert_eq!(message, \"Test error\");\n        },\n        _ => panic!(\"Expected document processing error\"),\n    }\n}\n\n#[test]\nfn test_daemon_error_send_sync() {\n    fn assert_send<T: Send>() {}\n    fn assert_sync<T: Sync>() {}\n\n    assert_send::<DaemonError>();\n    assert_sync::<DaemonError>();\n}\n\n#[test]\nfn test_all_structured_error_variants() {\n    // Test all the structured error variants\n    let errors = vec![\n        DaemonError::DocumentProcessing { message: \"test\".to_string() },\n        DaemonError::Search { message: \"test\".to_string() },\n        DaemonError::Memory { message: \"test\".to_string() },\n        DaemonError::System { message: \"test\".to_string() },\n        DaemonError::ProjectDetection { message: \"test\".to_string() },\n        DaemonError::ConnectionPool { message: \"test\".to_string() },\n        DaemonError::Timeout { seconds: 30 },\n        DaemonError::NotFound { resource: \"document\".to_string() },\n        DaemonError::InvalidInput { message: \"invalid data\".to_string() },\n        DaemonError::Internal { message: \"internal error\".to_string() },\n    ];\n\n    for error in errors {\n        // Each error should be debuggable\n        let debug_str = format!(\"{:?}\", error);\n        assert!(!debug_str.is_empty());\n\n        // Each error should be displayable\n        let display_str = format!(\"{}\", error);\n        assert!(!display_str.is_empty());\n\n        // Each error should convert to Status\n        let _status: tonic::Status = error.into();\n    }\n}\n\n#[test]\nfn test_timeout_error() {\n    let timeout_error = DaemonError::Timeout { seconds: 60 };\n    let msg = format!(\"{}\", timeout_error);\n    assert!(msg.contains(\"Timeout error\"));\n    assert!(msg.contains(\"60s\"));\n}\n\n#[test]\nfn test_not_found_error() {\n    let not_found_error = DaemonError::NotFound {\n        resource: \"collection\".to_string()\n    };\n    let msg = format!(\"{}\", not_found_error);\n    assert!(msg.contains(\"Resource not found\"));\n    assert!(msg.contains(\"collection\"));\n}\n\n#[test]\nfn test_error_to_status_conversion() {\n    // Test InvalidInput -> InvalidArgument\n    let invalid_input = DaemonError::InvalidInput {\n        message: \"Bad input\".to_string()\n    };\n    let status: tonic::Status = invalid_input.into();\n    assert_eq!(status.code(), tonic::Code::InvalidArgument);\n\n    // Test NotFound -> NotFound\n    let not_found = DaemonError::NotFound {\n        resource: \"user\".to_string()\n    };\n    let status: tonic::Status = not_found.into();\n    assert_eq!(status.code(), tonic::Code::NotFound);\n\n    // Test Timeout -> DeadlineExceeded\n    let timeout = DaemonError::Timeout { seconds: 30 };\n    let status: tonic::Status = timeout.into();\n    assert_eq!(status.code(), tonic::Code::DeadlineExceeded);\n\n    // Test IO -> Internal\n    let io_error = DaemonError::Io(IoError::new(ErrorKind::NotFound, \"File not found\"));\n    let status: tonic::Status = io_error.into();\n    assert_eq!(status.code(), tonic::Code::Internal);\n}\n\n#[test]\nfn test_error_equality_and_comparison() {\n    // Test that we can compare error messages\n    let error1 = DaemonError::DocumentProcessing {\n        message: \"Same message\".to_string()\n    };\n    let error2 = DaemonError::DocumentProcessing {\n        message: \"Same message\".to_string()\n    };\n    let error3 = DaemonError::DocumentProcessing {\n        message: \"Different message\".to_string()\n    };\n\n    // Test string representation equality\n    assert_eq!(format!(\"{}\", error1), format!(\"{}\", error2));\n    assert_ne!(format!(\"{}\", error1), format!(\"{}\", error3));\n\n    // Test that different error types produce different strings\n    let search_error = DaemonError::Search {\n        message: \"Same message\".to_string()\n    };\n    assert_ne!(format!(\"{}\", error1), format!(\"{}\", search_error));\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","tests","test_daemon_processing.rs"],"content":"//! Comprehensive unit tests for daemon/processing.rs module\n//! Tests DocumentProcessor and related functions with proven file-by-file methodology\n\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse workspace_qdrant_daemon::config::{ProcessingConfig, QdrantConfig, CollectionConfig};\nuse workspace_qdrant_daemon::daemon::processing::DocumentProcessor;\nuse workspace_qdrant_daemon::error::DaemonResult;\n\n/// Configuration module for test setup\n#[cfg(test)]\nmod test_config {\n    use super::*;\n\n    /// Create a standard test processing configuration\n    pub fn create_test_processing_config() -> ProcessingConfig {\n        ProcessingConfig {\n            max_concurrent_tasks: 2,\n            default_chunk_size: 1000,\n            default_chunk_overlap: 200,\n            max_file_size_bytes: 1024 * 1024, // 1MB\n            supported_extensions: vec![\n                \"rs\".to_string(),\n                \"py\".to_string(),\n                \"md\".to_string(),\n                \"txt\".to_string(),\n            ],\n            enable_lsp: true,\n            lsp_timeout_secs: 10,\n        }\n    }\n\n    /// Create a variant processing configuration for testing different values\n    pub fn create_variant_processing_config() -> ProcessingConfig {\n        ProcessingConfig {\n            max_concurrent_tasks: 4,\n            default_chunk_size: 2000,\n            default_chunk_overlap: 400,\n            max_file_size_bytes: 10 * 1024 * 1024, // 10MB\n            supported_extensions: vec![\n                \"js\".to_string(),\n                \"ts\".to_string(),\n                \"json\".to_string(),\n            ],\n            enable_lsp: false,\n            lsp_timeout_secs: 20,\n        }\n    }\n\n    /// Create a minimal processing configuration for edge testing\n    pub fn create_minimal_processing_config() -> ProcessingConfig {\n        ProcessingConfig {\n            max_concurrent_tasks: 1,\n            default_chunk_size: 100,\n            default_chunk_overlap: 20,\n            max_file_size_bytes: 1024, // 1KB\n            supported_extensions: vec![\"txt\".to_string()],\n            enable_lsp: false,\n            lsp_timeout_secs: 5,\n        }\n    }\n\n    /// Create a standard test qdrant configuration\n    pub fn create_test_qdrant_config() -> QdrantConfig {\n        QdrantConfig {\n            url: \"http://localhost:6333\".to_string(),\n            api_key: None,\n            timeout_secs: 30,\n            max_retries: 3,\n            default_collection: CollectionConfig {\n                vector_size: 384,\n                distance_metric: \"Cosine\".to_string(),\n                enable_indexing: true,\n                replication_factor: 1,\n                shard_number: 1,\n            },\n        }\n    }\n\n    /// Create a qdrant configuration with API key for testing\n    pub fn create_qdrant_config_with_key() -> QdrantConfig {\n        QdrantConfig {\n            url: \"https://remote-qdrant.example.com:6333\".to_string(),\n            api_key: Some(\"test-api-key-12345\".to_string()),\n            timeout_secs: 60,\n            max_retries: 5,\n            default_collection: CollectionConfig {\n                vector_size: 768,\n                distance_metric: \"Euclidean\".to_string(),\n                enable_indexing: false,\n                replication_factor: 2,\n                shard_number: 3,\n            },\n        }\n    }\n\n    /// Create an alternative qdrant configuration\n    pub fn create_alternative_qdrant_config() -> QdrantConfig {\n        QdrantConfig {\n            url: \"http://test-qdrant:6334\".to_string(),\n            api_key: Some(\"alternative-key\".to_string()),\n            timeout_secs: 45,\n            max_retries: 2,\n            default_collection: CollectionConfig {\n                vector_size: 512,\n                distance_metric: \"Dot\".to_string(),\n                enable_indexing: true,\n                replication_factor: 3,\n                shard_number: 2,\n            },\n        }\n    }\n}\n\n/// Basic DocumentProcessor creation and configuration tests\n#[cfg(test)]\nmod basic_creation_tests {\n    use super::*;\n    use super::test_config::*;\n\n    #[tokio::test]\n    async fn test_document_processor_creation_standard_config() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        // Verify configuration is properly stored\n        assert_eq!(processor.config().max_concurrent_tasks, 2);\n        assert_eq!(processor.config().default_chunk_size, 1000);\n        assert_eq!(processor.config().default_chunk_overlap, 200);\n        assert_eq!(processor.config().max_file_size_bytes, 1024 * 1024);\n        assert_eq!(processor.config().supported_extensions.len(), 4);\n        assert!(processor.config().supported_extensions.contains(&\"rs\".to_string()));\n        assert!(processor.config().supported_extensions.contains(&\"py\".to_string()));\n        assert!(processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 10);\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_creation_variant_config() {\n        let processing_config = create_variant_processing_config();\n        let qdrant_config = create_qdrant_config_with_key();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor with variant config\");\n\n        // Verify variant configuration values\n        assert_eq!(processor.config().max_concurrent_tasks, 4);\n        assert_eq!(processor.config().default_chunk_size, 2000);\n        assert_eq!(processor.config().default_chunk_overlap, 400);\n        assert_eq!(processor.config().max_file_size_bytes, 10 * 1024 * 1024);\n        assert_eq!(processor.config().supported_extensions.len(), 3);\n        assert!(processor.config().supported_extensions.contains(&\"js\".to_string()));\n        assert!(processor.config().supported_extensions.contains(&\"ts\".to_string()));\n        assert!(processor.config().supported_extensions.contains(&\"json\".to_string()));\n        assert!(!processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 20);\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_creation_minimal_config() {\n        let processing_config = create_minimal_processing_config();\n        let qdrant_config = create_alternative_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor with minimal config\");\n\n        // Verify minimal configuration values\n        assert_eq!(processor.config().max_concurrent_tasks, 1);\n        assert_eq!(processor.config().default_chunk_size, 100);\n        assert_eq!(processor.config().default_chunk_overlap, 20);\n        assert_eq!(processor.config().max_file_size_bytes, 1024);\n        assert_eq!(processor.config().supported_extensions.len(), 1);\n        assert!(processor.config().supported_extensions.contains(&\"txt\".to_string()));\n        assert!(!processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 5);\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_debug_format() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor for debug test\");\n\n        // Test debug formatting\n        let debug_str = format!(\"{:?}\", processor);\n        assert!(debug_str.contains(\"DocumentProcessor\"));\n        assert!(!debug_str.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_config_access() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor for config access test\");\n\n        // Test config access returns correct reference\n        let config = processor.config();\n        assert_eq!(config.max_concurrent_tasks, processing_config.max_concurrent_tasks);\n        assert_eq!(config.default_chunk_size, processing_config.default_chunk_size);\n        assert_eq!(config.default_chunk_overlap, processing_config.default_chunk_overlap);\n        assert_eq!(config.max_file_size_bytes, processing_config.max_file_size_bytes);\n        assert_eq!(config.supported_extensions, processing_config.supported_extensions);\n        assert_eq!(config.enable_lsp, processing_config.enable_lsp);\n        assert_eq!(config.lsp_timeout_secs, processing_config.lsp_timeout_secs);\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_multiple_configs() {\n        let config1 = create_test_processing_config();\n        let config2 = create_variant_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor1 = DocumentProcessor::new(&config1, &qdrant_config)\n            .await\n            .expect(\"Failed to create first DocumentProcessor\");\n\n        let processor2 = DocumentProcessor::new(&config2, &qdrant_config)\n            .await\n            .expect(\"Failed to create second DocumentProcessor\");\n\n        // Verify processors have different configurations\n        assert_ne!(processor1.config().max_concurrent_tasks, processor2.config().max_concurrent_tasks);\n        assert_ne!(processor1.config().default_chunk_size, processor2.config().default_chunk_size);\n        assert_ne!(processor1.config().supported_extensions, processor2.config().supported_extensions);\n    }\n}\n\n/// Document processing workflow tests\n#[cfg(test)]\nmod document_processing_tests {\n    use super::*;\n    use super::test_config::*;\n\n    #[tokio::test]\n    async fn test_process_single_document_success() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        let result = processor.process_document(\"test_file.rs\").await;\n        assert!(result.is_ok(), \"Document processing should succeed\");\n\n        let document_id = result.unwrap();\n        // UUID v4 is 36 characters with 4 hyphens\n        assert_eq!(document_id.len(), 36);\n        assert_eq!(document_id.matches('-').count(), 4);\n        \n        // Verify it's a valid UUID format\n        assert!(uuid::Uuid::parse_str(&document_id).is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_process_multiple_different_files() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        let test_files = vec![\n            \"main.rs\",\n            \"script.py\", \n            \"README.md\",\n            \"config.txt\",\n            \"data.json\",\n            \"index.html\",\n            \"style.css\",\n        ];\n\n        let mut results = Vec::new();\n        for file in &test_files {\n            let result = processor.process_document(file).await;\n            assert!(result.is_ok(), \"Failed to process file: {}\", file);\n            results.push(result.unwrap());\n        }\n\n        // All results should be valid UUIDs\n        for (i, result) in results.iter().enumerate() {\n            assert_eq!(result.len(), 36, \"Invalid UUID length for file: {}\", test_files[i]);\n            assert!(uuid::Uuid::parse_str(result).is_ok(), \"Invalid UUID format for file: {}\", test_files[i]);\n        }\n\n        // All UUIDs should be unique\n        for i in 0..results.len() {\n            for j in (i + 1)..results.len() {\n                assert_ne!(results[i], results[j], \"UUIDs should be unique\");\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_process_document_with_special_characters() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        let special_files = vec![\n            \"file with spaces.txt\",\n            \"file-with-dashes.md\",\n            \"file_with_underscores.py\",\n            \"file.with.dots.rs\",\n            \"file@with@symbols.txt\",\n            \"файл-с-unicode.txt\", // Cyrillic characters\n            \"文件.txt\", // Chinese characters\n        ];\n\n        for file in &special_files {\n            let result = processor.process_document(file).await;\n            assert!(result.is_ok(), \"Failed to process file with special characters: {}\", file);\n            \n            let document_id = result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(&document_id).is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_process_document_with_long_path() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        // Create a very long file path\n        let long_path = format!(\n            \"{}/test_file.rs\",\n            \"very/deep/nested/directory/structure/with/many/levels/of/subdirectories/that/goes/on/and/on/and/on/for/a/very/long/time/to/test/edge/cases\"\n        );\n\n        let result = processor.process_document(&long_path).await;\n        assert!(result.is_ok(), \"Should handle long file paths\");\n        \n        let document_id = result.unwrap();\n        assert_eq!(document_id.len(), 36);\n        assert!(uuid::Uuid::parse_str(&document_id).is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_process_document_empty_filename() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        let result = processor.process_document(\"\").await;\n        assert!(result.is_ok(), \"Should handle empty filename\");\n        \n        let document_id = result.unwrap();\n        assert_eq!(document_id.len(), 36);\n        assert!(uuid::Uuid::parse_str(&document_id).is_ok());\n    }\n}\n\n/// Concurrent processing and semaphore tests\n#[cfg(test)]\nmod concurrency_tests {\n    use super::*;\n    use super::test_config::*;\n    use tokio::time::Duration;\n\n    #[tokio::test]\n    async fn test_concurrent_processing_within_limits() {\n        let processing_config = create_test_processing_config(); // max_concurrent_tasks = 2\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let mut handles = vec![];\n        let start_time = Instant::now();\n\n        // Spawn 4 tasks (more than the limit of 2)\n        for i in 0..4 {\n            let processor_clone = Arc::clone(&processor);\n            let handle = tokio::spawn(async move {\n                processor_clone\n                    .process_document(&format!(\"concurrent_test_{}.rs\", i))\n                    .await\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all tasks to complete\n        let results = futures_util::future::join_all(handles).await;\n        let elapsed = start_time.elapsed();\n\n        // All tasks should complete successfully\n        for (i, result) in results.iter().enumerate() {\n            let task_result = result.as_ref().expect(&format!(\"Task {} panicked\", i));\n            assert!(task_result.is_ok(), \"Task {} failed: {:?}\", i, task_result);\n            \n            let document_id = task_result.as_ref().unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(document_id).is_ok());\n        }\n\n        // With max_concurrent_tasks = 2 and 4 tasks taking ~100ms each,\n        // total time should be at least 200ms (two batches)\n        assert!(elapsed >= Duration::from_millis(180), \"Tasks should be limited by semaphore, elapsed: {:?}\", elapsed);\n    }\n\n    #[tokio::test]\n    async fn test_sequential_processing_with_single_limit() {\n        let mut processing_config = create_minimal_processing_config();\n        processing_config.max_concurrent_tasks = 1; // Force sequential processing\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let start_time = Instant::now();\n        let task_count = 3;\n        let mut handles = vec![];\n\n        // Spawn multiple tasks that should run sequentially\n        for i in 0..task_count {\n            let processor_clone = Arc::clone(&processor);\n            let handle = tokio::spawn(async move {\n                processor_clone\n                    .process_document(&format!(\"sequential_test_{}.rs\", i))\n                    .await\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n        let elapsed = start_time.elapsed();\n\n        // All tasks should succeed\n        for (i, result) in results.iter().enumerate() {\n            let task_result = result.as_ref().expect(&format!(\"Task {} panicked\", i));\n            assert!(task_result.is_ok(), \"Task {} failed\", i);\n        }\n\n        // With 3 tasks running sequentially, each taking ~100ms, total should be ~300ms\n        assert!(elapsed >= Duration::from_millis(250), \"Sequential tasks should take longer, elapsed: {:?}\", elapsed);\n    }\n\n    #[tokio::test]\n    async fn test_high_concurrency_processing() {\n        let mut processing_config = create_variant_processing_config();\n        processing_config.max_concurrent_tasks = 8; // High concurrency\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let task_count = 16;\n        let mut handles = vec![];\n        let start_time = Instant::now();\n\n        // Spawn many concurrent tasks\n        for i in 0..task_count {\n            let processor_clone = Arc::clone(&processor);\n            let handle = tokio::spawn(async move {\n                processor_clone\n                    .process_document(&format!(\"high_concurrency_test_{}.rs\", i))\n                    .await\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n        let elapsed = start_time.elapsed();\n\n        // All tasks should succeed\n        for (i, result) in results.iter().enumerate() {\n            let task_result = result.as_ref().expect(&format!(\"Task {} panicked\", i));\n            assert!(task_result.is_ok(), \"Task {} failed\", i);\n        }\n\n        // With high concurrency (8), 16 tasks should complete faster than sequential\n        // Should complete in roughly 2 batches: ~200ms\n        assert!(elapsed <= Duration::from_millis(400), \"High concurrency should be faster, elapsed: {:?}\", elapsed);\n    }\n\n    #[tokio::test]\n    async fn test_semaphore_limits_concurrent_execution() {\n        let processing_config = create_test_processing_config(); // max_concurrent_tasks = 2\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let start_time = Instant::now();\n        let task_count = 4;\n        let mut handles = vec![];\n\n        // Spawn multiple tasks that should be limited by the semaphore\n        for i in 0..task_count {\n            let processor_clone = Arc::clone(&processor);\n            let handle = tokio::spawn(async move {\n                let start = Instant::now();\n                let result = processor_clone\n                    .process_document(&format!(\"semaphore_limit_test_{}.rs\", i))\n                    .await;\n                let elapsed = start.elapsed();\n                (i, result, elapsed)\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n        let total_elapsed = start_time.elapsed();\n\n        // All tasks should succeed\n        for result in &results {\n            let (task_id, process_result, _) = result.as_ref().expect(\"Task should not panic\");\n            assert!(process_result.is_ok(), \"Task {} failed\", task_id);\n        }\n\n        // With max_concurrent_tasks = 2 and 4 tasks, execution should take longer\n        // than if all tasks ran concurrently (which would be ~100ms)\n        // It should take at least 200ms (two batches of concurrent execution)\n        assert!(total_elapsed >= Duration::from_millis(180),\n            \"Semaphore should limit concurrency, total time: {:?}\", total_elapsed);\n\n        // Verify all UUIDs are valid and unique\n        let mut document_ids = vec![];\n        for result in results {\n            let (_, process_result, _) = result.expect(\"Task should not panic\");\n            let document_id = process_result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(&document_id).is_ok());\n            document_ids.push(document_id);\n        }\n\n        // All UUIDs should be unique\n        for i in 0..document_ids.len() {\n            for j in (i + 1)..document_ids.len() {\n                assert_ne!(document_ids[i], document_ids[j], \"All UUIDs should be unique\");\n            }\n        }\n    }\n}\n\n/// Error handling and edge case tests\n#[cfg(test)]\nmod error_handling_tests {\n    use super::*;\n    use super::test_config::*;\n\n    #[tokio::test]\n    async fn test_process_document_timing_consistency() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&processing_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        let mut durations = vec![];\n        \n        // Process the same document multiple times to check timing consistency\n        for i in 0..5 {\n            let start = Instant::now();\n            let result = processor.process_document(&format!(\"timing_test_{}.rs\", i)).await;\n            let duration = start.elapsed();\n            \n            assert!(result.is_ok(), \"Document processing should succeed\");\n            durations.push(duration);\n        }\n\n        // All processing times should be reasonably consistent (within a range)\n        // Current implementation sleeps for 100ms, so durations should be around that\n        for (i, duration) in durations.iter().enumerate() {\n            assert!(\n                duration >= &Duration::from_millis(95) && duration <= &Duration::from_millis(150),\n                \"Duration {} ({:?}) is outside expected range\", i, duration\n            );\n        }\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_stress_test() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let stress_test_count = 20;\n        let mut handles = vec![];\n\n        // Create many concurrent tasks to stress test the processor\n        for i in 0..stress_test_count {\n            let processor_clone = Arc::clone(&processor);\n            let handle = tokio::spawn(async move {\n                // Process multiple documents per task\n                let mut results = vec![];\n                for j in 0..3 {\n                    let file_path = format!(\"stress_test_{}_{}.rs\", i, j);\n                    let result = processor_clone.process_document(&file_path).await;\n                    results.push((file_path, result));\n                }\n                results\n            });\n            handles.push(handle);\n        }\n\n        let task_results = futures_util::future::join_all(handles).await;\n\n        // Verify all stress test tasks completed successfully\n        let mut total_processed = 0;\n        for (task_id, task_result) in task_results.iter().enumerate() {\n            let document_results = task_result.as_ref().expect(&format!(\"Stress test task {} panicked\", task_id));\n            \n            for (file_path, result) in document_results {\n                assert!(result.is_ok(), \"Failed to process {} in stress test\", file_path);\n                total_processed += 1;\n                \n                let document_id = result.as_ref().unwrap();\n                assert_eq!(document_id.len(), 36);\n                assert!(uuid::Uuid::parse_str(document_id).is_ok());\n            }\n        }\n\n        assert_eq!(total_processed, stress_test_count * 3, \"Not all documents were processed\");\n    }\n\n    #[tokio::test]\n    async fn test_processor_with_extreme_configurations() {\n        // Test with extremely small configuration\n        let mut tiny_config = create_minimal_processing_config();\n        tiny_config.max_concurrent_tasks = 1;\n        tiny_config.default_chunk_size = 1;\n        tiny_config.default_chunk_overlap = 0;\n        tiny_config.max_file_size_bytes = 1;\n        tiny_config.lsp_timeout_secs = 1;\n        \n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&tiny_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor with tiny config\");\n\n        assert_eq!(processor.config().max_concurrent_tasks, 1);\n        assert_eq!(processor.config().default_chunk_size, 1);\n        assert_eq!(processor.config().default_chunk_overlap, 0);\n        assert_eq!(processor.config().max_file_size_bytes, 1);\n        assert_eq!(processor.config().lsp_timeout_secs, 1);\n\n        // Should still be able to process documents\n        let result = processor.process_document(\"tiny_test.txt\").await;\n        assert!(result.is_ok());\n\n        // Test with extremely large configuration\n        let mut huge_config = create_variant_processing_config();\n        huge_config.max_concurrent_tasks = 1000;\n        huge_config.default_chunk_size = 1_000_000;\n        huge_config.default_chunk_overlap = 100_000;\n        huge_config.max_file_size_bytes = 1_000_000_000;\n        huge_config.lsp_timeout_secs = 3600;\n\n        let processor = DocumentProcessor::new(&huge_config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor with huge config\");\n\n        assert_eq!(processor.config().max_concurrent_tasks, 1000);\n        assert_eq!(processor.config().default_chunk_size, 1_000_000);\n        assert_eq!(processor.config().default_chunk_overlap, 100_000);\n        assert_eq!(processor.config().max_file_size_bytes, 1_000_000_000);\n        assert_eq!(processor.config().lsp_timeout_secs, 3600);\n\n        // Should still be able to process documents\n        let result = processor.process_document(\"huge_test.txt\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_processor_with_empty_extensions_list() {\n        let mut config = create_test_processing_config();\n        config.supported_extensions = vec![]; // Empty extensions list\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(&config, &qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor with empty extensions\");\n\n        assert!(processor.config().supported_extensions.is_empty());\n\n        // Should still process documents even with empty extensions list\n        let result = processor.process_document(\"file_without_extension\").await;\n        assert!(result.is_ok());\n\n        let result = processor.process_document(\"file.unknown_extension\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_processor_config_independence() {\n        let config1 = create_test_processing_config();\n        let config2 = create_variant_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor1 = DocumentProcessor::new(&config1, &qdrant_config)\n            .await\n            .expect(\"Failed to create first DocumentProcessor\");\n        \n        let processor2 = DocumentProcessor::new(&config2, &qdrant_config)\n            .await\n            .expect(\"Failed to create second DocumentProcessor\");\n\n        // Processors should have independent configurations\n        assert_ne!(processor1.config().max_concurrent_tasks, processor2.config().max_concurrent_tasks);\n        assert_ne!(processor1.config().default_chunk_size, processor2.config().default_chunk_size);\n        assert_ne!(processor1.config().supported_extensions, processor2.config().supported_extensions);\n        assert_ne!(processor1.config().enable_lsp, processor2.config().enable_lsp);\n\n        // Both should process documents independently\n        let result1 = processor1.process_document(\"independent_test_1.rs\").await;\n        let result2 = processor2.process_document(\"independent_test_2.js\").await;\n        \n        assert!(result1.is_ok());\n        assert!(result2.is_ok());\n        assert_ne!(result1.unwrap(), result2.unwrap()); // Different UUIDs\n    }\n}\n\n/// Configuration cloning and thread safety tests\n#[cfg(test)]\nmod thread_safety_tests {\n    use super::*;\n    use super::test_config::*;\n\n    #[test]\n    fn test_config_structs_are_send_sync() {\n        fn assert_send_sync<T: Send + Sync>() {}\n\n        // Verify all config types are Send + Sync\n        assert_send_sync::<ProcessingConfig>();\n        assert_send_sync::<QdrantConfig>();\n        assert_send_sync::<CollectionConfig>();\n    }\n\n    #[test]\n    fn test_processing_config_clone_equality() {\n        let config = create_test_processing_config();\n        let cloned = config.clone();\n\n        assert_eq!(config.max_concurrent_tasks, cloned.max_concurrent_tasks);\n        assert_eq!(config.default_chunk_size, cloned.default_chunk_size);\n        assert_eq!(config.default_chunk_overlap, cloned.default_chunk_overlap);\n        assert_eq!(config.max_file_size_bytes, cloned.max_file_size_bytes);\n        assert_eq!(config.supported_extensions, cloned.supported_extensions);\n        assert_eq!(config.enable_lsp, cloned.enable_lsp);\n        assert_eq!(config.lsp_timeout_secs, cloned.lsp_timeout_secs);\n    }\n\n    #[test]\n    fn test_qdrant_config_clone_equality() {\n        let config = create_test_qdrant_config();\n        let cloned = config.clone();\n\n        assert_eq!(config.url, cloned.url);\n        assert_eq!(config.api_key, cloned.api_key);\n        assert_eq!(config.timeout_secs, cloned.timeout_secs);\n        assert_eq!(config.max_retries, cloned.max_retries);\n        assert_eq!(config.default_collection.vector_size, cloned.default_collection.vector_size);\n        assert_eq!(config.default_collection.distance_metric, cloned.default_collection.distance_metric);\n        assert_eq!(config.default_collection.enable_indexing, cloned.default_collection.enable_indexing);\n        assert_eq!(config.default_collection.replication_factor, cloned.default_collection.replication_factor);\n        assert_eq!(config.default_collection.shard_number, cloned.default_collection.shard_number);\n    }\n\n    #[test]\n    fn test_config_debug_formatting() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processing_debug = format!(\"{:?}\", processing_config);\n        assert!(processing_debug.contains(\"ProcessingConfig\"));\n        assert!(processing_debug.contains(&processing_config.max_concurrent_tasks.to_string()));\n        assert!(processing_debug.contains(&processing_config.default_chunk_size.to_string()));\n\n        let qdrant_debug = format!(\"{:?}\", qdrant_config);\n        assert!(qdrant_debug.contains(\"QdrantConfig\"));\n        assert!(qdrant_debug.contains(&qdrant_config.url));\n        assert!(qdrant_debug.contains(&qdrant_config.timeout_secs.to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_processor_across_tokio_tasks() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        // Spawn multiple tokio tasks that use the same processor\n        let mut handles = vec![];\n        for i in 0..5 {\n            let processor_clone = Arc::clone(&processor);\n            let handle = tokio::spawn(async move {\n                let file_path = format!(\"tokio_task_test_{}.rs\", i);\n                let result = processor_clone.process_document(&file_path).await;\n                (i, result)\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n\n        // All tasks should complete successfully\n        for result in results {\n            let (task_id, process_result) = result.expect(\"Task should not panic\");\n            assert!(process_result.is_ok(), \"Task {} should succeed\", task_id);\n            \n            let document_id = process_result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(&document_id).is_ok());\n        }\n    }\n\n    #[test]\n    fn test_config_modification_independence() {\n        let mut config1 = create_test_processing_config();\n        let config2 = config1.clone();\n\n        // Modify config1\n        config1.max_concurrent_tasks = 999;\n        config1.default_chunk_size = 999;\n        config1.enable_lsp = !config1.enable_lsp;\n        config1.supported_extensions.push(\"modified\".to_string());\n\n        // config2 should remain unchanged\n        assert_ne!(config1.max_concurrent_tasks, config2.max_concurrent_tasks);\n        assert_ne!(config1.default_chunk_size, config2.default_chunk_size);\n        assert_ne!(config1.enable_lsp, config2.enable_lsp);\n        assert!(!config2.supported_extensions.contains(&\"modified\".to_string()));\n    }\n}\n\n/// Batch processing and performance tests\n#[cfg(test)]\nmod batch_processing_tests {\n    use super::*;\n    use super::test_config::*;\n\n    #[tokio::test]\n    async fn test_batch_processing_different_file_types() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        // Create a batch of different file types\n        let file_batch = vec![\n            (\"src/main.rs\", \"rust\"),\n            (\"scripts/deploy.py\", \"python\"),\n            (\"docs/README.md\", \"markdown\"),\n            (\"config/settings.txt\", \"text\"),\n            (\"frontend/index.html\", \"html\"),\n            (\"styles/main.css\", \"css\"),\n            (\"data/config.json\", \"json\"),\n            (\"scripts/build.sh\", \"shell\"),\n        ];\n\n        let mut handles = vec![];\n        for (file_path, file_type) in &file_batch {\n            let processor_clone = Arc::clone(&processor);\n            let file_path = file_path.to_string();\n            let file_type = file_type.to_string();\n            \n            let handle = tokio::spawn(async move {\n                let result = processor_clone.process_document(&file_path).await;\n                (file_path, file_type, result)\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n\n        // Verify all files were processed successfully\n        for result in results {\n            let (file_path, file_type, process_result) = result.expect(\"Task should not panic\");\n            assert!(process_result.is_ok(), \"Failed to process {} file: {}\", file_type, file_path);\n            \n            let document_id = process_result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(&document_id).is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_large_batch_processing_performance() {\n        let mut processing_config = create_variant_processing_config();\n        processing_config.max_concurrent_tasks = 6; // Reasonable concurrency for performance test\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let batch_size = 30;\n        let start_time = Instant::now();\n        let mut handles = vec![];\n\n        // Process a large batch of documents\n        for i in 0..batch_size {\n            let processor_clone = Arc::clone(&processor);\n            let handle = tokio::spawn(async move {\n                let file_path = format!(\"large_batch_test_{:03}.rs\", i);\n                processor_clone.process_document(&file_path).await\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n        let elapsed = start_time.elapsed();\n\n        // Verify all documents were processed\n        let mut successful_count = 0;\n        for (i, result) in results.iter().enumerate() {\n            let process_result = result.as_ref().expect(&format!(\"Task {} panicked\", i));\n            if process_result.is_ok() {\n                successful_count += 1;\n                let document_id = process_result.as_ref().unwrap();\n                assert_eq!(document_id.len(), 36);\n                assert!(uuid::Uuid::parse_str(document_id).is_ok());\n            }\n        }\n\n        assert_eq!(successful_count, batch_size, \"Not all documents were processed successfully\");\n        \n        // Performance check: with 6 concurrent tasks and 30 documents (~100ms each),\n        // should complete in roughly 500ms (5 batches)\n        assert!(elapsed <= Duration::from_millis(800), \"Batch processing took too long: {:?}\", elapsed);\n        println!(\"Processed {} documents in {:?} (avg: {:?} per document)\", \n                batch_size, elapsed, elapsed / batch_size);\n    }\n\n    #[tokio::test]\n    async fn test_mixed_batch_with_repeated_files() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        // Create a batch where some files are repeated\n        let file_list = vec![\n            \"common.rs\",\n            \"unique1.py\",\n            \"common.rs\", // Repeated\n            \"unique2.md\",\n            \"common.rs\", // Repeated again\n            \"unique3.txt\",\n        ];\n\n        let mut handles = vec![];\n        for (i, file_path) in file_list.iter().enumerate() {\n            let processor_clone = Arc::clone(&processor);\n            let file_path = file_path.to_string();\n            \n            let handle = tokio::spawn(async move {\n                let result = processor_clone.process_document(&file_path).await;\n                (i, file_path, result)\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n\n        // All should succeed and have unique UUIDs (even repeated files get new UUIDs)\n        let mut document_ids = vec![];\n        for result in results {\n            let (index, file_path, process_result) = result.expect(\"Task should not panic\");\n            assert!(process_result.is_ok(), \"Failed to process {} at index {}\", file_path, index);\n            \n            let document_id = process_result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(&document_id).is_ok());\n            document_ids.push(document_id);\n        }\n\n        // All UUIDs should be unique, even for repeated file names\n        for i in 0..document_ids.len() {\n            for j in (i + 1)..document_ids.len() {\n                assert_ne!(document_ids[i], document_ids[j], \n                    \"UUIDs should be unique even for repeated files\");\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_batch_processing_error_isolation() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(&processing_config, &qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        // Create a batch of both normal and edge-case files\n        let file_batch = vec![\n            \"normal1.rs\",\n            \"\", // Empty filename\n            \"normal2.py\",\n            \"file with spaces.txt\",\n            \"normal3.md\",\n            \"very/deep/nested/path/file.json\",\n            \"normal4.html\",\n        ];\n\n        let mut handles = vec![];\n        for (i, file_path) in file_batch.iter().enumerate() {\n            let processor_clone = Arc::clone(&processor);\n            let file_path = file_path.to_string();\n            \n            let handle = tokio::spawn(async move {\n                let result = processor_clone.process_document(&file_path).await;\n                (i, file_path, result)\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n\n        // All should succeed (current implementation should handle all edge cases)\n        for result in results {\n            let (index, file_path, process_result) = result.expect(\"Task should not panic\");\n            assert!(process_result.is_ok(), \n                \"Failed to process file '{}' at index {}: {:?}\", \n                file_path, index, process_result.err());\n            \n            let document_id = process_result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(&document_id).is_ok());\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine","tests","test_daemon_state.rs"],"content":"//! Comprehensive unit tests for daemon/state.rs\n//! Tests state persistence, recovery mechanisms, concurrent access, and error handling\n\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tempfile::{tempdir, NamedTempFile};\nuse tokio::time::timeout;\nuse tokio::task::JoinSet;\nuse sqlx::Row;\nuse workspace_qdrant_daemon::config::DatabaseConfig;\nuse workspace_qdrant_daemon::daemon::state::DaemonState;\nuse workspace_qdrant_daemon::error::DaemonError;\n\n/// Helper function to create test database configuration\nfn create_test_db_config() -> DatabaseConfig {\n    DatabaseConfig {\n        sqlite_path: \"sqlite::memory:\".to_string(),\n        max_connections: 1,\n        connection_timeout_secs: 5,\n        enable_wal: false,\n    }\n}\n\n/// Helper function to create test database configuration with custom path\nfn create_test_db_config_with_path(path: String) -> DatabaseConfig {\n    DatabaseConfig {\n        sqlite_path: path,\n        max_connections: 5,\n        connection_timeout_secs: 10,\n        enable_wal: true,\n    }\n}\n\n/// Helper function to create test database configuration for concurrent access\nfn create_concurrent_db_config() -> DatabaseConfig {\n    DatabaseConfig {\n        sqlite_path: \"sqlite::memory:\".to_string(),\n        max_connections: 10,\n        connection_timeout_secs: 30,\n        enable_wal: true,\n    }\n}\n\n#[cfg(test)]\nmod basic_functionality {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_daemon_state_creation_success() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Verify state was created successfully\n        assert!(!state.pool().is_closed());\n\n        // Test debug formatting\n        let debug_str = format!(\"{:?}\", state);\n        assert!(debug_str.contains(\"DaemonState\"));\n    }\n\n    #[tokio::test]\n    async fn test_daemon_state_creation_with_wal() {\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 5,\n            connection_timeout_secs: 15,\n            enable_wal: true,\n        };\n\n        let state = DaemonState::new(&config).await.unwrap();\n        assert!(!state.pool().is_closed());\n    }\n\n    #[tokio::test]\n    async fn test_health_check_success() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Health check should pass\n        let result = state.health_check().await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_health_check_multiple_calls() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Multiple health checks should all succeed\n        for _ in 0..5 {\n            state.health_check().await.unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_pool_access() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Pool should be accessible and functional\n        let pool = state.pool();\n        assert!(!pool.is_closed());\n\n        // Can execute queries through the pool\n        let result = sqlx::query(\"SELECT 1\")\n            .fetch_one(pool)\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_database_config_validation() {\n        // Test with different connection limits\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 20,\n            connection_timeout_secs: 60,\n            enable_wal: false,\n        };\n\n        let state = DaemonState::new(&config).await.unwrap();\n        state.health_check().await.unwrap();\n    }\n}\n\n#[cfg(test)]\nmod state_persistence {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_migrations_create_required_tables() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Verify all required tables were created\n        let tables = vec![\"projects\", \"collections\", \"processing_operations\"];\n\n        for table_name in tables {\n            let result = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\")\n                .bind(table_name)\n                .fetch_optional(state.pool())\n                .await\n                .unwrap();\n            assert!(result.is_some(), \"Table {} should exist\", table_name);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_projects_table_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Test projects table can accept proper data\n        let result = sqlx::query(r#\"\n            INSERT INTO projects (id, name, root_path, git_repository, git_branch, metadata)\n            VALUES ('test-id', 'test-project', '/test/path', 'https://github.com/test/repo', 'main', '{}')\n        \"#)\n        .execute(state.pool())\n        .await;\n        assert!(result.is_ok());\n\n        // Verify data can be retrieved\n        let row = sqlx::query(\"SELECT * FROM projects WHERE id = 'test-id'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n\n        assert_eq!(row.get::<String, _>(\"name\"), \"test-project\");\n        assert_eq!(row.get::<String, _>(\"root_path\"), \"/test/path\");\n    }\n\n    #[tokio::test]\n    async fn test_collections_table_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // First insert a project (foreign key dependency)\n        sqlx::query(r#\"\n            INSERT INTO projects (id, name, root_path)\n            VALUES ('proj-1', 'test-project', '/test/path')\n        \"#)\n        .execute(state.pool())\n        .await\n        .unwrap();\n\n        // Test collections table can accept proper data\n        let result = sqlx::query(r#\"\n            INSERT INTO collections (id, name, project_id, config)\n            VALUES ('coll-1', 'test-collection', 'proj-1', '{\"vector_size\": 384}')\n        \"#)\n        .execute(state.pool())\n        .await;\n        assert!(result.is_ok());\n\n        // Verify data can be retrieved\n        let row = sqlx::query(\"SELECT * FROM collections WHERE id = 'coll-1'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n\n        assert_eq!(row.get::<String, _>(\"name\"), \"test-collection\");\n        assert_eq!(row.get::<String, _>(\"project_id\"), \"proj-1\");\n    }\n\n    #[tokio::test]\n    async fn test_processing_operations_table_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // First insert a project (foreign key dependency)\n        sqlx::query(r#\"\n            INSERT INTO projects (id, name, root_path)\n            VALUES ('proj-1', 'test-project', '/test/path')\n        \"#)\n        .execute(state.pool())\n        .await\n        .unwrap();\n\n        // Test processing_operations table can accept proper data\n        let result = sqlx::query(r#\"\n            INSERT INTO processing_operations (id, project_id, status, total_documents, processed_documents, failed_documents, error_messages)\n            VALUES ('op-1', 'proj-1', 'in_progress', 100, 50, 2, '[\"error1\", \"error2\"]')\n        \"#)\n        .execute(state.pool())\n        .await;\n        assert!(result.is_ok());\n\n        // Verify data can be retrieved\n        let row = sqlx::query(\"SELECT * FROM processing_operations WHERE id = 'op-1'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n\n        assert_eq!(row.get::<String, _>(\"status\"), \"in_progress\");\n        assert_eq!(row.get::<i64, _>(\"total_documents\"), 100);\n        assert_eq!(row.get::<i64, _>(\"processed_documents\"), 50);\n    }\n\n    #[tokio::test]\n    async fn test_foreign_key_constraints() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Enable foreign key constraints\n        sqlx::query(\"PRAGMA foreign_keys = ON\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        // Try to insert a collection without a valid project (should fail)\n        let result = sqlx::query(r#\"\n            INSERT INTO collections (id, name, project_id, config)\n            VALUES ('coll-1', 'test-collection', 'nonexistent-project', '{}')\n        \"#)\n        .execute(state.pool())\n        .await;\n\n        assert!(result.is_err(), \"Foreign key constraint should prevent this insert\");\n    }\n\n    #[tokio::test]\n    async fn test_migration_idempotency() {\n        let config = create_test_db_config();\n\n        // Run migrations multiple times\n        let state1 = DaemonState::new(&config).await.unwrap();\n        drop(state1);\n\n        let state2 = DaemonState::new(&config).await.unwrap();\n        drop(state2);\n\n        let state3 = DaemonState::new(&config).await.unwrap();\n\n        // Final state should be functional\n        state3.health_check().await.unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_state_persistence_with_file_database() {\n        let temp_dir = tempdir().unwrap();\n        let db_path = temp_dir.path().join(\"test_state.db\");\n        let db_url = format!(\"sqlite://{}?mode=rwc\", db_path.display());\n        let config = create_test_db_config_with_path(db_url);\n\n        // Create state and insert data\n        {\n            let state = DaemonState::new(&config).await.unwrap();\n\n            sqlx::query(r#\"\n                INSERT INTO projects (id, name, root_path)\n                VALUES ('persistent-proj', 'test-project', '/test/path')\n            \"#)\n            .execute(state.pool())\n            .await\n            .unwrap();\n        }\n\n        // Recreate state with same database file\n        {\n            let state = DaemonState::new(&config).await.unwrap();\n\n            // Data should persist\n            let row = sqlx::query(\"SELECT * FROM projects WHERE id = 'persistent-proj'\")\n                .fetch_one(state.pool())\n                .await\n                .unwrap();\n\n            assert_eq!(row.get::<String, _>(\"name\"), \"test-project\");\n        }\n    }\n}\n\n#[cfg(test)]\nmod concurrent_access {\n    use super::*;\n    use std::sync::atomic::{AtomicU32, Ordering};\n    use tokio::task::JoinSet;\n\n    #[tokio::test]\n    async fn test_multiple_state_instances() {\n        let config1 = create_test_db_config();\n        let config2 = create_test_db_config();\n\n        let state1 = DaemonState::new(&config1).await.unwrap();\n        let state2 = DaemonState::new(&config2).await.unwrap();\n\n        // Both should be functional independently\n        state1.health_check().await.unwrap();\n        state2.health_check().await.unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_health_checks() {\n        let config = create_concurrent_db_config();\n        let state = Arc::new(DaemonState::new(&config).await.unwrap());\n\n        let mut tasks = JoinSet::new();\n\n        // Spawn multiple concurrent health checks\n        for _ in 0..10 {\n            let state_clone = Arc::clone(&state);\n            tasks.spawn(async move {\n                state_clone.health_check().await\n            });\n        }\n\n        // All health checks should succeed\n        while let Some(result) = tasks.join_next().await {\n            assert!(result.unwrap().is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_database_operations() {\n        let temp_dir = tempdir().unwrap();\n        let db_path = temp_dir.path().join(\"concurrent_test.db\");\n        let db_url = format!(\"sqlite://{}?mode=rwc\", db_path.display());\n        let config = create_test_db_config_with_path(db_url);\n\n        let state = Arc::new(DaemonState::new(&config).await.unwrap());\n        let counter = Arc::new(AtomicU32::new(0));\n        let mut tasks = JoinSet::new();\n\n        // Spawn multiple concurrent insert operations\n        for i in 0..5 {\n            let state_clone = Arc::clone(&state);\n            let counter_clone = Arc::clone(&counter);\n\n            tasks.spawn(async move {\n                let id = format!(\"concurrent-proj-{}\", i);\n                let name = format!(\"concurrent-project-{}\", i);\n                let path = format!(\"/concurrent/test/path/{}\", i);\n\n                let result = sqlx::query(r#\"\n                    INSERT INTO projects (id, name, root_path)\n                    VALUES (?, ?, ?)\n                \"#)\n                .bind(&id)\n                .bind(&name)\n                .bind(&path)\n                .execute(state_clone.pool())\n                .await;\n\n                if result.is_ok() {\n                    counter_clone.fetch_add(1, Ordering::SeqCst);\n                }\n                result\n            });\n        }\n\n        // Wait for all operations to complete\n        while let Some(result) = tasks.join_next().await {\n            assert!(result.unwrap().is_ok());\n        }\n\n        // Verify all inserts succeeded\n        assert_eq!(counter.load(Ordering::SeqCst), 5);\n\n        // Verify data integrity\n        let count: i64 = sqlx::query_scalar(\"SELECT COUNT(*) FROM projects WHERE name LIKE 'concurrent-project-%'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n        assert_eq!(count, 5);\n    }\n\n    #[tokio::test]\n    async fn test_connection_pool_management() {\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 3, // Limited pool size\n            connection_timeout_secs: 5,\n            enable_wal: true,\n        };\n\n        let state = Arc::new(DaemonState::new(&config).await.unwrap());\n        let mut tasks = JoinSet::new();\n\n        // Spawn more tasks than the pool size\n        for i in 0..6 {\n            let state_clone = Arc::clone(&state);\n\n            tasks.spawn(async move {\n                // Hold connection briefly\n                let result = sqlx::query(\"SELECT ?\")\n                    .bind(i)\n                    .fetch_one(state_clone.pool())\n                    .await;\n\n                tokio::time::sleep(Duration::from_millis(100)).await;\n                result\n            });\n        }\n\n        // All operations should eventually succeed despite pool limits\n        while let Some(result) = tasks.join_next().await {\n            assert!(result.unwrap().is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_connection_timeout_handling() {\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 1, // Very limited\n            connection_timeout_secs: 1, // Short timeout\n            enable_wal: false,\n        };\n\n        let state = Arc::new(DaemonState::new(&config).await.unwrap());\n\n        // Start a long-running operation\n        let state_clone = Arc::clone(&state);\n        let _long_task = tokio::spawn(async move {\n            tokio::time::sleep(Duration::from_secs(2)).await;\n            state_clone.health_check().await\n        });\n\n        // Try to use the same connection pool immediately\n        // This should either succeed quickly or timeout appropriately\n        let quick_result = timeout(\n            Duration::from_secs(3),\n            state.health_check()\n        ).await;\n\n        assert!(quick_result.is_ok(), \"Operation should complete within timeout\");\n    }\n}\n\n#[cfg(test)]\nmod error_handling {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_invalid_database_path() {\n        let config = DatabaseConfig {\n            sqlite_path: \"/invalid/nonexistent/path/db.sqlite\".to_string(),\n            max_connections: 1,\n            connection_timeout_secs: 5,\n            enable_wal: false,\n        };\n\n        let result = DaemonState::new(&config).await;\n        assert!(result.is_err());\n\n        match result.unwrap_err() {\n            DaemonError::Database(_) => {\n                // Expected error type\n            },\n            other => panic!(\"Expected Database error, got: {:?}\", other),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_invalid_connection_string() {\n        let config = DatabaseConfig {\n            sqlite_path: \"invalid://connection/string\".to_string(),\n            max_connections: 1,\n            connection_timeout_secs: 5,\n            enable_wal: false,\n        };\n\n        let result = DaemonState::new(&config).await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_database_permission_error() {\n        // Create a read-only file to simulate permission error\n        let temp_file = NamedTempFile::new().unwrap();\n        let db_path = temp_file.path();\n\n        // Try to set read-only permissions (may not work on all systems)\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::PermissionsExt;\n            let mut perms = std::fs::metadata(db_path).unwrap().permissions();\n            perms.set_mode(0o444); // Read-only\n            std::fs::set_permissions(db_path, perms).unwrap();\n        }\n\n        let db_url = format!(\"sqlite://{}?mode=rwc\", db_path.display());\n        let config = create_test_db_config_with_path(db_url);\n\n        // This may or may not fail depending on the system\n        // But if it fails, it should be a Database error\n        if let Err(error) = DaemonState::new(&config).await {\n            match error {\n                DaemonError::Database(_) => {\n                    // Expected error type\n                },\n                other => panic!(\"Expected Database error, got: {:?}\", other),\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_health_check_on_closed_pool() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Close the pool\n        state.pool().close().await;\n\n        // Health check should fail\n        let result = state.health_check().await;\n        assert!(result.is_err());\n\n        match result.unwrap_err() {\n            DaemonError::Database(_) => {\n                // Expected error type for closed pool\n            },\n            other => panic!(\"Expected Database error, got: {:?}\", other),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_migration_failure_recovery() {\n        let config = create_test_db_config();\n\n        // First, create a state successfully\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Manually corrupt the schema by dropping a table\n        sqlx::query(\"DROP TABLE IF EXISTS projects\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        drop(state);\n\n        // Creating a new state should re-run migrations and fix the issue\n        let new_state = DaemonState::new(&config).await.unwrap();\n\n        // Verify tables exist again\n        let result = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' AND name='projects'\")\n            .fetch_optional(new_state.pool())\n            .await\n            .unwrap();\n        assert!(result.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_connection_limit_exceeded() {\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 1, // Very limited\n            connection_timeout_secs: 1, // Short timeout\n            enable_wal: false,\n        };\n\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Try to saturate the connection pool\n        let pool = state.pool();\n        let _conn1 = pool.acquire().await.unwrap();\n\n        // Second connection should timeout quickly\n        let conn2_result = timeout(\n            Duration::from_millis(1500),\n            pool.acquire()\n        ).await;\n\n        // Should either timeout or succeed depending on timing\n        // The important thing is it doesn't hang indefinitely\n        assert!(conn2_result.is_ok() || conn2_result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_database_corruption_simulation() {\n        // Create a temporary file that we can corrupt\n        let temp_file = NamedTempFile::new().unwrap();\n        let db_path = temp_file.path();\n\n        // Write some invalid data to simulate corruption\n        std::fs::write(db_path, b\"this is not a valid sqlite database\").unwrap();\n\n        let db_url = format!(\"sqlite://{}?mode=rwc\", db_path.display());\n        let config = create_test_db_config_with_path(db_url);\n\n        // Attempt to open corrupted database should fail\n        let result = DaemonState::new(&config).await;\n        assert!(result.is_err());\n\n        match result.unwrap_err() {\n            DaemonError::Database(_) => {\n                // Expected error type for corrupted database\n            },\n            other => panic!(\"Expected Database error for corruption, got: {:?}\", other),\n        }\n    }\n}\n\n#[cfg(test)]\nmod performance_tests {\n    use super::*;\n    use std::time::Instant;\n\n    #[tokio::test]\n    async fn test_state_creation_performance() {\n        let config = create_test_db_config();\n\n        let start = Instant::now();\n        let state = DaemonState::new(&config).await.unwrap();\n        let creation_time = start.elapsed();\n\n        // State creation should be reasonably fast (under 1 second)\n        assert!(creation_time < Duration::from_secs(1),\n                \"State creation took too long: {:?}\", creation_time);\n\n        state.health_check().await.unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_health_check_performance() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Measure health check performance\n        let start = Instant::now();\n        for _ in 0..10 {\n            state.health_check().await.unwrap();\n        }\n        let total_time = start.elapsed();\n\n        // 10 health checks should complete quickly\n        assert!(total_time < Duration::from_millis(500),\n                \"Health checks took too long: {:?}\", total_time);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_operation_performance() {\n        let config = create_concurrent_db_config();\n        let state = Arc::new(DaemonState::new(&config).await.unwrap());\n\n        let start = Instant::now();\n        let mut tasks = JoinSet::new();\n\n        // Launch many concurrent operations\n        for i in 0..20 {\n            let state_clone = Arc::clone(&state);\n            tasks.spawn(async move {\n                let id = format!(\"perf-proj-{}\", i);\n                sqlx::query(r#\"\n                    INSERT INTO projects (id, name, root_path)\n                    VALUES (?, ?, ?)\n                \"#)\n                .bind(&id)\n                .bind(format!(\"project-{}\", i))\n                .bind(format!(\"/path/{}\", i))\n                .execute(state_clone.pool())\n                .await\n            });\n        }\n\n        // Wait for all to complete\n        while let Some(result) = tasks.join_next().await {\n            assert!(result.unwrap().is_ok());\n        }\n\n        let total_time = start.elapsed();\n\n        // 20 concurrent operations should complete in reasonable time\n        assert!(total_time < Duration::from_secs(5),\n                \"Concurrent operations took too long: {:?}\", total_time);\n    }\n\n    #[tokio::test]\n    async fn test_large_dataset_handling() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Insert a moderate amount of data\n        let start = Instant::now();\n        for i in 0..100 {\n            sqlx::query(r#\"\n                INSERT INTO projects (id, name, root_path, metadata)\n                VALUES (?, ?, ?, ?)\n            \"#)\n            .bind(format!(\"large-proj-{}\", i))\n            .bind(format!(\"Large Project {}\", i))\n            .bind(format!(\"/large/path/{}\", i))\n            .bind(format!(r#\"{{\"index\": {}, \"size\": \"large\"}}\"#, i))\n            .execute(state.pool())\n            .await\n            .unwrap();\n        }\n        let insert_time = start.elapsed();\n\n        // Query all data back\n        let start = Instant::now();\n        let rows = sqlx::query(\"SELECT * FROM projects WHERE name LIKE 'Large Project%'\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n        let query_time = start.elapsed();\n\n        assert_eq!(rows.len(), 100);\n\n        // Operations should complete in reasonable time\n        assert!(insert_time < Duration::from_secs(2),\n                \"Large insert took too long: {:?}\", insert_time);\n        assert!(query_time < Duration::from_millis(500),\n                \"Large query took too long: {:?}\", query_time);\n    }\n\n    #[tokio::test]\n    async fn test_memory_usage_stability() {\n        // Create and destroy many state instances with in-memory databases\n        for iteration in 0..10 {\n            let config = create_test_db_config();\n            let state = DaemonState::new(&config).await.unwrap();\n\n            // Do some operations\n            for i in 0..10 {\n                sqlx::query(r#\"\n                    INSERT INTO projects (id, name, root_path)\n                    VALUES (?, ?, ?)\n                \"#)\n                .bind(format!(\"mem-test-{}-{}\", iteration, i))\n                .bind(format!(\"Memory Test {} {}\", iteration, i))\n                .bind(format!(\"/memory/test/{}/{}\", iteration, i))\n                .execute(state.pool())\n                .await\n                .unwrap();\n            }\n\n            state.health_check().await.unwrap();\n\n            // State should be dropped here\n        }\n\n        // If we get here without OOM, memory management is working\n        assert!(true, \"Memory usage remained stable\");\n    }\n}\n\n#[cfg(test)]\nmod integration_tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_config_to_state_integration() {\n        // Test various configuration options\n        let configs = vec![\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 1,\n                connection_timeout_secs: 5,\n                enable_wal: false,\n            },\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 10,\n                connection_timeout_secs: 60,\n                enable_wal: true,\n            },\n        ];\n\n        for config in configs {\n            let state = DaemonState::new(&config).await.unwrap();\n            state.health_check().await.unwrap();\n\n            // Verify basic functionality works with each config\n            sqlx::query(r#\"\n                INSERT INTO projects (id, name, root_path)\n                VALUES ('integration-test', 'Integration Project', '/integration/path')\n            \"#)\n            .execute(state.pool())\n            .await\n            .unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_state_schema_completeness() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Test that all required tables have expected columns\n        let projects_columns = sqlx::query(\"PRAGMA table_info(projects)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n\n        let expected_project_columns = vec![\n            \"id\", \"name\", \"root_path\", \"git_repository\",\n            \"git_branch\", \"metadata\", \"created_at\", \"updated_at\"\n        ];\n\n        for expected_col in expected_project_columns {\n            assert!(\n                projects_columns.iter().any(|row| {\n                    row.get::<String, _>(\"name\") == expected_col\n                }),\n                \"Projects table missing column: {}\",\n                expected_col\n            );\n        }\n\n        let collections_columns = sqlx::query(\"PRAGMA table_info(collections)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n\n        let expected_collection_columns = vec![\n            \"id\", \"name\", \"project_id\", \"config\", \"created_at\"\n        ];\n\n        for expected_col in expected_collection_columns {\n            assert!(\n                collections_columns.iter().any(|row| {\n                    row.get::<String, _>(\"name\") == expected_col\n                }),\n                \"Collections table missing column: {}\",\n                expected_col\n            );\n        }\n\n        let processing_columns = sqlx::query(\"PRAGMA table_info(processing_operations)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n\n        let expected_processing_columns = vec![\n            \"id\", \"project_id\", \"status\", \"total_documents\",\n            \"processed_documents\", \"failed_documents\", \"error_messages\",\n            \"started_at\", \"updated_at\"\n        ];\n\n        for expected_col in expected_processing_columns {\n            assert!(\n                processing_columns.iter().any(|row| {\n                    row.get::<String, _>(\"name\") == expected_col\n                }),\n                \"Processing operations table missing column: {}\",\n                expected_col\n            );\n        }\n    }\n\n    #[tokio::test]\n    async fn test_cross_table_relationships() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(&config).await.unwrap();\n\n        // Create a complete data hierarchy\n        let project_id = \"rel-test-project\";\n        let collection_id = \"rel-test-collection\";\n        let operation_id = \"rel-test-operation\";\n\n        // Insert project\n        sqlx::query(r#\"\n            INSERT INTO projects (id, name, root_path, git_repository, git_branch, metadata)\n            VALUES (?, ?, ?, ?, ?, ?)\n        \"#)\n        .bind(project_id)\n        .bind(\"Relationship Test Project\")\n        .bind(\"/rel/test/path\")\n        .bind(\"https://github.com/test/repo\")\n        .bind(\"main\")\n        .bind(r#\"{\"test\": true}\"#)\n        .execute(state.pool())\n        .await\n        .unwrap();\n\n        // Insert collection linked to project\n        sqlx::query(r#\"\n            INSERT INTO collections (id, name, project_id, config)\n            VALUES (?, ?, ?, ?)\n        \"#)\n        .bind(collection_id)\n        .bind(\"Relationship Test Collection\")\n        .bind(project_id)\n        .bind(r#\"{\"vector_size\": 384, \"metric\": \"cosine\"}\"#)\n        .execute(state.pool())\n        .await\n        .unwrap();\n\n        // Insert processing operation linked to project\n        sqlx::query(r#\"\n            INSERT INTO processing_operations (id, project_id, status, total_documents, processed_documents, failed_documents, error_messages)\n            VALUES (?, ?, ?, ?, ?, ?, ?)\n        \"#)\n        .bind(operation_id)\n        .bind(project_id)\n        .bind(\"completed\")\n        .bind(50)\n        .bind(48)\n        .bind(2)\n        .bind(r#\"[\"timeout on large file\", \"parsing error\"]\"#)\n        .execute(state.pool())\n        .await\n        .unwrap();\n\n        // Query relationships\n        let project_data = sqlx::query(r#\"\n            SELECT\n                p.*,\n                COUNT(DISTINCT c.id) as collection_count,\n                COUNT(DISTINCT po.id) as operation_count\n            FROM projects p\n            LEFT JOIN collections c ON p.id = c.project_id\n            LEFT JOIN processing_operations po ON p.id = po.project_id\n            WHERE p.id = ?\n            GROUP BY p.id\n        \"#)\n        .bind(project_id)\n        .fetch_one(state.pool())\n        .await\n        .unwrap();\n\n        assert_eq!(project_data.get::<String, _>(\"name\"), \"Relationship Test Project\");\n        assert_eq!(project_data.get::<i64, _>(\"collection_count\"), 1);\n        assert_eq!(project_data.get::<i64, _>(\"operation_count\"), 1);\n    }\n}","traces":[],"covered":0,"coverable":0}],"coverage":76.20578778135048,"covered":237,"coverable":311}