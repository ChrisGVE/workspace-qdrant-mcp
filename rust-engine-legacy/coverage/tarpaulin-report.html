<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","benches","processing_benchmarks.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse std::time::Duration;\n\n/// Sample benchmark for document processing performance\nfn benchmark_document_processing(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"document_processing\");\n    group.measurement_time(Duration::from_secs(10));\n\n    group.bench_function(\"small_document\", |b| {\n        let content = \"Hello world! \".repeat(100);\n        b.iter(|| {\n            // Simulate document processing\n            black_box(content.len())\n        });\n    });\n\n    group.bench_function(\"large_document\", |b| {\n        let content = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. \".repeat(1000);\n        b.iter(|| {\n            // Simulate large document processing\n            black_box(content.len())\n        });\n    });\n\n    group.finish();\n}\n\n/// Benchmark for search operations\nfn benchmark_search_operations(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"search_operations\");\n\n    group.bench_function(\"vector_search\", |b| {\n        let query_vector = vec![0.1f32; 384]; // Typical embedding dimension\n        b.iter(|| {\n            // Simulate vector similarity calculation\n            let sum: f32 = black_box(query_vector.iter().sum());\n            black_box(sum)\n        });\n    });\n\n    group.bench_function(\"hybrid_search\", |b| {\n        let dense_scores = vec![0.8, 0.7, 0.6, 0.5, 0.4];\n        let sparse_scores = vec![0.9, 0.6, 0.8, 0.3, 0.7];\n\n        b.iter(|| {\n            // Simulate reciprocal rank fusion\n            let mut combined_scores = Vec::new();\n            for (i, (\u0026dense, \u0026sparse)) in dense_scores.iter().zip(sparse_scores.iter()).enumerate() {\n                let rrf_score = 1.0 / (60.0 + i as f32 + 1.0) + 1.0 / (60.0 + i as f32 + 1.0);\n                combined_scores.push(black_box(dense + sparse + rrf_score));\n            }\n            black_box(combined_scores)\n        });\n    });\n\n    group.finish();\n}\n\n/// Benchmark for concurrent operations\nfn benchmark_concurrent_processing(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"concurrent_processing\");\n\n    group.bench_function(\"parallel_document_processing\", |b| {\n        let documents: Vec\u003cString\u003e = (0..100).map(|i| format!(\"Document {}\", i)).collect();\n\n        b.iter(|| {\n            use std::thread;\n            let handles: Vec\u003c_\u003e = documents\n                .chunks(10)\n                .map(|chunk| {\n                    let chunk = chunk.to_vec();\n                    thread::spawn(move || {\n                        chunk.iter().map(|doc| black_box(doc.len())).sum::\u003cusize\u003e()\n                    })\n                })\n                .collect();\n\n            let results: Vec\u003c_\u003e = handles.into_iter().map(|h| h.join().unwrap()).collect();\n            black_box(results)\n        });\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    benchmark_document_processing,\n    benchmark_search_operations,\n    benchmark_concurrent_processing\n);\ncriterion_main!(benches);","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","build.rs"],"content":"use std::env;\nuse std::path::PathBuf;\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let out_dir = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n\n    tonic_build::configure()\n        .build_server(true)\n        .build_client(true)\n        .file_descriptor_set_path(out_dir.join(\"workspace_daemon_descriptor.bin\"))\n        .compile_protos(\n            \u0026[\"proto/workspace_daemon.proto\"],\n            \u0026[\"proto\"],\n        )?;\n\n    // Rerun if proto files change\n    println!(\"cargo:rerun-if-changed=proto/workspace_daemon.proto\");\n\n    Ok(())\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","config.rs"],"content":"//! Configuration management for the Workspace Qdrant Daemon\n\nuse crate::error::DaemonResult;\nuse serde::{Deserialize, Serialize};\nuse std::path::Path;\n\n/// Main daemon configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DaemonConfig {\n    /// Server configuration\n    pub server: ServerConfig,\n\n    /// Database configuration\n    pub database: DatabaseConfig,\n\n    /// Qdrant configuration\n    pub qdrant: QdrantConfig,\n\n    /// Document processing configuration\n    pub processing: ProcessingConfig,\n\n    /// File watching configuration\n    pub file_watcher: FileWatcherConfig,\n\n    /// Metrics configuration\n    pub metrics: MetricsConfig,\n\n    /// Logging configuration\n    pub logging: LoggingConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServerConfig {\n    /// gRPC server host\n    pub host: String,\n\n    /// gRPC server port\n    pub port: u16,\n\n    /// Maximum number of concurrent connections\n    pub max_connections: usize,\n\n    /// Connection timeout in seconds\n    pub connection_timeout_secs: u64,\n\n    /// Request timeout in seconds\n    pub request_timeout_secs: u64,\n\n    /// Enable TLS (for future use)\n    pub enable_tls: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DatabaseConfig {\n    /// SQLite database file path\n    pub sqlite_path: String,\n\n    /// Maximum number of database connections\n    pub max_connections: u32,\n\n    /// Connection timeout in seconds\n    pub connection_timeout_secs: u64,\n\n    /// Enable WAL mode for better concurrency\n    pub enable_wal: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct QdrantConfig {\n    /// Qdrant server URL\n    pub url: String,\n\n    /// Qdrant API key (optional)\n    pub api_key: Option\u003cString\u003e,\n\n    /// Connection timeout in seconds\n    pub timeout_secs: u64,\n\n    /// Maximum number of retries\n    pub max_retries: u32,\n\n    /// Default collection configuration\n    pub default_collection: CollectionConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CollectionConfig {\n    /// Vector size for embeddings\n    pub vector_size: usize,\n\n    /// Distance metric (Cosine, Euclidean, Dot)\n    pub distance_metric: String,\n\n    /// Enable payload indexing\n    pub enable_indexing: bool,\n\n    /// Replication factor\n    pub replication_factor: u32,\n\n    /// Number of shards\n    pub shard_number: u32,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProcessingConfig {\n    /// Maximum number of concurrent processing tasks\n    pub max_concurrent_tasks: usize,\n\n    /// Default chunk size for documents\n    pub default_chunk_size: usize,\n\n    /// Default chunk overlap\n    pub default_chunk_overlap: usize,\n\n    /// Maximum file size to process (in bytes)\n    pub max_file_size_bytes: u64,\n\n    /// Supported file extensions\n    pub supported_extensions: Vec\u003cString\u003e,\n\n    /// Enable LSP integration\n    pub enable_lsp: bool,\n\n    /// LSP server timeout in seconds\n    pub lsp_timeout_secs: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileWatcherConfig {\n    /// Enable file watching\n    pub enabled: bool,\n\n    /// Debounce delay in milliseconds\n    pub debounce_ms: u64,\n\n    /// Maximum number of watched directories\n    pub max_watched_dirs: usize,\n\n    /// Patterns to ignore\n    pub ignore_patterns: Vec\u003cString\u003e,\n\n    /// Enable recursive watching\n    pub recursive: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsConfig {\n    /// Enable metrics collection\n    pub enabled: bool,\n\n    /// Metrics collection interval in seconds\n    pub collection_interval_secs: u64,\n\n    /// Metrics retention period in days\n    pub retention_days: u32,\n\n    /// Enable Prometheus metrics export\n    pub enable_prometheus: bool,\n\n    /// Prometheus metrics port\n    pub prometheus_port: u16,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LoggingConfig {\n    /// Log level (trace, debug, info, warn, error)\n    pub level: String,\n\n    /// Log file path (optional)\n    pub file_path: Option\u003cString\u003e,\n\n    /// Enable JSON logging\n    pub json_format: bool,\n\n    /// Maximum log file size in MB\n    pub max_file_size_mb: u64,\n\n    /// Maximum number of log files to keep\n    pub max_files: u32,\n}\n\nimpl Default for DaemonConfig {\n    fn default() -\u003e Self {\n        Self {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50051,\n                max_connections: 1000,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 300,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: \"./workspace_daemon.db\".to_string(),\n                max_connections: 10,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: CollectionConfig {\n                    vector_size: 384, // sentence-transformers/all-MiniLM-L6-v2\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 4,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 100 * 1024 * 1024, // 100MB\n                supported_extensions: vec![\n                    \"rs\".to_string(),\n                    \"py\".to_string(),\n                    \"js\".to_string(),\n                    \"ts\".to_string(),\n                    \"md\".to_string(),\n                    \"txt\".to_string(),\n                    \"pdf\".to_string(),\n                    \"html\".to_string(),\n                    \"json\".to_string(),\n                    \"xml\".to_string(),\n                ],\n                enable_lsp: true,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: true,\n                debounce_ms: 500,\n                max_watched_dirs: 100,\n                ignore_patterns: vec![\n                    \"target/**\".to_string(),\n                    \"node_modules/**\".to_string(),\n                    \".git/**\".to_string(),\n                    \"*.tmp\".to_string(),\n                    \"*.log\".to_string(),\n                ],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: true,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: true,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: Some(\"./workspace_daemon.log\".to_string()),\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n}\n\nimpl DaemonConfig {\n    /// Load configuration from file or use defaults\n    pub fn load(config_path: Option\u003c\u0026Path\u003e) -\u003e DaemonResult\u003cSelf\u003e {\n        match config_path {\n            Some(path) =\u003e {\n                let content = std::fs::read_to_string(path)?;\n                let config: DaemonConfig = serde_yaml::from_str(\u0026content)\n                    .map_err(|e| crate::error::DaemonError::Config(\n                        config::ConfigError::Message(format!(\"Invalid YAML: {}\", e))\n                    ))?;\n                Ok(config)\n            },\n            None =\u003e {\n                // Try to load from environment variables\n                Self::from_env()\n            }\n        }\n    }\n\n    /// Load configuration from environment variables\n    fn from_env() -\u003e DaemonResult\u003cSelf\u003e {\n        let mut config = Self::default();\n\n        // Override with environment variables if present\n        if let Ok(url) = std::env::var(\"QDRANT_URL\") {\n            config.qdrant.url = url;\n        }\n\n        if let Ok(api_key) = std::env::var(\"QDRANT_API_KEY\") {\n            config.qdrant.api_key = Some(api_key);\n        }\n\n        if let Ok(host) = std::env::var(\"DAEMON_HOST\") {\n            config.server.host = host;\n        }\n\n        if let Ok(port) = std::env::var(\"DAEMON_PORT\") {\n            config.server.port = port.parse()\n                .map_err(|e| crate::error::DaemonError::Config(\n                    config::ConfigError::Message(format!(\"Invalid port: {}\", e))\n                ))?;\n        }\n\n        if let Ok(db_path) = std::env::var(\"DAEMON_DB_PATH\") {\n            config.database.sqlite_path = db_path;\n        }\n\n        Ok(config)\n    }\n\n    /// Save configuration to file\n    pub fn save(\u0026self, path: \u0026Path) -\u003e DaemonResult\u003c()\u003e {\n        let content = serde_yaml::to_string(self)\n            .map_err(|e| crate::error::DaemonError::Config(\n                config::ConfigError::Message(format!(\"Serialization error: {}\", e))\n            ))?;\n        std::fs::write(path, content)?;\n        Ok(())\n    }\n\n    /// Validate configuration\n    pub fn validate(\u0026self) -\u003e DaemonResult\u003c()\u003e {\n        // Validate server configuration\n        if self.server.port == 0 {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Server port cannot be 0\".to_string())\n            ));\n        }\n\n        // Validate Qdrant URL\n        if self.qdrant.url.is_empty() {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Qdrant URL cannot be empty\".to_string())\n            ));\n        }\n\n        // Validate database path\n        if self.database.sqlite_path.is_empty() {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Database path cannot be empty\".to_string())\n            ));\n        }\n\n        // Validate processing configuration\n        if self.processing.default_chunk_size == 0 {\n            return Err(crate::error::DaemonError::Config(\n                config::ConfigError::Message(\"Chunk size must be greater than 0\".to_string())\n            ));\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::env;\n    use tempfile::tempdir;\n    use std::fs::File;\n    use std::io::Write;\n\n    #[test]\n    fn test_daemon_config_default() {\n        let config = DaemonConfig::default();\n\n        // Test server defaults\n        assert_eq!(config.server.host, \"127.0.0.1\");\n        assert_eq!(config.server.port, 50051);\n        assert_eq!(config.server.max_connections, 1000);\n        assert_eq!(config.server.connection_timeout_secs, 30);\n        assert_eq!(config.server.request_timeout_secs, 300);\n        assert!(!config.server.enable_tls);\n\n        // Test database defaults\n        assert_eq!(config.database.sqlite_path, \"./workspace_daemon.db\");\n        assert_eq!(config.database.max_connections, 10);\n        assert_eq!(config.database.connection_timeout_secs, 30);\n        assert!(config.database.enable_wal);\n\n        // Test qdrant defaults\n        assert_eq!(config.qdrant.url, \"http://localhost:6333\");\n        assert!(config.qdrant.api_key.is_none());\n        assert_eq!(config.qdrant.timeout_secs, 30);\n        assert_eq!(config.qdrant.max_retries, 3);\n        assert_eq!(config.qdrant.default_collection.vector_size, 384);\n        assert_eq!(config.qdrant.default_collection.distance_metric, \"Cosine\");\n        assert!(config.qdrant.default_collection.enable_indexing);\n        assert_eq!(config.qdrant.default_collection.replication_factor, 1);\n        assert_eq!(config.qdrant.default_collection.shard_number, 1);\n\n        // Test processing defaults\n        assert_eq!(config.processing.max_concurrent_tasks, 4);\n        assert_eq!(config.processing.default_chunk_size, 1000);\n        assert_eq!(config.processing.default_chunk_overlap, 200);\n        assert_eq!(config.processing.max_file_size_bytes, 100 * 1024 * 1024);\n        assert!(config.processing.supported_extensions.contains(\u0026\"rs\".to_string()));\n        assert!(config.processing.supported_extensions.contains(\u0026\"py\".to_string()));\n        assert!(config.processing.enable_lsp);\n        assert_eq!(config.processing.lsp_timeout_secs, 10);\n\n        // Test file watcher defaults\n        assert!(config.file_watcher.enabled);\n        assert_eq!(config.file_watcher.debounce_ms, 500);\n        assert_eq!(config.file_watcher.max_watched_dirs, 100);\n        assert!(config.file_watcher.ignore_patterns.contains(\u0026\"target/**\".to_string()));\n        assert!(config.file_watcher.ignore_patterns.contains(\u0026\"node_modules/**\".to_string()));\n        assert!(config.file_watcher.recursive);\n\n        // Test metrics defaults\n        assert!(config.metrics.enabled);\n        assert_eq!(config.metrics.collection_interval_secs, 60);\n        assert_eq!(config.metrics.retention_days, 30);\n        assert!(config.metrics.enable_prometheus);\n        assert_eq!(config.metrics.prometheus_port, 9090);\n\n        // Test logging defaults\n        assert_eq!(config.logging.level, \"info\");\n        assert_eq!(config.logging.file_path, Some(\"./workspace_daemon.log\".to_string()));\n        assert!(!config.logging.json_format);\n        assert_eq!(config.logging.max_file_size_mb, 100);\n        assert_eq!(config.logging.max_files, 5);\n    }\n\n    #[test]\n    fn test_daemon_config_debug_clone() {\n        let config = DaemonConfig::default();\n        let cloned = config.clone();\n\n        assert_eq!(config.server.host, cloned.server.host);\n        assert_eq!(config.qdrant.url, cloned.qdrant.url);\n\n        // Test debug format\n        let debug_str = format!(\"{:?}\", config);\n        assert!(debug_str.contains(\"DaemonConfig\"));\n        assert!(debug_str.contains(\"ServerConfig\"));\n    }\n\n    #[test]\n    fn test_load_config_from_file() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"config.yaml\");\n        let mut file = File::create(\u0026file_path).unwrap();\n\n        writeln!(file, r#\"\nserver:\n  host: \"0.0.0.0\"\n  port: 8080\n  max_connections: 500\n  connection_timeout_secs: 60\n  request_timeout_secs: 600\n  enable_tls: true\nqdrant:\n  url: \"http://remote-qdrant:6333\"\n  api_key: \"test-key\"\n  timeout_secs: 45\n  max_retries: 5\n  default_collection:\n    vector_size: 512\n    distance_metric: \"Euclidean\"\n    enable_indexing: false\n    replication_factor: 2\n    shard_number: 3\ndatabase:\n  sqlite_path: \"/custom/path.db\"\n  max_connections: 20\n  connection_timeout_secs: 45\n  enable_wal: false\nprocessing:\n  max_concurrent_tasks: 8\n  default_chunk_size: 2000\n  default_chunk_overlap: 400\n  max_file_size_bytes: 200000000\n  supported_extensions: [\"rs\", \"py\"]\n  enable_lsp: false\n  lsp_timeout_secs: 20\nfile_watcher:\n  enabled: false\n  debounce_ms: 1000\n  max_watched_dirs: 50\n  ignore_patterns: [\"*.log\"]\n  recursive: false\nmetrics:\n  enabled: false\n  collection_interval_secs: 120\n  retention_days: 60\n  enable_prometheus: false\n  prometheus_port: 9091\nlogging:\n  level: \"debug\"\n  file_path: \"/custom/log.log\"\n  json_format: true\n  max_file_size_mb: 200\n  max_files: 10\n\"#).unwrap();\n\n        let config = DaemonConfig::load(Some(\u0026file_path)).unwrap();\n\n        assert_eq!(config.server.host, \"0.0.0.0\");\n        assert_eq!(config.server.port, 8080);\n        assert_eq!(config.server.max_connections, 500);\n        assert_eq!(config.server.connection_timeout_secs, 60);\n        assert_eq!(config.server.request_timeout_secs, 600);\n        assert!(config.server.enable_tls);\n\n        assert_eq!(config.qdrant.url, \"http://remote-qdrant:6333\");\n        assert_eq!(config.qdrant.api_key, Some(\"test-key\".to_string()));\n        assert_eq!(config.qdrant.timeout_secs, 45);\n        assert_eq!(config.qdrant.max_retries, 5);\n        assert_eq!(config.qdrant.default_collection.vector_size, 512);\n        assert_eq!(config.qdrant.default_collection.distance_metric, \"Euclidean\");\n        assert!(!config.qdrant.default_collection.enable_indexing);\n        assert_eq!(config.qdrant.default_collection.replication_factor, 2);\n        assert_eq!(config.qdrant.default_collection.shard_number, 3);\n\n        assert_eq!(config.database.sqlite_path, \"/custom/path.db\");\n        assert_eq!(config.database.max_connections, 20);\n        assert_eq!(config.database.connection_timeout_secs, 45);\n        assert!(!config.database.enable_wal);\n\n        assert_eq!(config.processing.max_concurrent_tasks, 8);\n        assert_eq!(config.processing.default_chunk_size, 2000);\n        assert_eq!(config.processing.default_chunk_overlap, 400);\n        assert_eq!(config.processing.max_file_size_bytes, 200000000);\n        assert_eq!(config.processing.supported_extensions, vec![\"rs\", \"py\"]);\n        assert!(!config.processing.enable_lsp);\n        assert_eq!(config.processing.lsp_timeout_secs, 20);\n\n        assert!(!config.file_watcher.enabled);\n        assert_eq!(config.file_watcher.debounce_ms, 1000);\n        assert_eq!(config.file_watcher.max_watched_dirs, 50);\n        assert_eq!(config.file_watcher.ignore_patterns, vec![\"*.log\"]);\n        assert!(!config.file_watcher.recursive);\n\n        assert!(!config.metrics.enabled);\n        assert_eq!(config.metrics.collection_interval_secs, 120);\n        assert_eq!(config.metrics.retention_days, 60);\n        assert!(!config.metrics.enable_prometheus);\n        assert_eq!(config.metrics.prometheus_port, 9091);\n\n        assert_eq!(config.logging.level, \"debug\");\n        assert_eq!(config.logging.file_path, Some(\"/custom/log.log\".to_string()));\n        assert!(config.logging.json_format);\n        assert_eq!(config.logging.max_file_size_mb, 200);\n        assert_eq!(config.logging.max_files, 10);\n    }\n\n    #[test]\n    fn test_load_config_no_file() {\n        let config = DaemonConfig::load(None).unwrap();\n        // Should load defaults when no file is provided\n        assert_eq!(config.server.host, \"127.0.0.1\");\n        assert_eq!(config.server.port, 50051);\n    }\n\n    #[test]\n    fn test_load_config_invalid_file() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"invalid.yaml\");\n        let mut file = File::create(\u0026file_path).unwrap();\n        writeln!(file, \"invalid: yaml: content: [\").unwrap();\n\n        let result = DaemonConfig::load(Some(\u0026file_path));\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Config(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected Config error\");\n        }\n    }\n\n    #[test]\n    fn test_load_config_nonexistent_file() {\n        let nonexistent_path = Path::new(\"/nonexistent/config.yaml\");\n        let result = DaemonConfig::load(Some(nonexistent_path));\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Io(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected IO error\");\n        }\n    }\n\n    #[test]\n    fn test_from_env() {\n        // Save original env vars\n        let original_qdrant_url = env::var(\"QDRANT_URL\").ok();\n        let original_qdrant_api_key = env::var(\"QDRANT_API_KEY\").ok();\n        let original_daemon_host = env::var(\"DAEMON_HOST\").ok();\n        let original_daemon_port = env::var(\"DAEMON_PORT\").ok();\n        let original_daemon_db_path = env::var(\"DAEMON_DB_PATH\").ok();\n\n        // Set test env vars\n        env::set_var(\"QDRANT_URL\", \"http://test-qdrant:6333\");\n        env::set_var(\"QDRANT_API_KEY\", \"test-api-key\");\n        env::set_var(\"DAEMON_HOST\", \"0.0.0.0\");\n        env::set_var(\"DAEMON_PORT\", \"8080\");\n        env::set_var(\"DAEMON_DB_PATH\", \"/test/db.sqlite\");\n\n        let config = DaemonConfig::from_env().unwrap();\n\n        assert_eq!(config.qdrant.url, \"http://test-qdrant:6333\");\n        assert_eq!(config.qdrant.api_key, Some(\"test-api-key\".to_string()));\n        assert_eq!(config.server.host, \"0.0.0.0\");\n        assert_eq!(config.server.port, 8080);\n        assert_eq!(config.database.sqlite_path, \"/test/db.sqlite\");\n\n        // Restore original env vars\n        match original_qdrant_url {\n            Some(val) =\u003e env::set_var(\"QDRANT_URL\", val),\n            None =\u003e env::remove_var(\"QDRANT_URL\"),\n        }\n        match original_qdrant_api_key {\n            Some(val) =\u003e env::set_var(\"QDRANT_API_KEY\", val),\n            None =\u003e env::remove_var(\"QDRANT_API_KEY\"),\n        }\n        match original_daemon_host {\n            Some(val) =\u003e env::set_var(\"DAEMON_HOST\", val),\n            None =\u003e env::remove_var(\"DAEMON_HOST\"),\n        }\n        match original_daemon_port {\n            Some(val) =\u003e env::set_var(\"DAEMON_PORT\", val),\n            None =\u003e env::remove_var(\"DAEMON_PORT\"),\n        }\n        match original_daemon_db_path {\n            Some(val) =\u003e env::set_var(\"DAEMON_DB_PATH\", val),\n            None =\u003e env::remove_var(\"DAEMON_DB_PATH\"),\n        }\n    }\n\n    #[test]\n    fn test_env_port_parsing_error() {\n        // Test the port parsing logic directly\n        let invalid_port_str = \"invalid_port\";\n        let parse_result: Result\u003cu16, _\u003e = invalid_port_str.parse();\n        assert!(parse_result.is_err());\n\n        // Test that we can create the expected error type\n        let daemon_error = crate::error::DaemonError::Config(\n            config::ConfigError::Message(format!(\"Invalid port: {}\", parse_result.unwrap_err()))\n        );\n\n        match daemon_error {\n            crate::error::DaemonError::Config(_) =\u003e {\n                // Expected error type - test passes\n            },\n            _ =\u003e panic!(\"Expected Config error for invalid port\"),\n        }\n\n        // Test the error message formatting\n        let error_msg = format!(\"{}\", daemon_error);\n        assert!(error_msg.contains(\"Configuration error\"));\n        assert!(error_msg.contains(\"Invalid port\"));\n    }\n\n    #[test]\n    fn test_save_config() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"output.yaml\");\n\n        let config = DaemonConfig::default();\n        config.save(\u0026file_path).unwrap();\n\n        // Verify file was created and can be read back\n        assert!(file_path.exists());\n        let loaded_config = DaemonConfig::load(Some(\u0026file_path)).unwrap();\n\n        assert_eq!(config.server.host, loaded_config.server.host);\n        assert_eq!(config.server.port, loaded_config.server.port);\n        assert_eq!(config.qdrant.url, loaded_config.qdrant.url);\n    }\n\n    #[test]\n    fn test_validate_config_valid() {\n        let config = DaemonConfig::default();\n        assert!(config.validate().is_ok());\n    }\n\n    #[test]\n    fn test_validate_config_invalid_port() {\n        let mut config = DaemonConfig::default();\n        config.server.port = 0;\n\n        let result = config.validate();\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Config(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected Config error for invalid port\");\n        }\n    }\n\n    #[test]\n    fn test_validate_config_empty_qdrant_url() {\n        let mut config = DaemonConfig::default();\n        config.qdrant.url = String::new();\n\n        let result = config.validate();\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Config(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected Config error for empty Qdrant URL\");\n        }\n    }\n\n    #[test]\n    fn test_validate_config_empty_database_path() {\n        let mut config = DaemonConfig::default();\n        config.database.sqlite_path = String::new();\n\n        let result = config.validate();\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Config(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected Config error for empty database path\");\n        }\n    }\n\n    #[test]\n    fn test_validate_config_zero_chunk_size() {\n        let mut config = DaemonConfig::default();\n        config.processing.default_chunk_size = 0;\n\n        let result = config.validate();\n        assert!(result.is_err());\n\n        if let Err(crate::error::DaemonError::Config(_)) = result {\n            // Expected error type\n        } else {\n            panic!(\"Expected Config error for zero chunk size\");\n        }\n    }\n\n    #[test]\n    fn test_serialization_roundtrip() {\n        let config = DaemonConfig::default();\n\n        // Test YAML serialization\n        let yaml_str = serde_yaml::to_string(\u0026config).unwrap();\n        let deserialized: DaemonConfig = serde_yaml::from_str(\u0026yaml_str).unwrap();\n\n        assert_eq!(config.server.host, deserialized.server.host);\n        assert_eq!(config.server.port, deserialized.server.port);\n        assert_eq!(config.qdrant.url, deserialized.qdrant.url);\n\n        // Test JSON serialization\n        let json_str = serde_json::to_string(\u0026config).unwrap();\n        let deserialized: DaemonConfig = serde_json::from_str(\u0026json_str).unwrap();\n\n        assert_eq!(config.server.host, deserialized.server.host);\n        assert_eq!(config.qdrant.url, deserialized.qdrant.url);\n    }\n\n    #[test]\n    fn test_config_structs_are_send_sync() {\n        fn assert_send_sync\u003cT: Send + Sync\u003e() {}\n\n        assert_send_sync::\u003cDaemonConfig\u003e();\n        assert_send_sync::\u003cServerConfig\u003e();\n        assert_send_sync::\u003cDatabaseConfig\u003e();\n        assert_send_sync::\u003cQdrantConfig\u003e();\n        assert_send_sync::\u003cCollectionConfig\u003e();\n        assert_send_sync::\u003cProcessingConfig\u003e();\n        assert_send_sync::\u003cFileWatcherConfig\u003e();\n        assert_send_sync::\u003cMetricsConfig\u003e();\n        assert_send_sync::\u003cLoggingConfig\u003e();\n    }\n\n    #[test]\n    fn test_collection_config_standalone() {\n        let collection_config = CollectionConfig {\n            vector_size: 768,\n            distance_metric: \"Dot\".to_string(),\n            enable_indexing: false,\n            replication_factor: 3,\n            shard_number: 2,\n        };\n\n        let debug_str = format!(\"{:?}\", collection_config);\n        assert!(debug_str.contains(\"CollectionConfig\"));\n        assert!(debug_str.contains(\"768\"));\n        assert!(debug_str.contains(\"Dot\"));\n\n        let cloned = collection_config.clone();\n        assert_eq!(collection_config.vector_size, cloned.vector_size);\n        assert_eq!(collection_config.distance_metric, cloned.distance_metric);\n    }\n\n    #[test]\n    fn test_config_with_serde_defaults() {\n        // Test that all config structs can be created with minimal YAML\n        // This tests basic serialization/deserialization\n        let minimal_yaml = r#\"\nserver:\n  host: \"custom-host\"\n  port: 9999\n  max_connections: 500\n  connection_timeout_secs: 30\n  request_timeout_secs: 300\n  enable_tls: false\nqdrant:\n  url: \"http://custom-qdrant:6333\"\n  api_key: null\n  timeout_secs: 30\n  max_retries: 3\n  default_collection:\n    vector_size: 384\n    distance_metric: \"Cosine\"\n    enable_indexing: true\n    replication_factor: 1\n    shard_number: 1\ndatabase:\n  sqlite_path: \"./workspace_daemon.db\"\n  max_connections: 10\n  connection_timeout_secs: 30\n  enable_wal: true\nprocessing:\n  max_concurrent_tasks: 4\n  default_chunk_size: 1000\n  default_chunk_overlap: 200\n  max_file_size_bytes: 104857600\n  supported_extensions: [\"rs\", \"py\"]\n  enable_lsp: true\n  lsp_timeout_secs: 10\nfile_watcher:\n  enabled: true\n  debounce_ms: 500\n  max_watched_dirs: 100\n  ignore_patterns: [\"target/**\"]\n  recursive: true\nmetrics:\n  enabled: true\n  collection_interval_secs: 60\n  retention_days: 30\n  enable_prometheus: true\n  prometheus_port: 9090\nlogging:\n  level: \"info\"\n  file_path: \"./workspace_daemon.log\"\n  json_format: false\n  max_file_size_mb: 100\n  max_files: 5\n\"#;\n\n        let config: DaemonConfig = serde_yaml::from_str(minimal_yaml).unwrap();\n\n        // Custom fields should be set\n        assert_eq!(config.server.host, \"custom-host\");\n        assert_eq!(config.server.port, 9999);\n        assert_eq!(config.qdrant.url, \"http://custom-qdrant:6333\");\n    }\n}","traces":[{"line":183,"address":[],"length":0,"stats":{"Line":11}},{"line":185,"address":[],"length":0,"stats":{"Line":22}},{"line":193,"address":[],"length":0,"stats":{"Line":22}},{"line":199,"address":[],"length":0,"stats":{"Line":22}},{"line":212,"address":[],"length":0,"stats":{"Line":22}},{"line":232,"address":[],"length":0,"stats":{"Line":22}},{"line":245,"address":[],"length":0,"stats":{"Line":22}},{"line":252,"address":[],"length":0,"stats":{"Line":11}},{"line":265,"address":[],"length":0,"stats":{"Line":5}},{"line":266,"address":[],"length":0,"stats":{"Line":5}},{"line":267,"address":[],"length":0,"stats":{"Line":4}},{"line":268,"address":[],"length":0,"stats":{"Line":12}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":4}},{"line":287,"address":[],"length":0,"stats":{"Line":3}},{"line":291,"address":[],"length":0,"stats":{"Line":4}},{"line":295,"address":[],"length":0,"stats":{"Line":3}},{"line":299,"address":[],"length":0,"stats":{"Line":3}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":3}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":315,"address":[],"length":0,"stats":{"Line":3}},{"line":316,"address":[],"length":0,"stats":{"Line":1}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":1}},{"line":324,"address":[],"length":0,"stats":{"Line":102}},{"line":326,"address":[],"length":0,"stats":{"Line":102}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":1}},{"line":334,"address":[],"length":0,"stats":{"Line":2}},{"line":335,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":342,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":1}},{"line":349,"address":[],"length":0,"stats":{"Line":1}}],"covered":36,"coverable":39},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","daemon","core.rs"],"content":"//! Core daemon functionality\n\nuse crate::error::{DaemonError, DaemonResult};\nuse tracing::{info, debug};\n\n/// Core daemon utilities\n#[derive(Debug)]\npub struct DaemonCore;\n\nimpl DaemonCore {\n    /// Initialize daemon core\n    pub fn new() -\u003e Self {\n        info!(\"Initializing daemon core\");\n        Self\n    }\n\n    /// Get system information\n    pub fn get_system_info() -\u003e DaemonResult\u003cSystemInfo\u003e {\n        Ok(SystemInfo {\n            cpu_count: num_cpus::get(),\n            memory_total: Self::get_total_memory(),\n            hostname: hostname::get()\n                .map_err(|e| DaemonError::System { message: format!(\"Failed to get hostname: {}\", e) })?\n                .to_string_lossy()\n                .to_string(),\n        })\n    }\n\n    /// Get total system memory (placeholder implementation)\n    fn get_total_memory() -\u003e u64 {\n        // TODO: Implement actual memory detection\n        8 * 1024 * 1024 * 1024 // 8GB placeholder\n    }\n}\n\n/// System information\n#[derive(Debug, Clone)]\npub struct SystemInfo {\n    pub cpu_count: usize,\n    pub memory_total: u64,\n    pub hostname: String,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_daemon_core_new() {\n        let core = DaemonCore::new();\n        // Just ensure we can create an instance\n        let debug_str = format!(\"{:?}\", core);\n        assert!(!debug_str.is_empty());\n    }\n\n    #[test]\n    fn test_get_system_info() {\n        let system_info = DaemonCore::get_system_info().unwrap();\n\n        // CPU count should be at least 1\n        assert!(system_info.cpu_count \u003e 0);\n\n        // Memory should be the placeholder value\n        assert_eq!(system_info.memory_total, 8 * 1024 * 1024 * 1024);\n\n        // Hostname should not be empty\n        assert!(!system_info.hostname.is_empty());\n\n        // Test debug formatting\n        let debug_str = format!(\"{:?}\", system_info);\n        assert!(debug_str.contains(\"SystemInfo\"));\n        assert!(debug_str.contains(\u0026system_info.hostname));\n    }\n\n    #[test]\n    fn test_get_total_memory() {\n        let memory = DaemonCore::get_total_memory();\n        assert_eq!(memory, 8 * 1024 * 1024 * 1024); // 8GB placeholder\n    }\n\n    #[test]\n    fn test_system_info_clone() {\n        let original = SystemInfo {\n            cpu_count: 4,\n            memory_total: 1024,\n            hostname: \"test-host\".to_string(),\n        };\n\n        let cloned = original.clone();\n        assert_eq!(original.cpu_count, cloned.cpu_count);\n        assert_eq!(original.memory_total, cloned.memory_total);\n        assert_eq!(original.hostname, cloned.hostname);\n    }\n\n    #[test]\n    fn test_system_info_debug() {\n        let info = SystemInfo {\n            cpu_count: 8,\n            memory_total: 16 * 1024 * 1024 * 1024,\n            hostname: \"debug-test\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", info);\n        assert!(debug_str.contains(\"SystemInfo\"));\n        assert!(debug_str.contains(\"8\"));\n        assert!(debug_str.contains(\"debug-test\"));\n    }\n\n    #[test]\n    fn test_daemon_core_is_unit_struct() {\n        let core1 = DaemonCore::new();\n        let core2 = DaemonCore::new();\n\n        // Both instances should have the same size (unit struct)\n        assert_eq!(\n            std::mem::size_of_val(\u0026core1),\n            std::mem::size_of_val(\u0026core2)\n        );\n        assert_eq!(std::mem::size_of::\u003cDaemonCore\u003e(), 0);\n    }\n}","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":3}},{"line":13,"address":[],"length":0,"stats":{"Line":3}},{"line":14,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}}],"covered":11,"coverable":11},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","daemon","mod.rs"],"content":"//! Core daemon implementation for workspace document processing\n\npub mod core;\npub mod state;\npub mod processing;\npub mod watcher;\n\nuse crate::config::DaemonConfig;\nuse crate::error::{DaemonError, DaemonResult};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{info, warn};\n\n/// Main daemon coordinator\n#[derive(Debug, Clone)]\npub struct WorkspaceDaemon {\n    config: DaemonConfig,\n    state: Arc\u003cRwLock\u003cstate::DaemonState\u003e\u003e,\n    processing: Arc\u003cprocessing::DocumentProcessor\u003e,\n    watcher: Option\u003cArc\u003cwatcher::FileWatcher\u003e\u003e,\n}\n\nimpl WorkspaceDaemon {\n    /// Create a new daemon instance\n    pub async fn new(config: DaemonConfig) -\u003e DaemonResult\u003cSelf\u003e {\n        // Validate configuration\n        config.validate()?;\n\n        info!(\"Initializing Workspace Daemon with config: {:?}\", config);\n\n        // Initialize state management\n        let state = Arc::new(RwLock::new(\n            state::DaemonState::new(\u0026config.database).await?\n        ));\n\n        // Initialize document processor\n        let processing = Arc::new(\n            processing::DocumentProcessor::new(\u0026config.processing, \u0026config.qdrant).await?\n        );\n\n        // Initialize file watcher if enabled\n        let watcher = if config.file_watcher.enabled {\n            Some(Arc::new(\n                watcher::FileWatcher::new(\u0026config.file_watcher, Arc::clone(\u0026processing)).await?\n            ))\n        } else {\n            None\n        };\n\n        Ok(Self {\n            config,\n            state,\n            processing,\n            watcher,\n        })\n    }\n\n    /// Start all daemon services\n    pub async fn start(\u0026mut self) -\u003e DaemonResult\u003c()\u003e {\n        info!(\"Starting daemon services\");\n\n        // Start file watcher if enabled\n        if let Some(ref watcher) = self.watcher {\n            watcher.start().await?;\n            info!(\"File watcher started\");\n        }\n\n        info!(\"All daemon services started successfully\");\n        Ok(())\n    }\n\n    /// Stop all daemon services\n    pub async fn stop(\u0026mut self) -\u003e DaemonResult\u003c()\u003e {\n        info!(\"Stopping daemon services\");\n\n        // Stop file watcher\n        if let Some(ref watcher) = self.watcher {\n            watcher.stop().await?;\n            info!(\"File watcher stopped\");\n        }\n\n        info!(\"All daemon services stopped\");\n        Ok(())\n    }\n\n    /// Get daemon configuration\n    pub fn config(\u0026self) -\u003e \u0026DaemonConfig {\n        \u0026self.config\n    }\n\n    /// Get daemon state (read-only)\n    pub async fn state(\u0026self) -\u003e tokio::sync::RwLockReadGuard\u003cstate::DaemonState\u003e {\n        self.state.read().await\n    }\n\n    /// Get daemon state (read-write)\n    pub async fn state_mut(\u0026self) -\u003e tokio::sync::RwLockWriteGuard\u003cstate::DaemonState\u003e {\n        self.state.write().await\n    }\n\n    /// Get document processor\n    pub fn processor(\u0026self) -\u003e \u0026Arc\u003cprocessing::DocumentProcessor\u003e {\n        \u0026self.processing\n    }\n\n    /// Get file watcher\n    pub fn watcher(\u0026self) -\u003e Option\u003c\u0026Arc\u003cwatcher::FileWatcher\u003e\u003e {\n        self.watcher.as_ref()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use tempfile::TempDir;\n    use tokio_test;\n    use std::path::PathBuf;\n    use uuid::Uuid;\n\n    fn create_test_config() -\u003e DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\".to_string();\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50051,\n                max_connections: 1000,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 300,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path,\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: crate::config::CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 4,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 100,\n                max_file_size_bytes: 1000000,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 100,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: crate::config::MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: crate::config::LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    fn create_test_config_with_watcher() -\u003e DaemonConfig {\n        let mut config = create_test_config();\n        config.file_watcher.enabled = true;\n        config\n    }\n\n    #[tokio::test]\n    async fn test_workspace_daemon_new_success() {\n        let config = create_test_config();\n        let result = WorkspaceDaemon::new(config).await;\n\n        assert!(result.is_ok());\n        let daemon = result.unwrap();\n        assert_eq!(daemon.config().database.max_connections, 5);\n        assert_eq!(daemon.config().qdrant.url, \"http://localhost:6333\");\n        assert!(daemon.watcher().is_none());\n    }\n\n    #[tokio::test]\n    async fn test_workspace_daemon_new_with_watcher() {\n        let config = create_test_config_with_watcher();\n        let result = WorkspaceDaemon::new(config).await;\n\n        assert!(result.is_ok());\n        let daemon = result.unwrap();\n        assert!(daemon.watcher().is_some());\n    }\n\n    #[tokio::test]\n    async fn test_workspace_daemon_debug_format() {\n        let config = create_test_config();\n        let daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        let debug_str = format!(\"{:?}\", daemon);\n        assert!(debug_str.contains(\"WorkspaceDaemon\"));\n    }\n\n    #[tokio::test]\n    async fn test_daemon_config_access() {\n        let config = create_test_config();\n        let original_max_connections = config.database.max_connections;\n        let daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        assert_eq!(daemon.config().database.max_connections, original_max_connections);\n    }\n\n    #[tokio::test]\n    async fn test_daemon_state_access() {\n        let config = create_test_config();\n        let daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        let state = daemon.state().await;\n        // Test that we can access state\n        drop(state);\n\n        let state_mut = daemon.state_mut().await;\n        // Test that we can access mutable state\n        drop(state_mut);\n    }\n\n    #[tokio::test]\n    async fn test_daemon_processor_access() {\n        let config = create_test_config();\n        let daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        let processor1 = daemon.processor();\n        let processor2 = daemon.processor();\n        assert!(Arc::ptr_eq(\u0026processor1, \u0026processor2)); // Should be same Arc\n    }\n\n    #[tokio::test]\n    async fn test_daemon_start_stop_cycle() {\n        let config = create_test_config();\n        let mut daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        // Test start\n        let start_result = daemon.start().await;\n        assert!(start_result.is_ok());\n\n        // Test stop\n        let stop_result = daemon.stop().await;\n        assert!(stop_result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_daemon_start_stop_with_watcher() {\n        let config = create_test_config_with_watcher();\n        let mut daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        // Test start with watcher\n        let start_result = daemon.start().await;\n        assert!(start_result.is_ok());\n\n        // Test stop with watcher\n        let stop_result = daemon.stop().await;\n        assert!(stop_result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_daemon_start_disabled_watcher() {\n        let config = create_test_config(); // watcher disabled\n        let mut daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        let start_result = daemon.start().await;\n        assert!(start_result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_daemon_multiple_start_stop_cycles() {\n        let config = create_test_config();\n        let mut daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        // Multiple start/stop cycles\n        for _ in 0..3 {\n            assert!(daemon.start().await.is_ok());\n            assert!(daemon.stop().await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_daemon_watcher_option_handling() {\n        // Test with watcher disabled\n        let config_disabled = create_test_config();\n        let daemon_disabled = WorkspaceDaemon::new(config_disabled).await.unwrap();\n        assert!(daemon_disabled.watcher().is_none());\n\n        // Test with watcher enabled\n        let config_enabled = create_test_config_with_watcher();\n        let daemon_enabled = WorkspaceDaemon::new(config_enabled).await.unwrap();\n        assert!(daemon_enabled.watcher().is_some());\n    }\n\n    #[tokio::test]\n    async fn test_daemon_concurrent_state_access() {\n        let config = create_test_config();\n        let daemon = Arc::new(WorkspaceDaemon::new(config).await.unwrap());\n\n        let daemon1 = Arc::clone(\u0026daemon);\n        let daemon2 = Arc::clone(\u0026daemon);\n\n        let handle1 = tokio::spawn(async move {\n            let _state = daemon1.state().await;\n            tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;\n        });\n\n        let handle2 = tokio::spawn(async move {\n            let _state = daemon2.state().await;\n            tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;\n        });\n\n        let (r1, r2) = tokio::join!(handle1, handle2);\n        assert!(r1.is_ok());\n        assert!(r2.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_daemon_processor_arc_sharing() {\n        let config = create_test_config();\n        let daemon = WorkspaceDaemon::new(config).await.unwrap();\n\n        let processor1 = daemon.processor();\n        let processor2 = daemon.processor();\n\n        // Both should point to the same Arc\u003cDocumentProcessor\u003e\n        assert!(Arc::ptr_eq(processor1, processor2));\n    }\n\n    #[tokio::test]\n    async fn test_daemon_error_handling_invalid_config() {\n        let mut config = create_test_config();\n\n        // Make config invalid by setting empty URL\n        config.qdrant.url = String::new();\n\n        let result = WorkspaceDaemon::new(config).await;\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_daemon_struct_send_sync() {\n        fn assert_send\u003cT: Send\u003e() {}\n        fn assert_sync\u003cT: Sync\u003e() {}\n\n        assert_send::\u003cWorkspaceDaemon\u003e();\n        assert_sync::\u003cWorkspaceDaemon\u003e();\n    }\n}","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":194}},{"line":27,"address":[],"length":0,"stats":{"Line":195}},{"line":29,"address":[],"length":0,"stats":{"Line":96}},{"line":32,"address":[],"length":0,"stats":{"Line":96}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":96}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":12}},{"line":47,"address":[],"length":0,"stats":{"Line":93}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":7}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":73,"address":[],"length":0,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":5}},{"line":87,"address":[],"length":0,"stats":{"Line":21}},{"line":88,"address":[],"length":0,"stats":{"Line":21}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":8}}],"covered":28,"coverable":32},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","daemon","processing.rs"],"content":"//! Document processing engine\n\nuse crate::config::{ProcessingConfig, QdrantConfig};\nuse crate::error::{DaemonError, DaemonResult};\nuse std::sync::Arc;\nuse tokio::sync::Semaphore;\nuse tracing::{info, debug};\n\n/// Document processor\n#[derive(Debug)]\npub struct DocumentProcessor {\n    config: ProcessingConfig,\n    qdrant_config: QdrantConfig,\n    semaphore: Arc\u003cSemaphore\u003e,\n}\n\nimpl DocumentProcessor {\n    /// Create a new document processor\n    pub async fn new(config: \u0026ProcessingConfig, qdrant_config: \u0026QdrantConfig) -\u003e DaemonResult\u003cSelf\u003e {\n        info!(\"Initializing document processor with max concurrent tasks: {}\", config.max_concurrent_tasks);\n\n        let semaphore = Arc::new(Semaphore::new(config.max_concurrent_tasks));\n\n        Ok(Self {\n            config: config.clone(),\n            qdrant_config: qdrant_config.clone(),\n            semaphore,\n        })\n    }\n\n    /// Process a single document\n    pub async fn process_document(\u0026self, file_path: \u0026str) -\u003e DaemonResult\u003cString\u003e {\n        let _permit = self.semaphore.acquire().await\n            .map_err(|e| DaemonError::Internal { message: format!(\"Semaphore error: {}\", e) })?;\n\n        debug!(\"Processing document: {}\", file_path);\n\n        // TODO: Implement actual document processing\n        // This is a placeholder\n        tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n\n        Ok(uuid::Uuid::new_v4().to_string())\n    }\n\n    /// Get processing configuration\n    pub fn config(\u0026self) -\u003e \u0026ProcessingConfig {\n        \u0026self.config\n    }\n\n    /// Create a test instance for testing purposes\n    #[cfg(any(test, feature = \"test-utils\"))]\n    pub fn test_instance() -\u003e Self {\n        let config = ProcessingConfig {\n            max_concurrent_tasks: 2,\n            default_chunk_size: 1000,\n            default_chunk_overlap: 200,\n            max_file_size_bytes: 1024 * 1024,\n            supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n            enable_lsp: false,\n            lsp_timeout_secs: 10,\n        };\n\n        let qdrant_config = QdrantConfig {\n            url: \"http://localhost:6333\".to_string(),\n            api_key: None,\n            timeout_secs: 30,\n            max_retries: 3,\n            default_collection: crate::config::CollectionConfig {\n                vector_size: 384,\n                distance_metric: \"Cosine\".to_string(),\n                enable_indexing: true,\n                replication_factor: 1,\n                shard_number: 1,\n            },\n        };\n\n        let semaphore = Arc::new(Semaphore::new(config.max_concurrent_tasks));\n\n        Self {\n            config,\n            qdrant_config,\n            semaphore,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{ProcessingConfig, QdrantConfig, CollectionConfig};\n    use std::sync::Arc;\n    use tracing_subscriber;\n\n    fn create_test_processing_config() -\u003e ProcessingConfig {\n        ProcessingConfig {\n            max_concurrent_tasks: 2,\n            default_chunk_size: 1000,\n            default_chunk_overlap: 200,\n            max_file_size_bytes: 1024 * 1024,\n            supported_extensions: vec![\"rs\".to_string(), \"py\".to_string()],\n            enable_lsp: true,\n            lsp_timeout_secs: 10,\n        }\n    }\n\n    fn create_test_qdrant_config() -\u003e QdrantConfig {\n        QdrantConfig {\n            url: \"http://localhost:6333\".to_string(),\n            api_key: None,\n            timeout_secs: 30,\n            max_retries: 3,\n            default_collection: CollectionConfig {\n                vector_size: 384,\n                distance_metric: \"Cosine\".to_string(),\n                enable_indexing: true,\n                replication_factor: 1,\n                shard_number: 1,\n            },\n        }\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_new() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        // Test that the processor was created successfully\n        assert_eq!(processor.config().max_concurrent_tasks, 2);\n        assert_eq!(processor.config().default_chunk_size, 1000);\n        assert_eq!(processor.config().default_chunk_overlap, 200);\n        assert_eq!(processor.config().max_file_size_bytes, 1024 * 1024);\n        assert!(processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 10);\n\n        // Test debug formatting\n        let debug_str = format!(\"{:?}\", processor);\n        assert!(debug_str.contains(\"DocumentProcessor\"));\n    }\n\n    #[tokio::test]\n    async fn test_process_document() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        let result = processor.process_document(\"test_file.rs\").await.unwrap();\n\n        // Should return a UUID string\n        assert_eq!(result.len(), 36); // UUID v4 string length\n        assert!(result.contains('-'));\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_processing() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .unwrap(),\n        );\n\n        let mut handles = vec![];\n\n        // Spawn multiple concurrent tasks\n        for i in 0..4 {\n            let processor_clone = Arc::clone(\u0026processor);\n            let handle = tokio::spawn(async move {\n                processor_clone\n                    .process_document(\u0026format!(\"test_file_{}.rs\", i))\n                    .await\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all tasks to complete\n        let results: Vec\u003c_\u003e = futures_util::future::join_all(handles).await;\n\n        // All tasks should complete successfully\n        for result in results {\n            let task_result = result.unwrap();\n            assert!(task_result.is_ok());\n            let uuid_str = task_result.unwrap();\n            assert_eq!(uuid_str.len(), 36);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_config_access() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        let config = processor.config();\n        assert_eq!(config.max_concurrent_tasks, 2);\n        assert_eq!(config.default_chunk_size, 1000);\n        assert_eq!(config.supported_extensions, vec![\"rs\", \"py\"]);\n    }\n\n    #[tokio::test]\n    async fn test_semaphore_limits() {\n        let mut processing_config = create_test_processing_config();\n        processing_config.max_concurrent_tasks = 1; // Allow only 1 concurrent task\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .unwrap(),\n        );\n\n        let start_time = std::time::Instant::now();\n\n        let processor1 = Arc::clone(\u0026processor);\n        let processor2 = Arc::clone(\u0026processor);\n\n        let handle1 = tokio::spawn(async move {\n            processor1.process_document(\"test1.rs\").await\n        });\n\n        let handle2 = tokio::spawn(async move {\n            processor2.process_document(\"test2.rs\").await\n        });\n\n        let (result1, result2) = tokio::join!(handle1, handle2);\n\n        // Both should succeed\n        assert!(result1.unwrap().is_ok());\n        assert!(result2.unwrap().is_ok());\n\n        // Should take at least 200ms due to semaphore limiting concurrency\n        let elapsed = start_time.elapsed();\n        assert!(elapsed \u003e= std::time::Duration::from_millis(150));\n    }\n\n    #[tokio::test]\n    async fn test_processor_with_different_configs() {\n        let mut config1 = create_test_processing_config();\n        config1.max_concurrent_tasks = 1;\n        config1.default_chunk_size = 500;\n\n        let mut config2 = create_test_processing_config();\n        config2.max_concurrent_tasks = 5;\n        config2.default_chunk_size = 2000;\n\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor1 = DocumentProcessor::new(\u0026config1, \u0026qdrant_config)\n            .await\n            .unwrap();\n        let processor2 = DocumentProcessor::new(\u0026config2, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        assert_eq!(processor1.config().max_concurrent_tasks, 1);\n        assert_eq!(processor1.config().default_chunk_size, 500);\n\n        assert_eq!(processor2.config().max_concurrent_tasks, 5);\n        assert_eq!(processor2.config().default_chunk_size, 2000);\n    }\n\n    #[tokio::test]\n    async fn test_various_file_extensions() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        let test_files = vec![\n            \"test.rs\",\n            \"script.py\",\n            \"document.md\",\n            \"data.json\",\n            \"page.html\",\n        ];\n\n        for file in test_files {\n            let result = processor.process_document(file).await;\n            assert!(result.is_ok(), \"Failed to process file: {}\", file);\n            let uuid_str = result.unwrap();\n            assert_eq!(uuid_str.len(), 36);\n        }\n    }\n\n    #[test]\n    fn test_instance_creation() {\n        let processor = DocumentProcessor::test_instance();\n\n        // Test that test_instance creates processor with expected config\n        assert_eq!(processor.config().max_concurrent_tasks, 2);\n        assert_eq!(processor.config().default_chunk_size, 1000);\n        assert_eq!(processor.config().default_chunk_overlap, 200);\n        assert_eq!(processor.config().max_file_size_bytes, 1024 * 1024);\n        assert_eq!(processor.config().supported_extensions, vec![\"txt\", \"md\"]);\n        assert!(!processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 10);\n\n        // Test that qdrant_config is properly set\n        assert_eq!(processor.qdrant_config.url, \"http://localhost:6333\");\n        assert_eq!(processor.qdrant_config.api_key, None);\n        assert_eq!(processor.qdrant_config.timeout_secs, 30);\n        assert_eq!(processor.qdrant_config.max_retries, 3);\n        assert_eq!(processor.qdrant_config.default_collection.vector_size, 384);\n        assert_eq!(processor.qdrant_config.default_collection.distance_metric, \"Cosine\");\n        assert!(processor.qdrant_config.default_collection.enable_indexing);\n        assert_eq!(processor.qdrant_config.default_collection.replication_factor, 1);\n        assert_eq!(processor.qdrant_config.default_collection.shard_number, 1);\n    }\n\n    #[tokio::test]\n    async fn test_semaphore_error_handling() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        // Close the semaphore to force an error condition\n        processor.semaphore.close();\n\n        let result = processor.process_document(\"test_file.rs\").await;\n        assert!(result.is_err());\n\n        match result {\n            Err(DaemonError::Internal { message }) =\u003e {\n                assert!(message.contains(\"Semaphore error\"));\n            }\n            _ =\u003e panic!(\"Expected Internal error with semaphore message\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_process_document_uuid_generation() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        // Process multiple documents and ensure UUIDs are unique\n        let mut uuids = std::collections::HashSet::new();\n\n        for i in 0..10 {\n            let result = processor.process_document(\u0026format!(\"test_{}.rs\", i)).await.unwrap();\n            assert_eq!(result.len(), 36);\n            assert!(result.contains('-'));\n\n            // Parse as UUID to ensure validity\n            let uuid = uuid::Uuid::parse_str(\u0026result).unwrap();\n            assert_eq!(uuid.get_version_num(), 4); // UUID v4\n\n            // Ensure uniqueness\n            assert!(uuids.insert(result), \"UUID should be unique\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_processor_configuration_variants() {\n        // Test with minimal configuration\n        let minimal_config = ProcessingConfig {\n            max_concurrent_tasks: 1,\n            default_chunk_size: 100,\n            default_chunk_overlap: 0,\n            max_file_size_bytes: 1024,\n            supported_extensions: vec![],\n            enable_lsp: false,\n            lsp_timeout_secs: 1,\n        };\n\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026minimal_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        assert_eq!(processor.config().max_concurrent_tasks, 1);\n        assert_eq!(processor.config().default_chunk_size, 100);\n        assert_eq!(processor.config().default_chunk_overlap, 0);\n        assert_eq!(processor.config().max_file_size_bytes, 1024);\n        assert!(processor.config().supported_extensions.is_empty());\n        assert!(!processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 1);\n\n        // Test processing with minimal config\n        let result = processor.process_document(\"minimal_test.txt\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_processor_configuration_maximal() {\n        // Test with maximal configuration\n        let maximal_config = ProcessingConfig {\n            max_concurrent_tasks: 100,\n            default_chunk_size: 10000,\n            default_chunk_overlap: 2000,\n            max_file_size_bytes: 100 * 1024 * 1024, // 100MB\n            supported_extensions: vec![\n                \"rs\".to_string(), \"py\".to_string(), \"js\".to_string(),\n                \"ts\".to_string(), \"java\".to_string(), \"cpp\".to_string(),\n                \"c\".to_string(), \"h\".to_string(), \"hpp\".to_string(),\n                \"md\".to_string(), \"txt\".to_string(), \"json\".to_string(),\n            ],\n            enable_lsp: true,\n            lsp_timeout_secs: 60,\n        };\n\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026maximal_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        assert_eq!(processor.config().max_concurrent_tasks, 100);\n        assert_eq!(processor.config().default_chunk_size, 10000);\n        assert_eq!(processor.config().default_chunk_overlap, 2000);\n        assert_eq!(processor.config().max_file_size_bytes, 100 * 1024 * 1024);\n        assert_eq!(processor.config().supported_extensions.len(), 12);\n        assert!(processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 60);\n\n        // Test processing with maximal config\n        let result = processor.process_document(\"maximal_test.cpp\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_qdrant_config_variants() {\n        let processing_config = create_test_processing_config();\n\n        // Test with API key\n        let qdrant_with_key = QdrantConfig {\n            url: \"https://cloud.qdrant.io\".to_string(),\n            api_key: Some(\"test-api-key\".to_string()),\n            timeout_secs: 60,\n            max_retries: 5,\n            default_collection: CollectionConfig {\n                vector_size: 768,\n                distance_metric: \"Dot\".to_string(),\n                enable_indexing: false,\n                replication_factor: 2,\n                shard_number: 4,\n            },\n        };\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_with_key)\n            .await\n            .unwrap();\n\n        assert_eq!(processor.qdrant_config.url, \"https://cloud.qdrant.io\");\n        assert_eq!(processor.qdrant_config.api_key, Some(\"test-api-key\".to_string()));\n        assert_eq!(processor.qdrant_config.timeout_secs, 60);\n        assert_eq!(processor.qdrant_config.max_retries, 5);\n        assert_eq!(processor.qdrant_config.default_collection.vector_size, 768);\n        assert_eq!(processor.qdrant_config.default_collection.distance_metric, \"Dot\");\n        assert!(!processor.qdrant_config.default_collection.enable_indexing);\n        assert_eq!(processor.qdrant_config.default_collection.replication_factor, 2);\n        assert_eq!(processor.qdrant_config.default_collection.shard_number, 4);\n    }\n\n    #[tokio::test]\n    async fn test_debug_implementation() {\n        let processor = DocumentProcessor::test_instance();\n\n        let debug_str = format!(\"{:?}\", processor);\n        assert!(debug_str.contains(\"DocumentProcessor\"));\n        assert!(debug_str.contains(\"config\"));\n        assert!(debug_str.contains(\"qdrant_config\"));\n        assert!(debug_str.contains(\"semaphore\"));\n    }\n\n    #[tokio::test]\n    async fn test_empty_file_path() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        let result = processor.process_document(\"\").await;\n        assert!(result.is_ok()); // Should handle empty path gracefully\n        let uuid_str = result.unwrap();\n        assert_eq!(uuid_str.len(), 36);\n    }\n\n    #[tokio::test]\n    async fn test_very_long_file_path() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        // Create a very long file path\n        let long_path = \"a\".repeat(1000) + \".rs\";\n        let result = processor.process_document(\u0026long_path).await;\n        assert!(result.is_ok()); // Should handle long paths gracefully\n        let uuid_str = result.unwrap();\n        assert_eq!(uuid_str.len(), 36);\n    }\n\n    #[tokio::test]\n    async fn test_special_characters_in_file_path() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        let special_paths = vec![\n            \"file with spaces.rs\",\n            \"file-with-dashes.py\",\n            \"file_with_underscores.md\",\n            \"file.with.dots.txt\",\n            \"file@with#special$chars%.json\",\n            \"file(with)parentheses.rs\",\n            \"file[with]brackets.py\",\n            \"file{with}braces.md\",\n        ];\n\n        for path in special_paths {\n            let result = processor.process_document(path).await;\n            assert!(result.is_ok(), \"Failed to process file: {}\", path);\n            let uuid_str = result.unwrap();\n            assert_eq!(uuid_str.len(), 36);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_unicode_file_paths() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        let unicode_paths = vec![\n            \".rs\", // Russian\n            \".py\", // Chinese\n            \".md\", // Japanese\n            \".txt\", // Korean\n            \".json\", // Greek\n            \".rs\", // Hindi\n            \"rocket.py\", // Emoji\n        ];\n\n        for path in unicode_paths {\n            let result = processor.process_document(path).await;\n            assert!(result.is_ok(), \"Failed to process unicode file: {}\", path);\n            let uuid_str = result.unwrap();\n            assert_eq!(uuid_str.len(), 36);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_debug_logging_coverage() {\n        // This test ensures the debug! logging line is executed\n        // Initialize tracing subscriber to capture debug logs\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::DEBUG)\n            .try_init();\n\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        // This call will trigger the debug! statement on line 36\n        let result = processor.process_document(\"debug_test.rs\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_info_logging_coverage() {\n        // This test ensures the info! logging line is executed\n        // Initialize tracing subscriber to capture info logs\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::INFO)\n            .try_init();\n\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        // This call will trigger the info! statement on line 20\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        assert_eq!(processor.config().max_concurrent_tasks, 2);\n    }\n\n    #[tokio::test]\n    async fn test_complete_processing_pipeline() {\n        // Comprehensive test that exercises the complete processing pipeline\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        // Test processor creation (covers info! logging)\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .unwrap();\n\n        // Test configuration access\n        let config = processor.config();\n        assert!(config.enable_lsp);\n        assert_eq!(config.supported_extensions, vec![\"rs\", \"py\"]);\n\n        // Test document processing with various scenarios\n        let test_scenarios = vec![\n            (\"simple.rs\", \"Simple Rust file\"),\n            (\"\", \"Empty path\"),\n            (\"very/deep/nested/path/file.py\", \"Deeply nested path\"),\n            (\"file with spaces.md\", \"Path with spaces\"),\n            (\".txt\", \"Unicode filename\"),\n        ];\n\n        for (path, description) in test_scenarios {\n            let result = processor.process_document(path).await;\n            assert!(result.is_ok(), \"Failed to process {}: {}\", description, path);\n\n            let uuid_str = result.unwrap();\n            assert_eq!(uuid_str.len(), 36, \"Invalid UUID length for {}\", description);\n\n            // Verify it's a valid UUID v4\n            let uuid = uuid::Uuid::parse_str(\u0026uuid_str)\n                .expect(\u0026format!(\"Invalid UUID format for {}\", description));\n            assert_eq!(uuid.get_version_num(), 4, \"Expected UUID v4 for {}\", description);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_processor_struct_fields() {\n        // Test to ensure all struct fields are properly initialized and accessible\n        let processor = DocumentProcessor::test_instance();\n\n        // Test config field\n        assert_eq!(processor.config.max_concurrent_tasks, 2);\n        assert_eq!(processor.config.default_chunk_size, 1000);\n        assert_eq!(processor.config.default_chunk_overlap, 200);\n        assert_eq!(processor.config.max_file_size_bytes, 1024 * 1024);\n        assert_eq!(processor.config.supported_extensions, vec![\"txt\", \"md\"]);\n        assert!(!processor.config.enable_lsp);\n        assert_eq!(processor.config.lsp_timeout_secs, 10);\n\n        // Test qdrant_config field\n        assert_eq!(processor.qdrant_config.url, \"http://localhost:6333\");\n        assert_eq!(processor.qdrant_config.api_key, None);\n        assert_eq!(processor.qdrant_config.timeout_secs, 30);\n        assert_eq!(processor.qdrant_config.max_retries, 3);\n        assert_eq!(processor.qdrant_config.default_collection.vector_size, 384);\n        assert_eq!(processor.qdrant_config.default_collection.distance_metric, \"Cosine\");\n        assert!(processor.qdrant_config.default_collection.enable_indexing);\n        assert_eq!(processor.qdrant_config.default_collection.replication_factor, 1);\n        assert_eq!(processor.qdrant_config.default_collection.shard_number, 1);\n\n        // Test semaphore field by verifying it works\n        let permit = processor.semaphore.acquire().await.unwrap();\n        drop(permit); // Release permit\n    }\n}","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":232}},{"line":20,"address":[],"length":0,"stats":{"Line":116}},{"line":22,"address":[],"length":0,"stats":{"Line":464}},{"line":24,"address":[],"length":0,"stats":{"Line":116}},{"line":25,"address":[],"length":0,"stats":{"Line":348}},{"line":26,"address":[],"length":0,"stats":{"Line":232}},{"line":27,"address":[],"length":0,"stats":{"Line":116}},{"line":32,"address":[],"length":0,"stats":{"Line":96}},{"line":33,"address":[],"length":0,"stats":{"Line":95}},{"line":34,"address":[],"length":0,"stats":{"Line":52}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":47}},{"line":46,"address":[],"length":0,"stats":{"Line":35}},{"line":47,"address":[],"length":0,"stats":{"Line":35}},{"line":52,"address":[],"length":0,"stats":{"Line":43}},{"line":57,"address":[],"length":0,"stats":{"Line":86}},{"line":58,"address":[],"length":0,"stats":{"Line":172}},{"line":64,"address":[],"length":0,"stats":{"Line":129}},{"line":68,"address":[],"length":0,"stats":{"Line":43}},{"line":77,"address":[],"length":0,"stats":{"Line":172}}],"covered":19,"coverable":20},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","daemon","state.rs"],"content":"//! Daemon state management using SQLite\n\nuse crate::config::DatabaseConfig;\nuse crate::error::{DaemonError, DaemonResult};\nuse sqlx::SqlitePool;\nuse tracing::{info, debug};\n\n/// Daemon state manager\n#[derive(Debug)]\npub struct DaemonState {\n    pool: SqlitePool,\n}\n\nimpl DaemonState {\n    /// Create a new state manager\n    pub async fn new(config: \u0026DatabaseConfig) -\u003e DaemonResult\u003cSelf\u003e {\n        info!(\"Initializing database at: {}\", config.sqlite_path);\n\n        let pool = SqlitePool::connect(\u0026config.sqlite_path).await?;\n\n        // Run migrations\n        Self::run_migrations(\u0026pool).await?;\n\n        Ok(Self { pool })\n    }\n\n    /// Run database migrations\n    async fn run_migrations(pool: \u0026SqlitePool) -\u003e DaemonResult\u003c()\u003e {\n        debug!(\"Running database migrations\");\n\n        // Create projects table\n        sqlx::query(r#\"\n            CREATE TABLE IF NOT EXISTS projects (\n                id TEXT PRIMARY KEY,\n                name TEXT NOT NULL,\n                root_path TEXT NOT NULL UNIQUE,\n                git_repository TEXT,\n                git_branch TEXT,\n                metadata TEXT, -- JSON\n                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n            )\n        \"#)\n        .execute(pool)\n        .await?;\n\n        // Create collections table\n        sqlx::query(r#\"\n            CREATE TABLE IF NOT EXISTS collections (\n                id TEXT PRIMARY KEY,\n                name TEXT NOT NULL,\n                project_id TEXT NOT NULL,\n                config TEXT, -- JSON\n                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (project_id) REFERENCES projects (id),\n                UNIQUE (name, project_id)\n            )\n        \"#)\n        .execute(pool)\n        .await?;\n\n        // Create processing_operations table\n        sqlx::query(r#\"\n            CREATE TABLE IF NOT EXISTS processing_operations (\n                id TEXT PRIMARY KEY,\n                project_id TEXT,\n                status TEXT NOT NULL,\n                total_documents INTEGER DEFAULT 0,\n                processed_documents INTEGER DEFAULT 0,\n                failed_documents INTEGER DEFAULT 0,\n                error_messages TEXT, -- JSON array\n                started_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (project_id) REFERENCES projects (id)\n            )\n        \"#)\n        .execute(pool)\n        .await?;\n\n        info!(\"Database migrations completed\");\n        Ok(())\n    }\n\n    /// Get the connection pool\n    pub fn pool(\u0026self) -\u003e \u0026SqlitePool {\n        \u0026self.pool\n    }\n\n    /// Health check\n    pub async fn health_check(\u0026self) -\u003e DaemonResult\u003c()\u003e {\n        sqlx::query(\"SELECT 1\")\n            .execute(\u0026self.pool)\n            .await?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use sqlx::Row;\n    use tokio::time::{timeout, Duration};\n\n    fn create_test_db_config() -\u003e DatabaseConfig {\n        DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 1,\n            connection_timeout_secs: 5,\n            enable_wal: false,\n        }\n    }\n\n    fn create_test_db_config_with_wal() -\u003e DatabaseConfig {\n        DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 5,\n            connection_timeout_secs: 10,\n            enable_wal: true,\n        }\n    }\n\n    #[tokio::test]\n    async fn test_daemon_state_new_basic() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Test that the state was created successfully\n        assert!(!state.pool().is_closed());\n\n        // Test debug formatting\n        let debug_str = format!(\"{:?}\", state);\n        assert!(debug_str.contains(\"DaemonState\"));\n    }\n\n    #[tokio::test]\n    async fn test_daemon_state_new_with_wal() {\n        let config = create_test_db_config_with_wal();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        assert!(!state.pool().is_closed());\n        state.health_check().await.unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_daemon_state_new_custom_config() {\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 3,\n            connection_timeout_secs: 15,\n            enable_wal: false,\n        };\n\n        let state = DaemonState::new(\u0026config).await.unwrap();\n        assert!(!state.pool().is_closed());\n\n        // Verify logging by checking info! logs are called during initialization\n        // This tests the logging paths in the new() method\n    }\n\n    #[tokio::test]\n    async fn test_health_check_success() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Health check should pass\n        let result = state.health_check().await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_health_check_multiple_calls() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Multiple health checks should all pass\n        for _ in 0..5 {\n            state.health_check().await.unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_pool_access() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Pool should be accessible\n        let pool = state.pool();\n        assert!(!pool.is_closed());\n\n        // Test that we can use the pool reference\n        sqlx::query(\"SELECT 1\")\n            .execute(pool)\n            .await\n            .unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_migrations_create_all_tables() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Verify all tables were created by querying them\n        let projects_result = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' AND name='projects'\")\n            .fetch_optional(state.pool())\n            .await\n            .unwrap();\n        assert!(projects_result.is_some());\n\n        let collections_result = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' AND name='collections'\")\n            .fetch_optional(state.pool())\n            .await\n            .unwrap();\n        assert!(collections_result.is_some());\n\n        let processing_ops_result = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' AND name='processing_operations'\")\n            .fetch_optional(state.pool())\n            .await\n            .unwrap();\n        assert!(processing_ops_result.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_migrations_table_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Test projects table schema\n        let projects_schema = sqlx::query(\"PRAGMA table_info(projects)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n        assert!(!projects_schema.is_empty());\n\n        // Verify expected columns exist\n        let column_names: Vec\u003cString\u003e = projects_schema\n            .iter()\n            .map(|row| row.get::\u003cString, _\u003e(\"name\"))\n            .collect();\n        assert!(column_names.contains(\u0026\"id\".to_string()));\n        assert!(column_names.contains(\u0026\"name\".to_string()));\n        assert!(column_names.contains(\u0026\"root_path\".to_string()));\n        assert!(column_names.contains(\u0026\"git_repository\".to_string()));\n        assert!(column_names.contains(\u0026\"metadata\".to_string()));\n        assert!(column_names.contains(\u0026\"created_at\".to_string()));\n        assert!(column_names.contains(\u0026\"updated_at\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_migrations_collections_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Test collections table schema\n        let collections_schema = sqlx::query(\"PRAGMA table_info(collections)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n        assert!(!collections_schema.is_empty());\n\n        let column_names: Vec\u003cString\u003e = collections_schema\n            .iter()\n            .map(|row| row.get::\u003cString, _\u003e(\"name\"))\n            .collect();\n        assert!(column_names.contains(\u0026\"id\".to_string()));\n        assert!(column_names.contains(\u0026\"name\".to_string()));\n        assert!(column_names.contains(\u0026\"project_id\".to_string()));\n        assert!(column_names.contains(\u0026\"config\".to_string()));\n        assert!(column_names.contains(\u0026\"created_at\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_migrations_processing_operations_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Test processing_operations table schema\n        let processing_ops_schema = sqlx::query(\"PRAGMA table_info(processing_operations)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n        assert!(!processing_ops_schema.is_empty());\n\n        let column_names: Vec\u003cString\u003e = processing_ops_schema\n            .iter()\n            .map(|row| row.get::\u003cString, _\u003e(\"name\"))\n            .collect();\n        assert!(column_names.contains(\u0026\"id\".to_string()));\n        assert!(column_names.contains(\u0026\"project_id\".to_string()));\n        assert!(column_names.contains(\u0026\"status\".to_string()));\n        assert!(column_names.contains(\u0026\"total_documents\".to_string()));\n        assert!(column_names.contains(\u0026\"processed_documents\".to_string()));\n        assert!(column_names.contains(\u0026\"failed_documents\".to_string()));\n        assert!(column_names.contains(\u0026\"error_messages\".to_string()));\n        assert!(column_names.contains(\u0026\"started_at\".to_string()));\n        assert!(column_names.contains(\u0026\"updated_at\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_migrations_foreign_keys() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Enable foreign key constraints\n        sqlx::query(\"PRAGMA foreign_keys = ON\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        // Test that foreign key constraints work\n        // First, insert a project\n        sqlx::query(\"INSERT INTO projects (id, name, root_path) VALUES ('test-project', 'Test Project', '/test')\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        // Then, insert a collection referencing the project\n        let result = sqlx::query(\"INSERT INTO collections (id, name, project_id) VALUES ('test-collection', 'Test Collection', 'test-project')\")\n            .execute(state.pool())\n            .await;\n        assert!(result.is_ok());\n\n        // Try inserting a collection with invalid project_id (should fail)\n        let invalid_result = sqlx::query(\"INSERT INTO collections (id, name, project_id) VALUES ('invalid-collection', 'Invalid Collection', 'nonexistent-project')\")\n            .execute(state.pool())\n            .await;\n        assert!(invalid_result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_migrations_unique_constraints() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Test unique constraint on projects.root_path\n        sqlx::query(\"INSERT INTO projects (id, name, root_path) VALUES ('project1', 'Project 1', '/same/path')\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        // Second insert with same root_path should fail\n        let duplicate_result = sqlx::query(\"INSERT INTO projects (id, name, root_path) VALUES ('project2', 'Project 2', '/same/path')\")\n            .execute(state.pool())\n            .await;\n        assert!(duplicate_result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_migrations_default_values() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Insert minimal data to test defaults\n        sqlx::query(\"INSERT INTO projects (id, name, root_path) VALUES ('minimal-project', 'Minimal Project', '/minimal')\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        // Verify default values are set\n        let row = sqlx::query(\"SELECT created_at, updated_at FROM projects WHERE id = 'minimal-project'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n\n        let created_at: String = row.get(\"created_at\");\n        let updated_at: String = row.get(\"updated_at\");\n        assert!(!created_at.is_empty());\n        assert!(!updated_at.is_empty());\n\n        // Test processing_operations defaults\n        sqlx::query(\"INSERT INTO processing_operations (id, status) VALUES ('test-op', 'running')\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        let op_row = sqlx::query(\"SELECT total_documents, processed_documents, failed_documents, started_at FROM processing_operations WHERE id = 'test-op'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n\n        let total_docs: i64 = op_row.get(\"total_documents\");\n        let processed_docs: i64 = op_row.get(\"processed_documents\");\n        let failed_docs: i64 = op_row.get(\"failed_documents\");\n        let started_at: String = op_row.get(\"started_at\");\n\n        assert_eq!(total_docs, 0);\n        assert_eq!(processed_docs, 0);\n        assert_eq!(failed_docs, 0);\n        assert!(!started_at.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_invalid_database_path() {\n        let config = DatabaseConfig {\n            sqlite_path: \"/invalid/path/db.sqlite\".to_string(),\n            max_connections: 1,\n            connection_timeout_secs: 5,\n            enable_wal: false,\n        };\n\n        let result = DaemonState::new(\u0026config).await;\n        assert!(result.is_err());\n\n        // Verify it's a database error\n        match result {\n            Err(DaemonError::Database(_)) =\u003e {},\n            _ =\u003e panic!(\"Expected Database error for invalid path\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_run_migrations_directly() {\n        let config = create_test_db_config();\n        let pool = SqlitePool::connect(\u0026config.sqlite_path).await.unwrap();\n\n        // Test migrations run successfully\n        let result = DaemonState::run_migrations(\u0026pool).await;\n        assert!(result.is_ok());\n\n        // Test running migrations again (should be idempotent)\n        let result2 = DaemonState::run_migrations(\u0026pool).await;\n        assert!(result2.is_ok());\n\n        // Verify tables exist after direct migration call\n        let tables = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\")\n            .fetch_all(\u0026pool)\n            .await\n            .unwrap();\n\n        let table_names: Vec\u003cString\u003e = tables.iter().map(|row| row.get::\u003cString, _\u003e(\"name\")).collect();\n        assert!(table_names.contains(\u0026\"projects\".to_string()));\n        assert!(table_names.contains(\u0026\"collections\".to_string()));\n        assert!(table_names.contains(\u0026\"processing_operations\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_run_migrations_logging() {\n        let config = create_test_db_config();\n        let pool = SqlitePool::connect(\u0026config.sqlite_path).await.unwrap();\n\n        // This test ensures the debug! logging paths are covered\n        let result = DaemonState::run_migrations(\u0026pool).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_database_config_variations() {\n        // Test various database configurations\n        let configs = vec![\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 1,\n                connection_timeout_secs: 5,\n                enable_wal: false,\n            },\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 10,\n                enable_wal: true,\n            },\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 10,\n                connection_timeout_secs: 30,\n                enable_wal: false,\n            },\n        ];\n\n        for config in configs {\n            let state = DaemonState::new(\u0026config).await.unwrap();\n            state.health_check().await.unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_multiple_state_instances() {\n        let config1 = create_test_db_config();\n        let config2 = create_test_db_config();\n\n        let state1 = DaemonState::new(\u0026config1).await.unwrap();\n        let state2 = DaemonState::new(\u0026config2).await.unwrap();\n\n        // Both should be functional\n        state1.health_check().await.unwrap();\n        state2.health_check().await.unwrap();\n\n        // Test cross-state operations\n        assert!(!state1.pool().is_closed());\n        assert!(!state2.pool().is_closed());\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_health_checks() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Run multiple health checks concurrently\n        let futures = (0..10).map(|_| state.health_check()).collect::\u003cVec\u003c_\u003e\u003e();\n        let results = futures_util::future::try_join_all(futures).await;\n        assert!(results.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_database_operations_after_init() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Test basic database operations work after initialization\n        let result = sqlx::query(\"INSERT INTO projects (id, name, root_path) VALUES ('test', 'Test Project', '/test/path')\")\n            .execute(state.pool())\n            .await;\n        assert!(result.is_ok());\n\n        let count: (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM projects\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n        assert_eq!(count.0, 1);\n    }\n\n    #[tokio::test]\n    async fn test_pool_state_after_operations() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Perform several database operations\n        for i in 0..5 {\n            sqlx::query(\u0026format!(\"INSERT INTO projects (id, name, root_path) VALUES ('project{}', 'Project {}', '/path/{}')\", i, i, i))\n                .execute(state.pool())\n                .await\n                .unwrap();\n        }\n\n        // Pool should still be healthy\n        state.health_check().await.unwrap();\n        assert!(!state.pool().is_closed());\n    }\n\n    #[tokio::test]\n    async fn test_state_debug_formatting() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Test comprehensive debug formatting\n        let debug_str = format!(\"{:?}\", state);\n        assert!(debug_str.contains(\"DaemonState\"));\n        assert!(!debug_str.is_empty());\n\n        // Debug should not expose sensitive information\n        assert!(!debug_str.contains(\"password\"));\n        assert!(!debug_str.contains(\"secret\"));\n    }\n\n    #[tokio::test]\n    async fn test_health_check_error_recovery() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Verify health check works initially\n        state.health_check().await.unwrap();\n\n        // Pool should remain functional\n        assert!(!state.pool().is_closed());\n\n        // Multiple health checks should continue to work\n        for _ in 0..3 {\n            state.health_check().await.unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_database_config_edge_cases() {\n        // Test various edge case configurations\n        let edge_configs = vec![\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 1,  // Minimum connections\n                connection_timeout_secs: 1,  // Short timeout\n                enable_wal: false,\n            },\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 100,  // High connections\n                connection_timeout_secs: 300,  // Long timeout\n                enable_wal: true,\n            },\n        ];\n\n        for config in edge_configs {\n            let state = DaemonState::new(\u0026config).await.unwrap();\n            state.health_check().await.unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_migration_logging_paths() {\n        let config = create_test_db_config();\n\n        // Create state to trigger migration logging\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Verify the state is functional (ensures logging didn't break anything)\n        state.health_check().await.unwrap();\n\n        // Test that pool is accessible after logging\n        let pool = state.pool();\n        assert!(!pool.is_closed());\n    }\n\n    #[tokio::test]\n    async fn test_error_handling_coverage() {\n        // Test various error scenarios to improve coverage\n\n        // Test with completely invalid path format\n        let bad_config = DatabaseConfig {\n            sqlite_path: \"invalid://path\".to_string(),\n            max_connections: 1,\n            connection_timeout_secs: 5,\n            enable_wal: false,\n        };\n\n        let result = DaemonState::new(\u0026bad_config).await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_all_code_paths_covered() {\n        // This test aims to hit any remaining uncovered code paths\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Test all public methods\n        let pool_ref = state.pool();\n        assert!(!pool_ref.is_closed());\n\n        // Test health check multiple times\n        state.health_check().await.unwrap();\n        state.health_check().await.unwrap();\n\n        // Test debug formatting\n        let _debug = format!(\"{:?}\", state);\n\n        // Test with timeout to ensure async paths are covered\n        let health_result = timeout(Duration::from_secs(5), state.health_check()).await;\n        assert!(health_result.is_ok());\n        assert!(health_result.unwrap().is_ok());\n    }\n}","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":250}},{"line":17,"address":[],"length":0,"stats":{"Line":125}},{"line":19,"address":[],"length":0,"stats":{"Line":375}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":123}},{"line":28,"address":[],"length":0,"stats":{"Line":252}},{"line":29,"address":[],"length":0,"stats":{"Line":126}},{"line":44,"address":[],"length":0,"stats":{"Line":252}},{"line":45,"address":[],"length":0,"stats":{"Line":126}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":126}},{"line":85,"address":[],"length":0,"stats":{"Line":33}},{"line":86,"address":[],"length":0,"stats":{"Line":33}},{"line":90,"address":[],"length":0,"stats":{"Line":66}},{"line":91,"address":[],"length":0,"stats":{"Line":99}},{"line":92,"address":[],"length":0,"stats":{"Line":66}},{"line":93,"address":[],"length":0,"stats":{"Line":33}},{"line":94,"address":[],"length":0,"stats":{"Line":33}}],"covered":16,"coverable":19},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","daemon","watcher.rs"],"content":"//! File system watcher for automatic document processing\n\nuse crate::config::FileWatcherConfig;\nuse crate::daemon::processing::DocumentProcessor;\nuse crate::error::{DaemonError, DaemonResult};\nuse notify::{RecommendedWatcher, RecursiveMode, Event};\nuse std::sync::Arc;\nuse std::path::Path;\nuse tokio::sync::{mpsc, Mutex};\nuse tracing::{info, debug, warn, error};\n\n/// File watcher\n#[derive(Debug)]\npub struct FileWatcher {\n    config: FileWatcherConfig,\n    processor: Arc\u003cDocumentProcessor\u003e,\n    watcher: Arc\u003cMutex\u003cOption\u003cRecommendedWatcher\u003e\u003e\u003e,\n}\n\nimpl FileWatcher {\n    /// Create a new file watcher\n    pub async fn new(config: \u0026FileWatcherConfig, processor: Arc\u003cDocumentProcessor\u003e) -\u003e DaemonResult\u003cSelf\u003e {\n        info!(\"Initializing file watcher (enabled: {})\", config.enabled);\n\n        Ok(Self {\n            config: config.clone(),\n            processor,\n            watcher: Arc::new(Mutex::new(None)),\n        })\n    }\n\n    /// Start watching for file changes\n    pub async fn start(\u0026self) -\u003e DaemonResult\u003c()\u003e {\n        if !self.config.enabled {\n            info!(\"File watcher is disabled\");\n            return Ok(());\n        }\n\n        info!(\"Starting file watcher\");\n\n        // TODO: Implement actual file watching\n        // This is a placeholder implementation\n\n        Ok(())\n    }\n\n    /// Stop watching for file changes\n    pub async fn stop(\u0026self) -\u003e DaemonResult\u003c()\u003e {\n        info!(\"Stopping file watcher\");\n\n        // TODO: Implement actual stop logic\n\n        Ok(())\n    }\n\n    /// Add a directory to watch\n    pub async fn watch_directory\u003cP: AsRef\u003cPath\u003e\u003e(\u0026mut self, path: P) -\u003e DaemonResult\u003c()\u003e {\n        let path = path.as_ref();\n        info!(\"Adding directory to watch: {}\", path.display());\n\n        // TODO: Implement actual directory watching\n\n        Ok(())\n    }\n\n    /// Remove a directory from watching\n    pub async fn unwatch_directory\u003cP: AsRef\u003cPath\u003e\u003e(\u0026mut self, path: P) -\u003e DaemonResult\u003c()\u003e {\n        let path = path.as_ref();\n        info!(\"Removing directory from watch: {}\", path.display());\n\n        // TODO: Implement actual directory unwatching\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{FileWatcherConfig, ProcessingConfig, QdrantConfig};\n    use tempfile::TempDir;\n    use std::path::PathBuf;\n    use std::sync::Arc;\n    use tokio_test;\n\n    fn create_test_config(enabled: bool) -\u003e FileWatcherConfig {\n        FileWatcherConfig {\n            enabled,\n            debounce_ms: 100,\n            max_watched_dirs: 10,\n            ignore_patterns: vec![\"*.tmp\".to_string(), \"*.log\".to_string()],\n            recursive: true,\n        }\n    }\n\n    fn create_test_processor() -\u003e Arc\u003cDocumentProcessor\u003e {\n        // Use test instance for reliable testing\n        Arc::new(DocumentProcessor::test_instance())\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_new_enabled() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let result = FileWatcher::new(\u0026config, processor).await;\n        assert!(result.is_ok());\n\n        let watcher = result.unwrap();\n        assert_eq!(watcher.config.enabled, true);\n        assert_eq!(watcher.config.debounce_ms, 100);\n        assert_eq!(watcher.config.max_watched_dirs, 10);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_new_disabled() {\n        let config = create_test_config(false);\n        let processor = create_test_processor();\n\n        let result = FileWatcher::new(\u0026config, processor).await;\n        assert!(result.is_ok());\n\n        let watcher = result.unwrap();\n        assert_eq!(watcher.config.enabled, false);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_debug_format() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n        let debug_str = format!(\"{:?}\", watcher);\n\n        assert!(debug_str.contains(\"FileWatcher\"));\n        assert!(debug_str.contains(\"config\"));\n        assert!(debug_str.contains(\"processor\"));\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_start_enabled() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n        let result = watcher.start().await;\n\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_start_disabled() {\n        let config = create_test_config(false);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n        let result = watcher.start().await;\n\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_stop() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // Start then stop\n        assert!(watcher.start().await.is_ok());\n        assert!(watcher.stop().await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_watch_directory() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        let temp_dir = TempDir::new().unwrap();\n        let result = watcher.watch_directory(temp_dir.path()).await;\n\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_watch_directory_string_path() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        let result = watcher.watch_directory(\"/tmp\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_unwatch_directory() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        let temp_dir = TempDir::new().unwrap();\n\n        // Watch then unwatch\n        assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n        assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_unwatch_directory_string_path() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        let result = watcher.unwatch_directory(\"/tmp\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_multiple_directories() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        let temp_dir1 = TempDir::new().unwrap();\n        let temp_dir2 = TempDir::new().unwrap();\n\n        // Watch multiple directories\n        assert!(watcher.watch_directory(temp_dir1.path()).await.is_ok());\n        assert!(watcher.watch_directory(temp_dir2.path()).await.is_ok());\n\n        // Unwatch them\n        assert!(watcher.unwatch_directory(temp_dir1.path()).await.is_ok());\n        assert!(watcher.unwatch_directory(temp_dir2.path()).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_start_stop_multiple_times() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // Multiple start/stop cycles\n        for _ in 0..3 {\n            assert!(watcher.start().await.is_ok());\n            assert!(watcher.stop().await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_config_clone() {\n        let config = create_test_config(true);\n        let config_clone = config.clone();\n\n        assert_eq!(config.enabled, config_clone.enabled);\n        assert_eq!(config.debounce_ms, config_clone.debounce_ms);\n        assert_eq!(config.max_watched_dirs, config_clone.max_watched_dirs);\n        assert_eq!(config.ignore_patterns, config_clone.ignore_patterns);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_processor_arc_sharing() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let processor_clone = Arc::clone(\u0026processor);\n\n        let watcher = FileWatcher::new(\u0026config, processor_clone).await.unwrap();\n\n        // Test that the processor Arc is properly shared\n        assert!(Arc::strong_count(\u0026processor) \u003e= 2);\n    }\n\n    #[test]\n    fn test_file_watcher_send_sync() {\n        fn assert_send\u003cT: Send\u003e() {}\n        fn assert_sync\u003cT: Sync\u003e() {}\n\n        assert_send::\u003cFileWatcher\u003e();\n        assert_sync::\u003cFileWatcher\u003e();\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_with_ignore_patterns() {\n        let mut config = create_test_config(true);\n        config.ignore_patterns = vec![\n            \"*.tmp\".to_string(),\n            \"*.log\".to_string(),\n            \"target/*\".to_string(),\n        ];\n\n        let processor = create_test_processor();\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        assert_eq!(watcher.config.ignore_patterns.len(), 3);\n        assert!(watcher.config.ignore_patterns.contains(\u0026\"*.tmp\".to_string()));\n        assert!(watcher.config.ignore_patterns.contains(\u0026\"*.log\".to_string()));\n        assert!(watcher.config.ignore_patterns.contains(\u0026\"target/*\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_with_custom_debounce() {\n        let mut config = create_test_config(true);\n        config.debounce_ms = 1000;\n\n        let processor = create_test_processor();\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        assert_eq!(watcher.config.debounce_ms, 1000);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_with_edge_case_configs() {\n        // Test with zero debounce\n        let mut config = create_test_config(true);\n        config.debounce_ms = 0;\n        config.max_watched_dirs = 0;\n\n        let processor = create_test_processor();\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        assert_eq!(watcher.config.debounce_ms, 0);\n        assert_eq!(watcher.config.max_watched_dirs, 0);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_with_maximal_config() {\n        let mut config = create_test_config(true);\n        config.debounce_ms = u64::MAX;\n        config.max_watched_dirs = usize::MAX;\n        config.ignore_patterns = vec![\n            \"*.tmp\".to_string(),\n            \"*.log\".to_string(),\n            \"target/**\".to_string(),\n            \"node_modules/**\".to_string(),\n            \".git/**\".to_string(),\n            \"*.backup\".to_string(),\n            \"*.swp\".to_string(),\n            \"*~\".to_string(),\n        ];\n        config.recursive = true;\n\n        let processor = create_test_processor();\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        assert_eq!(watcher.config.debounce_ms, u64::MAX);\n        assert_eq!(watcher.config.max_watched_dirs, usize::MAX);\n        assert_eq!(watcher.config.ignore_patterns.len(), 8);\n        assert!(watcher.config.recursive);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_watcher_field_initialization() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // Verify the watcher field is properly initialized as None\n        let watcher_guard = watcher.watcher.lock().await;\n        assert!(watcher_guard.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_processor_field_access() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let processor_weak_count = Arc::weak_count(\u0026processor);\n\n        let watcher = FileWatcher::new(\u0026config, processor.clone()).await.unwrap();\n\n        // Verify processor is properly stored and accessible\n        assert!(Arc::ptr_eq(\u0026watcher.processor, \u0026processor));\n        assert!(Arc::weak_count(\u0026processor) \u003e= processor_weak_count);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_config_field_values() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // Verify all config fields are properly cloned and stored\n        assert_eq!(watcher.config.enabled, config.enabled);\n        assert_eq!(watcher.config.debounce_ms, config.debounce_ms);\n        assert_eq!(watcher.config.max_watched_dirs, config.max_watched_dirs);\n        assert_eq!(watcher.config.ignore_patterns, config.ignore_patterns);\n        assert_eq!(watcher.config.recursive, config.recursive);\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_logging_levels() {\n        // Test that logging statements are executed by configuring tracing\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::DEBUG)\n            .try_init();\n\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        // This will trigger the info! logging on line 23\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // This will trigger the info! logging on line 39\n        assert!(watcher.start().await.is_ok());\n\n        // This will trigger the info! logging on line 49\n        assert!(watcher.stop().await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_disabled_logging() {\n        // Test the disabled path logging\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::INFO)\n            .try_init();\n\n        let config = create_test_config(false); // disabled\n        let processor = create_test_processor();\n\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // This will trigger the \"File watcher is disabled\" info! logging on line 35\n        assert!(watcher.start().await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_watch_directory_logging() {\n        // Test directory watching logging\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::INFO)\n            .try_init();\n\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        let temp_dir = TempDir::new().unwrap();\n\n        // This will trigger the info! logging on line 59\n        assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_unwatch_directory_logging() {\n        // Test directory unwatching logging\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::INFO)\n            .try_init();\n\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        let temp_dir = TempDir::new().unwrap();\n\n        // This will trigger the info! logging on line 69\n        assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_path_as_ref_implementations() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        let temp_dir = TempDir::new().unwrap();\n        let path_buf = temp_dir.path().to_path_buf();\n        let path_str = temp_dir.path().to_str().unwrap();\n\n        // Test different AsRef\u003cPath\u003e implementations\n        assert!(watcher.watch_directory(\u0026path_buf).await.is_ok());\n        assert!(watcher.watch_directory(path_str).await.is_ok());\n        assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n\n        assert!(watcher.unwatch_directory(\u0026path_buf).await.is_ok());\n        assert!(watcher.unwatch_directory(path_str).await.is_ok());\n        assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_complex_paths() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // Test complex path scenarios\n        let complex_paths = vec![\n            \"/tmp\",\n            \"/tmp/subdir\",\n            \"./relative/path\",\n            \"../parent/path\",\n            \"/path/with spaces/dir\",\n            \"/path/with-dashes/dir\",\n            \"/path/with_underscores/dir\",\n            \"/path/with.dots/dir\",\n        ];\n\n        for path in complex_paths {\n            assert!(watcher.watch_directory(path).await.is_ok());\n            assert!(watcher.unwatch_directory(path).await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_unicode_paths() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        let unicode_paths = vec![\n            \"/tmp/\",     // Russian\n            \"/tmp/\",         // Chinese\n            \"/tmp/\",       // Japanese\n            \"/tmp/\",       // Korean\n            \"/tmp/\",    // Greek\n            \"/tmp/\",      // Hindi\n            \"/tmp/rocket\",     // Emoji\n        ];\n\n        for path in unicode_paths {\n            assert!(watcher.watch_directory(path).await.is_ok());\n            assert!(watcher.unwatch_directory(path).await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_empty_path() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // Test empty path\n        assert!(watcher.watch_directory(\"\").await.is_ok());\n        assert!(watcher.unwatch_directory(\"\").await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_very_long_path() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // Test very long path\n        let long_path = format!(\"/tmp/{}\", \"a\".repeat(1000));\n        assert!(watcher.watch_directory(\u0026long_path).await.is_ok());\n        assert!(watcher.unwatch_directory(\u0026long_path).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_rapid_operations() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // Test rapid start/stop operations\n        for _ in 0..10 {\n            assert!(watcher.start().await.is_ok());\n            assert!(watcher.stop().await.is_ok());\n        }\n\n        // Test rapid watch/unwatch operations\n        let temp_dir = TempDir::new().unwrap();\n        for _ in 0..10 {\n            assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n            assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_concurrent_operations() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let watcher = Arc::new(Mutex::new(\n            FileWatcher::new(\u0026config, processor).await.unwrap()\n        ));\n\n        let mut handles = vec![];\n\n        // Spawn concurrent start/stop operations\n        for i in 0..5 {\n            let watcher_clone = Arc::clone(\u0026watcher);\n            let handle = tokio::spawn(async move {\n                let watcher = watcher_clone.lock().await;\n                if i % 2 == 0 {\n                    watcher.start().await\n                } else {\n                    watcher.stop().await\n                }\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all operations to complete\n        let results = futures_util::future::join_all(handles).await;\n\n        // All operations should succeed\n        for result in results {\n            assert!(result.unwrap().is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_concurrent_directory_operations() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let watcher = Arc::new(Mutex::new(\n            FileWatcher::new(\u0026config, processor).await.unwrap()\n        ));\n\n        let temp_dirs: Vec\u003c_\u003e = (0..5).map(|_| TempDir::new().unwrap()).collect();\n        let mut handles = vec![];\n\n        // Spawn concurrent watch operations\n        for (i, temp_dir) in temp_dirs.iter().enumerate() {\n            let watcher_clone = Arc::clone(\u0026watcher);\n            let path = temp_dir.path().to_path_buf();\n            let handle = tokio::spawn(async move {\n                let mut watcher = watcher_clone.lock().await;\n                if i % 2 == 0 {\n                    watcher.watch_directory(\u0026path).await\n                } else {\n                    watcher.unwatch_directory(\u0026path).await\n                }\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all operations to complete\n        let results = futures_util::future::join_all(handles).await;\n\n        // All operations should succeed\n        for result in results {\n            assert!(result.unwrap().is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_stress_test() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // Stress test with many operations\n        let temp_dirs: Vec\u003c_\u003e = (0..50).map(|_| TempDir::new().unwrap()).collect();\n\n        // Watch all directories\n        for temp_dir in \u0026temp_dirs {\n            assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n        }\n\n        // Multiple start/stop cycles\n        for _ in 0..20 {\n            assert!(watcher.start().await.is_ok());\n            assert!(watcher.stop().await.is_ok());\n        }\n\n        // Unwatch all directories\n        for temp_dir in \u0026temp_dirs {\n            assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_all_config_combinations() {\n        let processor = create_test_processor();\n\n        // Test all boolean combinations\n        let config_combinations = vec![\n            (true, true),   // enabled, recursive\n            (true, false),  // enabled, not recursive\n            (false, true),  // disabled, recursive\n            (false, false), // disabled, not recursive\n        ];\n\n        for (enabled, recursive) in config_combinations {\n            let mut config = create_test_config(enabled);\n            config.recursive = recursive;\n\n            let watcher = FileWatcher::new(\u0026config, processor.clone()).await.unwrap();\n\n            assert_eq!(watcher.config.enabled, enabled);\n            assert_eq!(watcher.config.recursive, recursive);\n\n            // Test that all operations work regardless of config\n            assert!(watcher.start().await.is_ok());\n            assert!(watcher.stop().await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_config_boundary_values() {\n        let processor = create_test_processor();\n\n        // Test boundary values for numeric fields\n        let boundary_configs = vec![\n            (0, 0),                    // minimum values\n            (1, 1),                    // just above minimum\n            (u64::MAX, usize::MAX),    // maximum values\n            (1000, 100),               // typical values\n        ];\n\n        for (debounce_ms, max_watched_dirs) in boundary_configs {\n            let mut config = create_test_config(true);\n            config.debounce_ms = debounce_ms;\n            config.max_watched_dirs = max_watched_dirs;\n\n            let watcher = FileWatcher::new(\u0026config, processor.clone()).await.unwrap();\n\n            assert_eq!(watcher.config.debounce_ms, debounce_ms);\n            assert_eq!(watcher.config.max_watched_dirs, max_watched_dirs);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_ignore_patterns_variations() {\n        let processor = create_test_processor();\n\n        let pattern_variations = vec![\n            vec![], // empty patterns\n            vec![\"*.tmp\".to_string()], // single pattern\n            vec![\"*.tmp\".to_string(), \"*.log\".to_string()], // multiple patterns\n            vec![\n                \"*.tmp\".to_string(),\n                \"*.log\".to_string(),\n                \"target/**\".to_string(),\n                \"node_modules/**\".to_string(),\n                \".git/**\".to_string(),\n                \"*.backup\".to_string(),\n                \"*.swp\".to_string(),\n                \"*~\".to_string(),\n                \"*.cache\".to_string(),\n                \".DS_Store\".to_string(),\n            ], // many patterns\n        ];\n\n        for patterns in pattern_variations {\n            let mut config = create_test_config(true);\n            config.ignore_patterns = patterns.clone();\n\n            let watcher = FileWatcher::new(\u0026config, processor.clone()).await.unwrap();\n\n            assert_eq!(watcher.config.ignore_patterns, patterns);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_comprehensive_api_coverage() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        // Test the complete API surface\n        let temp_dir = TempDir::new().unwrap();\n\n        // Test all public methods in sequence\n        assert!(watcher.start().await.is_ok());\n        assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n        assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n        assert!(watcher.stop().await.is_ok());\n\n        // Test methods multiple times to ensure state consistency\n        for _ in 0..3 {\n            assert!(watcher.start().await.is_ok());\n            assert!(watcher.watch_directory(temp_dir.path()).await.is_ok());\n            assert!(watcher.unwatch_directory(temp_dir.path()).await.is_ok());\n            assert!(watcher.stop().await.is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_memory_safety() {\n        // Test that dropping components doesn't cause issues\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n\n        {\n            let watcher = FileWatcher::new(\u0026config, processor.clone()).await.unwrap();\n            assert!(watcher.start().await.is_ok());\n            // watcher is dropped here\n        }\n\n        // Processor should still be valid\n        assert_eq!(processor.config().max_concurrent_tasks, 2);\n\n        // Create another watcher with the same processor\n        let mut watcher2 = FileWatcher::new(\u0026config, processor).await.unwrap();\n        assert!(watcher2.start().await.is_ok());\n        assert!(watcher2.stop().await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_file_watcher_struct_debug_format_completeness() {\n        let config = create_test_config(true);\n        let processor = create_test_processor();\n        let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n        let debug_output = format!(\"{:?}\", watcher);\n\n        // Verify debug output contains all expected field names\n        assert!(debug_output.contains(\"FileWatcher\"));\n        assert!(debug_output.contains(\"config\"));\n        assert!(debug_output.contains(\"processor\"));\n        assert!(debug_output.contains(\"watcher\"));\n\n        // Verify debug output contains some config values\n        assert!(debug_output.contains(\"enabled\"));\n        assert!(debug_output.contains(\"debounce_ms\"));\n    }\n\n    #[test]\n    fn test_file_watcher_trait_implementations() {\n        // Verify required trait implementations\n        fn assert_debug\u003cT: std::fmt::Debug\u003e() {}\n        fn assert_send\u003cT: Send\u003e() {}\n        fn assert_sync\u003cT: Sync\u003e() {}\n\n        assert_debug::\u003cFileWatcher\u003e();\n        assert_send::\u003cFileWatcher\u003e();\n        assert_sync::\u003cFileWatcher\u003e();\n\n        // Test that the type can be used in various contexts\n        fn _takes_debug(_: impl std::fmt::Debug) {}\n        fn _takes_send(_: impl Send) {}\n        fn _takes_sync(_: impl Sync) {}\n\n        let config = FileWatcherConfig {\n            enabled: true,\n            debounce_ms: 100,\n            max_watched_dirs: 10,\n            ignore_patterns: vec![],\n            recursive: true,\n        };\n        let processor = Arc::new(DocumentProcessor::test_instance());\n\n        // This would be tested in a tokio context, but we're testing trait bounds here\n        // let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n        // _takes_debug(watcher);\n        // _takes_send(watcher);\n        // _takes_sync(watcher);\n    }\n}","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":104}},{"line":23,"address":[],"length":0,"stats":{"Line":52}},{"line":25,"address":[],"length":0,"stats":{"Line":52}},{"line":26,"address":[],"length":0,"stats":{"Line":156}},{"line":27,"address":[],"length":0,"stats":{"Line":104}},{"line":28,"address":[],"length":0,"stats":{"Line":104}},{"line":33,"address":[],"length":0,"stats":{"Line":104}},{"line":34,"address":[],"length":0,"stats":{"Line":52}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":48}},{"line":44,"address":[],"length":0,"stats":{"Line":48}},{"line":48,"address":[],"length":0,"stats":{"Line":94}},{"line":49,"address":[],"length":0,"stats":{"Line":47}},{"line":53,"address":[],"length":0,"stats":{"Line":47}},{"line":57,"address":[],"length":0,"stats":{"Line":186}},{"line":58,"address":[],"length":0,"stats":{"Line":279}},{"line":59,"address":[],"length":0,"stats":{"Line":93}},{"line":63,"address":[],"length":0,"stats":{"Line":93}},{"line":67,"address":[],"length":0,"stats":{"Line":182}},{"line":68,"address":[],"length":0,"stats":{"Line":273}},{"line":69,"address":[],"length":0,"stats":{"Line":91}},{"line":73,"address":[],"length":0,"stats":{"Line":91}}],"covered":22,"coverable":22},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","error.rs"],"content":"//! Error types for the Workspace Qdrant Daemon\n\nuse thiserror::Error;\nuse tonic::{Code, Status};\n\n/// Main error type for daemon operations\n#[derive(Error, Debug)]\npub enum DaemonError {\n    #[error(\"Configuration error: {0}\")]\n    Config(#[from] config::ConfigError),\n\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n\n    #[error(\"I/O error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"gRPC error: {0}\")]\n    Grpc(#[from] tonic::transport::Error),\n\n    #[error(\"Serialization error: {0}\")]\n    Serialization(#[from] serde_json::Error),\n\n    #[error(\"File watching error: {0}\")]\n    FileWatcher(#[from] notify::Error),\n\n    #[error(\"Git error: {0}\")]\n    Git(#[from] git2::Error),\n\n    #[error(\"HTTP client error: {0}\")]\n    Http(#[from] reqwest::Error),\n\n    #[error(\"Document processing error: {message}\")]\n    DocumentProcessing { message: String },\n\n    #[error(\"Search error: {message}\")]\n    Search { message: String },\n\n    #[error(\"Memory management error: {message}\")]\n    Memory { message: String },\n\n    #[error(\"System error: {message}\")]\n    System { message: String },\n\n    #[error(\"Project detection error: {message}\")]\n    ProjectDetection { message: String },\n\n    #[error(\"Connection pool error: {message}\")]\n    ConnectionPool { message: String },\n\n    #[error(\"Timeout error: operation timed out after {seconds}s\")]\n    Timeout { seconds: u64 },\n\n    #[error(\"Resource not found: {resource}\")]\n    NotFound { resource: String },\n\n    #[error(\"Invalid input: {message}\")]\n    InvalidInput { message: String },\n\n    #[error(\"Internal error: {message}\")]\n    Internal { message: String },\n}\n\nimpl From\u003cDaemonError\u003e for Status {\n    fn from(err: DaemonError) -\u003e Self {\n        match err {\n            DaemonError::Config(_) | DaemonError::InvalidInput { .. } =\u003e {\n                Status::new(Code::InvalidArgument, err.to_string())\n            },\n            DaemonError::NotFound { .. } =\u003e {\n                Status::new(Code::NotFound, err.to_string())\n            },\n            DaemonError::Timeout { .. } =\u003e {\n                Status::new(Code::DeadlineExceeded, err.to_string())\n            },\n            DaemonError::Database(_) | DaemonError::Io(_) | DaemonError::FileWatcher(_) =\u003e {\n                Status::new(Code::Internal, \"Internal server error\")\n            },\n            _ =\u003e Status::new(Code::Internal, \"Internal server error\"),\n        }\n    }\n}\n\n/// Result type alias for daemon operations\npub type DaemonResult\u003cT\u003e = Result\u003cT, DaemonError\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::{Error, ErrorKind};\n\n    #[test]\n    fn test_daemon_error_display() {\n        let err = DaemonError::DocumentProcessing {\n            message: \"Test error\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Document processing error: Test error\");\n\n        let err = DaemonError::Search {\n            message: \"Search failed\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Search error: Search failed\");\n\n        let err = DaemonError::Memory {\n            message: \"Memory allocation failed\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Memory management error: Memory allocation failed\");\n\n        let err = DaemonError::System {\n            message: \"System call failed\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"System error: System call failed\");\n\n        let err = DaemonError::ProjectDetection {\n            message: \"No git repository found\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Project detection error: No git repository found\");\n\n        let err = DaemonError::ConnectionPool {\n            message: \"Pool exhausted\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Connection pool error: Pool exhausted\");\n\n        let err = DaemonError::Timeout { seconds: 30 };\n        assert_eq!(format!(\"{}\", err), \"Timeout error: operation timed out after 30s\");\n\n        let err = DaemonError::NotFound {\n            resource: \"document\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Resource not found: document\");\n\n        let err = DaemonError::InvalidInput {\n            message: \"Invalid format\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Invalid input: Invalid format\");\n\n        let err = DaemonError::Internal {\n            message: \"Unexpected state\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", err), \"Internal error: Unexpected state\");\n    }\n\n    #[test]\n    fn test_daemon_error_debug() {\n        let err = DaemonError::DocumentProcessing {\n            message: \"Test error\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", err);\n        assert!(debug_str.contains(\"DocumentProcessing\"));\n        assert!(debug_str.contains(\"Test error\"));\n    }\n\n    #[test]\n    fn test_daemon_error_from_io_error() {\n        let io_error = Error::new(ErrorKind::NotFound, \"File not found\");\n        let daemon_error: DaemonError = io_error.into();\n\n        match daemon_error {\n            DaemonError::Io(ref e) =\u003e {\n                assert_eq!(e.kind(), ErrorKind::NotFound);\n                assert_eq!(e.to_string(), \"File not found\");\n            },\n            _ =\u003e panic!(\"Expected DaemonError::Io\"),\n        }\n    }\n\n    #[test]\n    fn test_daemon_error_from_serde_json_error() {\n        let json_error = serde_json::from_str::\u003cserde_json::Value\u003e(\"invalid json\")\n            .unwrap_err();\n        let daemon_error: DaemonError = json_error.into();\n\n        match daemon_error {\n            DaemonError::Serialization(_) =\u003e {\n                // Success - correct variant\n            },\n            _ =\u003e panic!(\"Expected DaemonError::Serialization\"),\n        }\n    }\n\n    #[test]\n    fn test_status_conversion_invalid_argument() {\n        let err = DaemonError::InvalidInput {\n            message: \"Bad request\".to_string(),\n        };\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::InvalidArgument);\n        assert!(status.message().contains(\"Invalid input: Bad request\"));\n\n        let err = DaemonError::Config(config::ConfigError::Message(\"Config parse error\".to_string()));\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::InvalidArgument);\n    }\n\n    #[test]\n    fn test_status_conversion_not_found() {\n        let err = DaemonError::NotFound {\n            resource: \"user\".to_string(),\n        };\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::NotFound);\n        assert!(status.message().contains(\"Resource not found: user\"));\n    }\n\n    #[test]\n    fn test_status_conversion_deadline_exceeded() {\n        let err = DaemonError::Timeout { seconds: 60 };\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::DeadlineExceeded);\n        assert!(status.message().contains(\"operation timed out after 60s\"));\n    }\n\n    #[test]\n    fn test_status_conversion_internal_error() {\n        let io_error = Error::new(ErrorKind::PermissionDenied, \"Access denied\");\n        let err = DaemonError::Io(io_error);\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::Internal);\n        assert_eq!(status.message(), \"Internal server error\");\n\n        let err = DaemonError::Database(sqlx::Error::PoolClosed);\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::Internal);\n        assert_eq!(status.message(), \"Internal server error\");\n\n        let err = DaemonError::DocumentProcessing {\n            message: \"Processing failed\".to_string(),\n        };\n        let status: Status = err.into();\n        assert_eq!(status.code(), Code::Internal);\n        assert_eq!(status.message(), \"Internal server error\");\n    }\n\n    #[test]\n    fn test_daemon_result_type() {\n        let success: DaemonResult\u003ci32\u003e = Ok(42);\n        assert_eq!(success.unwrap(), 42);\n\n        let error: DaemonResult\u003ci32\u003e = Err(DaemonError::Internal {\n            message: \"Test error\".to_string(),\n        });\n        assert!(error.is_err());\n    }\n\n    #[test]\n    fn test_error_chain() {\n        let io_error = Error::new(ErrorKind::NotFound, \"File not found\");\n        let daemon_error = DaemonError::Io(io_error);\n\n        let error_string = format!(\"{}\", daemon_error);\n        assert!(error_string.contains(\"I/O error:\"));\n        assert!(error_string.contains(\"File not found\"));\n    }\n\n    #[test]\n    fn test_all_error_variants_are_testable() {\n        // Test that we can create all error variants\n        let errors = vec![\n            DaemonError::DocumentProcessing { message: \"test\".to_string() },\n            DaemonError::Search { message: \"test\".to_string() },\n            DaemonError::Memory { message: \"test\".to_string() },\n            DaemonError::System { message: \"test\".to_string() },\n            DaemonError::ProjectDetection { message: \"test\".to_string() },\n            DaemonError::ConnectionPool { message: \"test\".to_string() },\n            DaemonError::Timeout { seconds: 10 },\n            DaemonError::NotFound { resource: \"test\".to_string() },\n            DaemonError::InvalidInput { message: \"test\".to_string() },\n            DaemonError::Internal { message: \"test\".to_string() },\n        ];\n\n        for error in errors {\n            // Each error should be debuggable\n            let debug_str = format!(\"{:?}\", error);\n            assert!(!debug_str.is_empty());\n\n            // Each error should be displayable\n            let display_str = format!(\"{}\", error);\n            assert!(!display_str.is_empty());\n\n            // Each error should convert to Status\n            let _status: Status = error.into();\n        }\n    }\n\n    #[test]\n    fn test_error_source_chain() {\n        let io_error = Error::new(ErrorKind::NotFound, \"File not found\");\n        let daemon_error = DaemonError::Io(io_error);\n\n        // Test that the source chain is preserved\n        let source = std::error::Error::source(\u0026daemon_error);\n        assert!(source.is_some());\n\n        if let Some(source) = source {\n            assert_eq!(source.to_string(), \"File not found\");\n        }\n    }\n}","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":17}},{"line":66,"address":[],"length":0,"stats":{"Line":17}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":8}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":16}}],"covered":7,"coverable":7},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","grpc","middleware.rs"],"content":"//! gRPC middleware for connection management, metrics, and security\n\nuse std::time::{Duration, Instant};\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, info, warn};\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse dashmap::DashMap;\nuse parking_lot::RwLock;\n\n/// Connection tracking and management\n#[derive(Debug)]\npub struct ConnectionManager {\n    /// Active connections count\n    active_connections: AtomicU64,\n\n    /// Maximum allowed connections\n    max_connections: u64,\n\n    /// Connection metadata by client ID\n    connections: Arc\u003cDashMap\u003cString, ConnectionInfo\u003e\u003e,\n\n    /// Rate limiting state\n    rate_limiter: Arc\u003cRwLock\u003cRateLimiter\u003e\u003e,\n}\n\n#[derive(Debug)]\npub struct ConnectionInfo {\n    pub client_id: String,\n    pub connected_at: Instant,\n    pub last_activity: Instant,\n    pub request_count: AtomicU64,\n    pub bytes_sent: AtomicU64,\n    pub bytes_received: AtomicU64,\n}\n\nimpl Clone for ConnectionInfo {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            client_id: self.client_id.clone(),\n            connected_at: self.connected_at,\n            last_activity: self.last_activity,\n            request_count: AtomicU64::new(self.request_count.load(Ordering::SeqCst)),\n            bytes_sent: AtomicU64::new(self.bytes_sent.load(Ordering::SeqCst)),\n            bytes_received: AtomicU64::new(self.bytes_received.load(Ordering::SeqCst)),\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct RateLimiter {\n    /// Requests per second limit per client\n    requests_per_second: u32,\n\n    /// Client request tracking\n    client_requests: DashMap\u003cString, Vec\u003cInstant\u003e\u003e,\n\n    /// Cleanup interval\n    last_cleanup: Instant,\n}\n\nimpl ConnectionManager {\n    pub fn new(max_connections: u64, requests_per_second: u32) -\u003e Self {\n        Self {\n            active_connections: AtomicU64::new(0),\n            max_connections,\n            connections: Arc::new(DashMap::new()),\n            rate_limiter: Arc::new(RwLock::new(RateLimiter {\n                requests_per_second,\n                client_requests: DashMap::new(),\n                last_cleanup: Instant::now(),\n            })),\n        }\n    }\n\n    /// Register a new connection\n    pub fn register_connection(\u0026self, client_id: String) -\u003e Result\u003c(), Status\u003e {\n        let current_connections = self.active_connections.load(Ordering::SeqCst);\n\n        if current_connections \u003e= self.max_connections {\n            warn!(\"Connection limit reached: {}/{}\", current_connections, self.max_connections);\n            return Err(Status::resource_exhausted(\"Connection limit reached\"));\n        }\n\n        let connection_info = ConnectionInfo {\n            client_id: client_id.clone(),\n            connected_at: Instant::now(),\n            last_activity: Instant::now(),\n            request_count: AtomicU64::new(0),\n            bytes_sent: AtomicU64::new(0),\n            bytes_received: AtomicU64::new(0),\n        };\n\n        self.connections.insert(client_id.clone(), connection_info);\n        self.active_connections.fetch_add(1, Ordering::SeqCst);\n\n        info!(\"Connection registered: {} (total: {})\", client_id, current_connections + 1);\n        Ok(())\n    }\n\n    /// Unregister a connection\n    pub fn unregister_connection(\u0026self, client_id: \u0026str) {\n        if self.connections.remove(client_id).is_some() {\n            let remaining = self.active_connections.fetch_sub(1, Ordering::SeqCst) - 1;\n            info!(\"Connection unregistered: {} (remaining: {})\", client_id, remaining);\n        }\n\n        // Clean up rate limiter tracking\n        self.rate_limiter.read().client_requests.remove(client_id);\n    }\n\n    /// Check if request is rate limited\n    pub fn check_rate_limit(\u0026self, client_id: \u0026str) -\u003e Result\u003c(), Status\u003e {\n        let mut rate_limiter = self.rate_limiter.write();\n\n        // Cleanup old entries periodically\n        let now = Instant::now();\n        if now.duration_since(rate_limiter.last_cleanup) \u003e Duration::from_secs(60) {\n            self.cleanup_rate_limiter(\u0026mut rate_limiter, now);\n            rate_limiter.last_cleanup = now;\n        }\n\n        // Get or create client request history\n        let mut requests = rate_limiter.client_requests\n            .entry(client_id.to_string())\n            .or_insert_with(Vec::new)\n            .clone();\n\n        // Remove requests older than 1 second\n        requests.retain(|\u0026timestamp| now.duration_since(timestamp) \u003c Duration::from_secs(1));\n\n        // Check if rate limit exceeded\n        if requests.len() \u003e= rate_limiter.requests_per_second as usize {\n            warn!(\"Rate limit exceeded for client: {}\", client_id);\n            return Err(Status::resource_exhausted(\"Rate limit exceeded\"));\n        }\n\n        // Add current request\n        requests.push(now);\n        rate_limiter.client_requests.insert(client_id.to_string(), requests);\n\n        Ok(())\n    }\n\n    /// Update connection activity\n    pub fn update_activity(\u0026self, client_id: \u0026str, bytes_sent: u64, bytes_received: u64) {\n        if let Some(mut connection) = self.connections.get_mut(client_id) {\n            connection.last_activity = Instant::now();\n            connection.request_count.fetch_add(1, Ordering::SeqCst);\n            connection.bytes_sent.fetch_add(bytes_sent, Ordering::SeqCst);\n            connection.bytes_received.fetch_add(bytes_received, Ordering::SeqCst);\n        }\n    }\n\n    /// Get connection statistics\n    pub fn get_stats(\u0026self) -\u003e ConnectionStats {\n        let active_count = self.active_connections.load(Ordering::SeqCst);\n        let total_requests: u64 = self.connections\n            .iter()\n            .map(|entry| entry.request_count.load(Ordering::SeqCst))\n            .sum();\n        let total_bytes_sent: u64 = self.connections\n            .iter()\n            .map(|entry| entry.bytes_sent.load(Ordering::SeqCst))\n            .sum();\n        let total_bytes_received: u64 = self.connections\n            .iter()\n            .map(|entry| entry.bytes_received.load(Ordering::SeqCst))\n            .sum();\n\n        ConnectionStats {\n            active_connections: active_count,\n            max_connections: self.max_connections,\n            total_requests,\n            total_bytes_sent,\n            total_bytes_received,\n        }\n    }\n\n    /// Cleanup expired connections\n    pub fn cleanup_expired_connections(\u0026self, timeout: Duration) {\n        let now = Instant::now();\n        let mut expired_clients = Vec::new();\n\n        for entry in self.connections.iter() {\n            if now.duration_since(entry.last_activity) \u003e timeout {\n                expired_clients.push(entry.client_id.clone());\n            }\n        }\n\n        for client_id in expired_clients {\n            self.unregister_connection(\u0026client_id);\n            warn!(\"Expired connection cleaned up: {}\", client_id);\n        }\n    }\n\n    fn cleanup_rate_limiter(\u0026self, rate_limiter: \u0026mut RateLimiter, now: Instant) {\n        let cutoff = now - Duration::from_secs(60);\n\n        // Remove old client tracking data\n        rate_limiter.client_requests.retain(|_client_id, requests| {\n            requests.retain(|\u0026timestamp| timestamp \u003e cutoff);\n            !requests.is_empty()\n        });\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct ConnectionStats {\n    pub active_connections: u64,\n    pub max_connections: u64,\n    pub total_requests: u64,\n    pub total_bytes_sent: u64,\n    pub total_bytes_received: u64,\n}\n\n/// Connection pool for outbound connections (to Qdrant, etc.)\npub struct ConnectionPool\u003cT: deadpool::managed::Manager\u003e {\n    pool: deadpool::managed::Pool\u003cT\u003e,\n    config: PoolConfig,\n}\n\nimpl\u003cT: deadpool::managed::Manager\u003e std::fmt::Debug for ConnectionPool\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ConnectionPool\")\n            .field(\"config\", \u0026self.config)\n            .finish_non_exhaustive()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct PoolConfig {\n    pub max_size: usize,\n    pub min_idle: Option\u003cusize\u003e,\n    pub max_lifetime: Option\u003cDuration\u003e,\n    pub idle_timeout: Option\u003cDuration\u003e,\n    pub connection_timeout: Duration,\n}\n\nimpl Default for PoolConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_size: 10,\n            min_idle: Some(2),\n            max_lifetime: Some(Duration::from_secs(3600)), // 1 hour\n            idle_timeout: Some(Duration::from_secs(600)),   // 10 minutes\n            connection_timeout: Duration::from_secs(30),\n        }\n    }\n}\n\n/// Middleware interceptor for connection management\n#[derive(Debug, Clone)]\npub struct ConnectionInterceptor {\n    connection_manager: Arc\u003cConnectionManager\u003e,\n}\n\nimpl ConnectionInterceptor {\n    pub fn new(connection_manager: Arc\u003cConnectionManager\u003e) -\u003e Self {\n        Self { connection_manager }\n    }\n\n    /// Intercept incoming requests\n    pub fn intercept\u003cT\u003e(\u0026self, request: Request\u003cT\u003e) -\u003e Result\u003cRequest\u003cT\u003e, Status\u003e {\n        // Extract client ID from metadata\n        let client_id = request\n            .metadata()\n            .get(\"client-id\")\n            .and_then(|value| value.to_str().ok())\n            .unwrap_or(\"unknown\")\n            .to_string();\n\n        // Check rate limiting\n        self.connection_manager.check_rate_limit(\u0026client_id)?;\n\n        // Update activity (approximate request size)\n        let request_size = std::mem::size_of_val(\u0026request) as u64;\n        self.connection_manager.update_activity(\u0026client_id, 0, request_size);\n\n        Ok(request)\n    }\n\n    /// Intercept outgoing responses\n    pub fn intercept_response\u003cT\u003e(\u0026self, response: Response\u003cT\u003e, client_id: \u0026str) -\u003e Response\u003cT\u003e {\n        // Update activity (approximate response size)\n        let response_size = std::mem::size_of_val(\u0026response) as u64;\n        self.connection_manager.update_activity(client_id, response_size, 0);\n\n        response\n    }\n}\n\n/// Retry configuration for failed connections\n#[derive(Debug, Clone)]\npub struct RetryConfig {\n    pub max_retries: u32,\n    pub initial_delay: Duration,\n    pub max_delay: Duration,\n    pub backoff_multiplier: f64,\n}\n\nimpl Default for RetryConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_retries: 3,\n            initial_delay: Duration::from_millis(100),\n            max_delay: Duration::from_secs(30),\n            backoff_multiplier: 2.0,\n        }\n    }\n}\n\n/// Retry wrapper for gRPC operations\npub async fn with_retry\u003cF, T, E\u003e(\n    operation: F,\n    config: \u0026RetryConfig,\n) -\u003e Result\u003cT, E\u003e\nwhere\n    F: Fn() -\u003e std::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = Result\u003cT, E\u003e\u003e + Send\u003e\u003e,\n    E: std::fmt::Debug,\n{\n    let mut delay = config.initial_delay;\n\n    for attempt in 1..=config.max_retries {\n        match operation().await {\n            Ok(result) =\u003e return Ok(result),\n            Err(err) if attempt == config.max_retries =\u003e {\n                debug!(\"Operation failed after {} attempts: {:?}\", config.max_retries, err);\n                return Err(err);\n            },\n            Err(err) =\u003e {\n                debug!(\"Operation failed (attempt {}/{}): {:?}\", attempt, config.max_retries, err);\n                tokio::time::sleep(delay).await;\n\n                // Exponential backoff with jitter\n                delay = std::cmp::min(\n                    Duration::from_millis(\n                        (delay.as_millis() as f64 * config.backoff_multiplier) as u64\n                    ),\n                    config.max_delay,\n                );\n            }\n        }\n    }\n\n    unreachable!()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tokio_test;\n    use std::sync::atomic::Ordering;\n    use std::time::Duration;\n    use tonic::{Request, Response, Status, metadata::MetadataValue};\n\n    #[test]\n    fn test_connection_manager_new() {\n        let manager = ConnectionManager::new(100, 10);\n\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 0);\n        assert_eq!(manager.max_connections, 100);\n        assert!(manager.connections.is_empty());\n    }\n\n    #[test]\n    fn test_connection_info_clone() {\n        let info = ConnectionInfo {\n            client_id: \"test_client\".to_string(),\n            connected_at: Instant::now(),\n            last_activity: Instant::now(),\n            request_count: AtomicU64::new(5),\n            bytes_sent: AtomicU64::new(1000),\n            bytes_received: AtomicU64::new(2000),\n        };\n\n        let cloned = info.clone();\n\n        assert_eq!(info.client_id, cloned.client_id);\n        assert_eq!(info.request_count.load(Ordering::SeqCst),\n                   cloned.request_count.load(Ordering::SeqCst));\n        assert_eq!(info.bytes_sent.load(Ordering::SeqCst),\n                   cloned.bytes_sent.load(Ordering::SeqCst));\n        assert_eq!(info.bytes_received.load(Ordering::SeqCst),\n                   cloned.bytes_received.load(Ordering::SeqCst));\n    }\n\n    #[test]\n    fn test_connection_manager_register_connection() {\n        let manager = ConnectionManager::new(2, 10);\n\n        // Register first connection\n        let result1 = manager.register_connection(\"client1\".to_string());\n        assert!(result1.is_ok());\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 1);\n\n        // Register second connection\n        let result2 = manager.register_connection(\"client2\".to_string());\n        assert!(result2.is_ok());\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 2);\n\n        // Try to register third connection (should fail due to limit)\n        let result3 = manager.register_connection(\"client3\".to_string());\n        assert!(result3.is_err());\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 2);\n    }\n\n    #[test]\n    fn test_connection_manager_unregister_connection() {\n        let manager = ConnectionManager::new(10, 10);\n\n        // Register and then unregister\n        manager.register_connection(\"client1\".to_string()).unwrap();\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 1);\n\n        manager.unregister_connection(\"client1\");\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 0);\n        assert!(manager.connections.is_empty());\n\n        // Unregistering non-existent connection should not panic\n        manager.unregister_connection(\"non_existent\");\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 0);\n    }\n\n    #[test]\n    fn test_connection_manager_rate_limiting() {\n        let manager = ConnectionManager::new(10, 2); // 2 requests per second\n\n        // First request should succeed\n        let result1 = manager.check_rate_limit(\"client1\");\n        assert!(result1.is_ok());\n\n        // Second request should succeed\n        let result2 = manager.check_rate_limit(\"client1\");\n        assert!(result2.is_ok());\n\n        // Third request should fail (rate limit exceeded)\n        let result3 = manager.check_rate_limit(\"client1\");\n        assert!(result3.is_err());\n        if let Err(status) = result3 {\n            assert_eq!(status.code(), tonic::Code::ResourceExhausted);\n        }\n    }\n\n    #[test]\n    fn test_connection_manager_rate_limiting_different_clients() {\n        let manager = ConnectionManager::new(10, 2); // 2 requests per second\n\n        // Two requests from client1\n        assert!(manager.check_rate_limit(\"client1\").is_ok());\n        assert!(manager.check_rate_limit(\"client1\").is_ok());\n\n        // Two requests from client2 should still succeed\n        assert!(manager.check_rate_limit(\"client2\").is_ok());\n        assert!(manager.check_rate_limit(\"client2\").is_ok());\n\n        // Third request from each client should fail\n        assert!(manager.check_rate_limit(\"client1\").is_err());\n        assert!(manager.check_rate_limit(\"client2\").is_err());\n    }\n\n    #[test]\n    fn test_connection_manager_update_activity() {\n        let manager = ConnectionManager::new(10, 10);\n        manager.register_connection(\"client1\".to_string()).unwrap();\n\n        // Update activity\n        manager.update_activity(\"client1\", 1000, 500);\n\n        let stats = manager.get_stats();\n        assert_eq!(stats.total_bytes_sent, 1000);\n        assert_eq!(stats.total_bytes_received, 500);\n        assert_eq!(stats.total_requests, 1);\n\n        // Update activity again\n        manager.update_activity(\"client1\", 2000, 1000);\n\n        let stats = manager.get_stats();\n        assert_eq!(stats.total_bytes_sent, 3000);\n        assert_eq!(stats.total_bytes_received, 1500);\n        assert_eq!(stats.total_requests, 2);\n    }\n\n    #[test]\n    fn test_connection_manager_get_stats() {\n        let manager = ConnectionManager::new(10, 10);\n\n        // Initial stats\n        let stats = manager.get_stats();\n        assert_eq!(stats.active_connections, 0);\n        assert_eq!(stats.max_connections, 10);\n        assert_eq!(stats.total_requests, 0);\n        assert_eq!(stats.total_bytes_sent, 0);\n        assert_eq!(stats.total_bytes_received, 0);\n\n        // Register connections and update activity\n        manager.register_connection(\"client1\".to_string()).unwrap();\n        manager.register_connection(\"client2\".to_string()).unwrap();\n        manager.update_activity(\"client1\", 100, 200);\n        manager.update_activity(\"client2\", 300, 400);\n\n        let stats = manager.get_stats();\n        assert_eq!(stats.active_connections, 2);\n        assert_eq!(stats.total_requests, 2);\n        assert_eq!(stats.total_bytes_sent, 400);\n        assert_eq!(stats.total_bytes_received, 600);\n    }\n\n    #[test]\n    fn test_connection_manager_cleanup_expired_connections() {\n        let manager = ConnectionManager::new(10, 10);\n        manager.register_connection(\"client1\".to_string()).unwrap();\n\n        // Connection should not be expired immediately\n        manager.cleanup_expired_connections(Duration::from_secs(1));\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 1);\n\n        // Connection should be expired with zero timeout\n        manager.cleanup_expired_connections(Duration::from_secs(0));\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 0);\n    }\n\n    #[test]\n    fn test_connection_stats_debug() {\n        let stats = ConnectionStats {\n            active_connections: 5,\n            max_connections: 10,\n            total_requests: 100,\n            total_bytes_sent: 1000,\n            total_bytes_received: 2000,\n        };\n\n        let debug_str = format!(\"{:?}\", stats);\n        assert!(debug_str.contains(\"ConnectionStats\"));\n        assert!(debug_str.contains(\"5\"));\n        assert!(debug_str.contains(\"100\"));\n    }\n\n    #[test]\n    fn test_connection_stats_clone() {\n        let stats = ConnectionStats {\n            active_connections: 5,\n            max_connections: 10,\n            total_requests: 100,\n            total_bytes_sent: 1000,\n            total_bytes_received: 2000,\n        };\n\n        let cloned = stats.clone();\n        assert_eq!(stats.active_connections, cloned.active_connections);\n        assert_eq!(stats.max_connections, cloned.max_connections);\n        assert_eq!(stats.total_requests, cloned.total_requests);\n        assert_eq!(stats.total_bytes_sent, cloned.total_bytes_sent);\n        assert_eq!(stats.total_bytes_received, cloned.total_bytes_received);\n    }\n\n    #[test]\n    fn test_pool_config_default() {\n        let config = PoolConfig::default();\n\n        assert_eq!(config.max_size, 10);\n        assert_eq!(config.min_idle, Some(2));\n        assert_eq!(config.max_lifetime, Some(Duration::from_secs(3600)));\n        assert_eq!(config.idle_timeout, Some(Duration::from_secs(600)));\n        assert_eq!(config.connection_timeout, Duration::from_secs(30));\n    }\n\n    #[test]\n    fn test_pool_config_debug() {\n        let config = PoolConfig::default();\n        let debug_str = format!(\"{:?}\", config);\n\n        assert!(debug_str.contains(\"PoolConfig\"));\n        assert!(debug_str.contains(\"max_size\"));\n        assert!(debug_str.contains(\"10\"));\n    }\n\n    #[test]\n    fn test_connection_interceptor_new() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager.clone());\n\n        assert!(Arc::ptr_eq(\u0026interceptor.connection_manager, \u0026manager));\n    }\n\n    #[test]\n    fn test_connection_interceptor_debug() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager);\n\n        let debug_str = format!(\"{:?}\", interceptor);\n        assert!(debug_str.contains(\"ConnectionInterceptor\"));\n        assert!(debug_str.contains(\"connection_manager\"));\n    }\n\n    #[test]\n    fn test_connection_interceptor_clone() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager);\n        let cloned = interceptor.clone();\n\n        assert!(Arc::ptr_eq(\u0026interceptor.connection_manager, \u0026cloned.connection_manager));\n    }\n\n    #[test]\n    fn test_connection_interceptor_intercept_without_client_id() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager);\n\n        let request: Request\u003c()\u003e = Request::new(());\n        let result = interceptor.intercept(request);\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_connection_interceptor_intercept_with_client_id() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager);\n\n        let mut request: Request\u003c()\u003e = Request::new(());\n        request.metadata_mut().insert(\n            \"client-id\",\n            MetadataValue::from_static(\"test_client\")\n        );\n\n        let result = interceptor.intercept(request);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_connection_interceptor_intercept_response() {\n        let manager = Arc::new(ConnectionManager::new(10, 10));\n        let interceptor = ConnectionInterceptor::new(manager.clone());\n\n        manager.register_connection(\"test_client\".to_string()).unwrap();\n\n        let response: Response\u003c()\u003e = Response::new(());\n        let result = interceptor.intercept_response(response, \"test_client\");\n\n        // Should return the response unchanged\n        assert_eq!(result.get_ref(), \u0026());\n    }\n\n    #[test]\n    fn test_retry_config_default() {\n        let config = RetryConfig::default();\n\n        assert_eq!(config.max_retries, 3);\n        assert_eq!(config.initial_delay, Duration::from_millis(100));\n        assert_eq!(config.max_delay, Duration::from_secs(30));\n        assert_eq!(config.backoff_multiplier, 2.0);\n    }\n\n    #[test]\n    fn test_retry_config_debug() {\n        let config = RetryConfig::default();\n        let debug_str = format!(\"{:?}\", config);\n\n        assert!(debug_str.contains(\"RetryConfig\"));\n        assert!(debug_str.contains(\"max_retries\"));\n        assert!(debug_str.contains(\"3\"));\n    }\n\n    #[test]\n    fn test_retry_config_clone() {\n        let config = RetryConfig::default();\n        let cloned = config.clone();\n\n        assert_eq!(config.max_retries, cloned.max_retries);\n        assert_eq!(config.initial_delay, cloned.initial_delay);\n        assert_eq!(config.max_delay, cloned.max_delay);\n        assert_eq!(config.backoff_multiplier, cloned.backoff_multiplier);\n    }\n\n    #[tokio::test]\n    async fn test_with_retry_success_first_attempt() {\n        let config = RetryConfig {\n            max_retries: 3,\n            initial_delay: Duration::from_millis(10),\n            max_delay: Duration::from_secs(1),\n            backoff_multiplier: 2.0,\n        };\n\n        let result = with_retry(\n            || Box::pin(async { Ok::\u003ci32, \u0026'static str\u003e(42) }),\n            \u0026config,\n        ).await;\n\n        assert_eq!(result.unwrap(), 42);\n    }\n\n    #[tokio::test]\n    async fn test_with_retry_success_after_failures() {\n        let config = RetryConfig {\n            max_retries: 3,\n            initial_delay: Duration::from_millis(1),\n            max_delay: Duration::from_secs(1),\n            backoff_multiplier: 2.0,\n        };\n\n        let attempt = Arc::new(AtomicU64::new(0));\n        let attempt_clone = Arc::clone(\u0026attempt);\n        let result = with_retry(\n            move || {\n                let current_attempt = attempt_clone.fetch_add(1, Ordering::SeqCst) + 1;\n                Box::pin(async move {\n                    if current_attempt \u003c 3 {\n                        Err(\"temporary failure\")\n                    } else {\n                        Ok::\u003ci32, \u0026'static str\u003e(42)\n                    }\n                })\n            },\n            \u0026config,\n        ).await;\n\n        assert_eq!(result.unwrap(), 42);\n    }\n\n    #[tokio::test]\n    async fn test_with_retry_final_failure() {\n        let config = RetryConfig {\n            max_retries: 2,\n            initial_delay: Duration::from_millis(1),\n            max_delay: Duration::from_secs(1),\n            backoff_multiplier: 2.0,\n        };\n\n        let result = with_retry(\n            || Box::pin(async { Err::\u003ci32, \u0026'static str\u003e(\"permanent failure\") }),\n            \u0026config,\n        ).await;\n\n        assert_eq!(result.unwrap_err(), \"permanent failure\");\n    }\n\n    #[test]\n    fn test_rate_limiter_debug() {\n        let rate_limiter = RateLimiter {\n            requests_per_second: 10,\n            client_requests: DashMap::new(),\n            last_cleanup: Instant::now(),\n        };\n\n        let debug_str = format!(\"{:?}\", rate_limiter);\n        assert!(debug_str.contains(\"RateLimiter\"));\n        assert!(debug_str.contains(\"requests_per_second\"));\n        assert!(debug_str.contains(\"10\"));\n    }\n\n    #[test]\n    fn test_connection_manager_send_sync() {\n        fn assert_send\u003cT: Send\u003e() {}\n        fn assert_sync\u003cT: Sync\u003e() {}\n\n        assert_send::\u003cConnectionManager\u003e();\n        assert_sync::\u003cConnectionManager\u003e();\n    }\n\n    #[test]\n    fn test_connection_interceptor_send_sync() {\n        fn assert_send\u003cT: Send\u003e() {}\n        fn assert_sync\u003cT: Sync\u003e() {}\n\n        assert_send::\u003cConnectionInterceptor\u003e();\n        assert_sync::\u003cConnectionInterceptor\u003e();\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_connection_management() {\n        let manager = Arc::new(ConnectionManager::new(100, 50));\n\n        let mut handles = vec![];\n\n        // Spawn multiple tasks to register connections concurrently\n        for i in 0..10 {\n            let manager_clone = Arc::clone(\u0026manager);\n            let handle = tokio::spawn(async move {\n                let client_id = format!(\"client_{}\", i);\n                manager_clone.register_connection(client_id.clone()).unwrap();\n\n                // Simulate some activity\n                for _ in 0..5 {\n                    manager_clone.update_activity(\u0026client_id, 100, 200);\n                    tokio::time::sleep(Duration::from_millis(1)).await;\n                }\n\n                manager_clone.unregister_connection(\u0026client_id);\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all tasks to complete\n        for handle in handles {\n            handle.await.unwrap();\n        }\n\n        // All connections should be unregistered\n        assert_eq!(manager.active_connections.load(Ordering::SeqCst), 0);\n    }\n}","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":44,"address":[],"length":0,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":26}},{"line":65,"address":[],"length":0,"stats":{"Line":52}},{"line":67,"address":[],"length":0,"stats":{"Line":78}},{"line":68,"address":[],"length":0,"stats":{"Line":78}},{"line":77,"address":[],"length":0,"stats":{"Line":19}},{"line":78,"address":[],"length":0,"stats":{"Line":76}},{"line":80,"address":[],"length":0,"stats":{"Line":19}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":13}},{"line":103,"address":[],"length":0,"stats":{"Line":39}},{"line":104,"address":[],"length":0,"stats":{"Line":36}},{"line":105,"address":[],"length":0,"stats":{"Line":12}},{"line":109,"address":[],"length":0,"stats":{"Line":39}},{"line":113,"address":[],"length":0,"stats":{"Line":11}},{"line":114,"address":[],"length":0,"stats":{"Line":22}},{"line":117,"address":[],"length":0,"stats":{"Line":22}},{"line":118,"address":[],"length":0,"stats":{"Line":22}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":33}},{"line":125,"address":[],"length":0,"stats":{"Line":33}},{"line":126,"address":[],"length":0,"stats":{"Line":11}},{"line":130,"address":[],"length":0,"stats":{"Line":49}},{"line":133,"address":[],"length":0,"stats":{"Line":22}},{"line":134,"address":[],"length":0,"stats":{"Line":3}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":57}},{"line":147,"address":[],"length":0,"stats":{"Line":169}},{"line":156,"address":[],"length":0,"stats":{"Line":8}},{"line":157,"address":[],"length":0,"stats":{"Line":32}},{"line":158,"address":[],"length":0,"stats":{"Line":24}},{"line":160,"address":[],"length":0,"stats":{"Line":20}},{"line":162,"address":[],"length":0,"stats":{"Line":24}},{"line":164,"address":[],"length":0,"stats":{"Line":20}},{"line":166,"address":[],"length":0,"stats":{"Line":24}},{"line":168,"address":[],"length":0,"stats":{"Line":20}},{"line":173,"address":[],"length":0,"stats":{"Line":16}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":6}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":245,"address":[],"length":0,"stats":{"Line":4}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":7}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":4}},{"line":269,"address":[],"length":0,"stats":{"Line":5}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":3}},{"line":289,"address":[],"length":0,"stats":{"Line":1}},{"line":303,"address":[],"length":0,"stats":{"Line":3}},{"line":306,"address":[],"length":0,"stats":{"Line":3}},{"line":307,"address":[],"length":0,"stats":{"Line":3}},{"line":314,"address":[],"length":0,"stats":{"Line":3}},{"line":322,"address":[],"length":0,"stats":{"Line":6}},{"line":324,"address":[],"length":0,"stats":{"Line":9}},{"line":325,"address":[],"length":0,"stats":{"Line":12}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":6}},{"line":328,"address":[],"length":0,"stats":{"Line":1}},{"line":329,"address":[],"length":0,"stats":{"Line":1}},{"line":331,"address":[],"length":0,"stats":{"Line":3}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":3}},{"line":337,"address":[],"length":0,"stats":{"Line":3}},{"line":338,"address":[],"length":0,"stats":{"Line":3}},{"line":340,"address":[],"length":0,"stats":{"Line":3}}],"covered":81,"coverable":97},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","grpc","mod.rs"],"content":"//! gRPC server implementations for all daemon services\n\npub mod server;\npub mod services;\npub mod middleware;\n\npub use server::GrpcServer;","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","grpc","server.rs"],"content":"//! Main gRPC server implementation with all service registrations\n\nuse crate::daemon::WorkspaceDaemon;\nuse crate::grpc::middleware::{ConnectionManager, ConnectionInterceptor};\nuse crate::grpc::services::{\n    DocumentProcessorImpl,\n    SearchServiceImpl,\n    MemoryServiceImpl,\n    SystemServiceImpl,\n};\nuse crate::proto::{\n    document_processor_server::DocumentProcessorServer,\n    search_service_server::SearchServiceServer,\n    memory_service_server::MemoryServiceServer,\n    system_service_server::SystemServiceServer,\n};\n\nuse anyhow::Result;\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::signal;\nuse tonic::transport::Server;\nuse tracing::info;\n\n/// Main gRPC server coordinating all daemon services\npub struct GrpcServer {\n    daemon: Arc\u003cWorkspaceDaemon\u003e,\n    address: SocketAddr,\n    connection_manager: Arc\u003cConnectionManager\u003e,\n}\n\nimpl GrpcServer {\n    /// Create a new gRPC server instance\n    pub fn new(daemon: WorkspaceDaemon, address: SocketAddr) -\u003e Self {\n        let config = daemon.config();\n        let connection_manager = Arc::new(ConnectionManager::new(\n            config.server.max_connections as u64,\n            100, // 100 requests per second per client\n        ));\n\n        Self {\n            daemon: Arc::new(daemon),\n            address,\n            connection_manager,\n        }\n    }\n\n    /// Start the gRPC server in foreground mode\n    pub async fn serve(self) -\u003e Result\u003c()\u003e {\n        let address = self.address;\n        info!(\"Starting gRPC server on {}\", address);\n        info!(\"Connection manager initialized with max connections: {}\",\n              self.daemon.config().server.max_connections);\n\n        // Start connection cleanup task\n        let connection_manager_clone = Arc::clone(\u0026self.connection_manager);\n        let cleanup_task = tokio::spawn(async move {\n            let mut interval = tokio::time::interval(Duration::from_secs(60));\n            loop {\n                interval.tick().await;\n                connection_manager_clone.cleanup_expired_connections(Duration::from_secs(300));\n            }\n        });\n\n        let server = self.build_server().await?;\n\n        // Graceful shutdown\n        let shutdown_signal = async {\n            signal::ctrl_c()\n                .await\n                .expect(\"Failed to install CTRL+C signal handler\");\n            info!(\"Received shutdown signal, gracefully shutting down...\");\n            cleanup_task.abort();\n        };\n\n        server\n            .serve_with_shutdown(address, shutdown_signal)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"gRPC server error: {}\", e))?;\n\n        info!(\"gRPC server shutdown complete\");\n        Ok(())\n    }\n\n    /// Start the gRPC server in daemon mode\n    pub async fn serve_daemon(self) -\u003e Result\u003c()\u003e {\n        let address = self.address;\n        info!(\"Starting gRPC server in daemon mode on {}\", address);\n        info!(\"Connection manager initialized with max connections: {}\",\n              self.daemon.config().server.max_connections);\n\n        // Start connection cleanup task\n        let connection_manager_clone = Arc::clone(\u0026self.connection_manager);\n        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(Duration::from_secs(60));\n            loop {\n                interval.tick().await;\n                connection_manager_clone.cleanup_expired_connections(Duration::from_secs(300));\n            }\n        });\n\n        let server = self.build_server().await?;\n\n        server\n            .serve(address)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"gRPC server error: {}\", e))?;\n\n        Ok(())\n    }\n\n    /// Build the complete gRPC server with all services\n    async fn build_server(self) -\u003e Result\u003ctonic::transport::server::Router\u003e {\n        let reflection_service = tonic_reflection::server::Builder::configure()\n            .register_encoded_file_descriptor_set(include_bytes!(concat!(env!(\"OUT_DIR\"), \"/workspace_daemon_descriptor.bin\")))\n            .build_v1()\n            .map_err(|e| anyhow::anyhow!(\"Failed to build reflection service: {}\", e))?;\n\n        // Create connection interceptor\n        let interceptor = ConnectionInterceptor::new(Arc::clone(\u0026self.connection_manager));\n\n        // Create service implementations\n        let document_processor = DocumentProcessorImpl::new(Arc::clone(\u0026self.daemon));\n        let search_service = SearchServiceImpl::new(Arc::clone(\u0026self.daemon));\n        let memory_service = MemoryServiceImpl::new(Arc::clone(\u0026self.daemon));\n        let system_service = SystemServiceImpl::new(Arc::clone(\u0026self.daemon));\n\n        let config = self.daemon.config();\n\n        let server = Server::builder()\n            // Add connection timeout from config\n            .timeout(Duration::from_secs(config.server.connection_timeout_secs))\n            // Set concurrency limits\n            .concurrency_limit_per_connection(256)\n            // Add keep-alive settings\n            .tcp_keepalive(Some(Duration::from_secs(60)))\n            // Register all services\n            .add_service(DocumentProcessorServer::new(document_processor))\n            .add_service(SearchServiceServer::new(search_service))\n            .add_service(MemoryServiceServer::new(memory_service))\n            .add_service(SystemServiceServer::new(system_service))\n            // Add reflection for debugging\n            .add_service(reflection_service);\n\n        Ok(server)\n    }\n\n    /// Get connection statistics\n    pub fn get_connection_stats(\u0026self) -\u003e crate::grpc::middleware::ConnectionStats {\n        self.connection_manager.get_stats()\n    }\n\n    /// Get connection manager for external access\n    pub fn connection_manager(\u0026self) -\u003e \u0026Arc\u003cConnectionManager\u003e {\n        \u0026self.connection_manager\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use std::net::{IpAddr, Ipv4Addr};\n    use tempfile::TempDir;\n    use tokio_test;\n\n    fn create_test_daemon_config() -\u003e DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\";\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50052, // Use different port for testing\n                max_connections: 100,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 60,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path.to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 2,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 1024 * 1024,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 10,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    async fn create_test_daemon() -\u003e WorkspaceDaemon {\n        let config = create_test_daemon_config();\n        WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\")\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_new() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0);\n\n        let server = GrpcServer::new(daemon, address);\n\n        assert_eq!(server.address, address);\n        assert!(Arc::strong_count(\u0026server.connection_manager) \u003e= 1);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_connection_manager_access() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n        let connection_manager = server.connection_manager();\n\n        // Test that we can access connection manager\n        let stats = connection_manager.get_stats();\n        assert_eq!(stats.active_connections, 0);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_get_connection_stats() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n        let stats = server.get_connection_stats();\n\n        // Initially should have no active connections\n        assert_eq!(stats.active_connections, 0);\n        assert_eq!(stats.total_requests, 0);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_build_server() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n        let result = server.build_server().await;\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_grpc_server_address_types() {\n        // Test IPv4 address\n        let ipv4 = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1)), 8080);\n        assert_eq!(ipv4.ip(), IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1)));\n        assert_eq!(ipv4.port(), 8080);\n\n        // Test IPv6 address\n        let ipv6 = \"[::1]:9090\".parse::\u003cSocketAddr\u003e().unwrap();\n        assert!(ipv6.is_ipv6());\n        assert_eq!(ipv6.port(), 9090);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_with_different_ports() {\n        let daemon = create_test_daemon().await;\n\n        let ports = [8080, 8081, 8082];\n        for port in ports {\n            let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);\n            let server = GrpcServer::new(daemon.clone(), address);\n            assert_eq!(server.address.port(), port);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_connection_manager_initialization() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n        let connection_manager = server.connection_manager();\n\n        // Test that connection manager is properly initialized\n        let stats = connection_manager.get_stats();\n        assert_eq!(stats.active_connections, 0);\n        assert_eq!(stats.total_requests, 0);\n        assert_eq!(stats.total_bytes_sent, 0);\n        assert_eq!(stats.total_bytes_received, 0);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_daemon_config_access() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n\n        // Test accessing daemon config through server\n        let connection_manager = server.connection_manager();\n        let stats = connection_manager.get_stats();\n\n        // Should have valid stats\n        assert!(stats.active_connections \u003e= 0);\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_arc_sharing() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n        let daemon_arc = \u0026server.daemon;\n\n        // Verify daemon is properly shared via Arc\n        assert!(Arc::strong_count(daemon_arc) \u003e= 1);\n    }\n\n    #[test]\n    fn test_socket_addr_parsing() {\n        // Test various socket address formats\n        let addrs = [\n            \"127.0.0.1:8080\",\n            \"0.0.0.0:8080\",\n            \"[::1]:8080\",\n            \"[::]:8080\",\n        ];\n\n        for addr_str in addrs {\n            let result = addr_str.parse::\u003cSocketAddr\u003e();\n            assert!(result.is_ok(), \"Failed to parse address: {}\", addr_str);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_grpc_server_memory_efficiency() {\n        let daemon = create_test_daemon().await;\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n        let server = GrpcServer::new(daemon, address);\n\n        // Verify that server doesn't hold unnecessary references\n        let initial_daemon_count = Arc::strong_count(\u0026server.daemon);\n        let initial_manager_count = Arc::strong_count(\u0026server.connection_manager);\n\n        assert_eq!(initial_daemon_count, 1);\n        assert_eq!(initial_manager_count, 1);\n    }\n\n    #[test]\n    fn test_grpc_server_send_sync() {\n        fn assert_send\u003cT: Send\u003e() {}\n        fn assert_sync\u003cT: Sync\u003e() {}\n\n        assert_send::\u003cGrpcServer\u003e();\n        assert_sync::\u003cGrpcServer\u003e();\n    }\n}","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":11}},{"line":36,"address":[],"length":0,"stats":{"Line":33}},{"line":37,"address":[],"length":0,"stats":{"Line":33}},{"line":38,"address":[],"length":0,"stats":{"Line":11}},{"line":43,"address":[],"length":0,"stats":{"Line":33}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":3}}],"covered":13,"coverable":51},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","grpc","services","document_processor.rs"],"content":"//! Document processing gRPC service implementation\n\nuse crate::daemon::WorkspaceDaemon;\nuse crate::proto::{\n    document_processor_server::DocumentProcessor,\n    ProcessDocumentRequest, ProcessDocumentResponse,\n    ProcessingStatusRequest, ProcessingStatusResponse,\n    CancelProcessingRequest,\n};\nuse std::sync::Arc;\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, error, info};\n\n/// Document processor service implementation\n#[derive(Debug)]\npub struct DocumentProcessorImpl {\n    daemon: Arc\u003cWorkspaceDaemon\u003e,\n}\n\nimpl DocumentProcessorImpl {\n    pub fn new(daemon: Arc\u003cWorkspaceDaemon\u003e) -\u003e Self {\n        Self { daemon }\n    }\n}\n\n#[tonic::async_trait]\nimpl DocumentProcessor for DocumentProcessorImpl {\n    async fn process_document(\n        \u0026self,\n        request: Request\u003cProcessDocumentRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cProcessDocumentResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Processing document: {:?}\", req.file_path);\n\n        // TODO: Implement actual document processing\n        // This is a placeholder implementation\n        let response = ProcessDocumentResponse {\n            document_id: uuid::Uuid::new_v4().to_string(),\n            status: crate::proto::ProcessingStatus::Completed as i32,\n            error_message: String::new(),\n            chunks_created: 1,\n            extracted_metadata: std::collections::HashMap::new(),\n            processed_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    type ProcessDocumentsStream = tokio_stream::wrappers::ReceiverStream\u003cResult\u003cProcessDocumentResponse, Status\u003e\u003e;\n\n    async fn process_documents(\n        \u0026self,\n        request: Request\u003ctonic::Streaming\u003cProcessDocumentRequest\u003e\u003e,\n    ) -\u003e Result\u003cResponse\u003cSelf::ProcessDocumentsStream\u003e, Status\u003e {\n        let mut stream = request.into_inner();\n        let (tx, rx) = tokio::sync::mpsc::channel(128);\n\n        // Spawn task to process the stream\n        tokio::spawn(async move {\n            while let Some(req) = stream.message().await.transpose() {\n                match req {\n                    Ok(req) =\u003e {\n                        debug!(\"Processing document in stream: {:?}\", req.file_path);\n\n                        // TODO: Implement actual processing\n                        let response = ProcessDocumentResponse {\n                            document_id: uuid::Uuid::new_v4().to_string(),\n                            status: crate::proto::ProcessingStatus::Completed as i32,\n                            error_message: String::new(),\n                            chunks_created: 1,\n                            extracted_metadata: std::collections::HashMap::new(),\n                            processed_at: Some(prost_types::Timestamp {\n                                seconds: chrono::Utc::now().timestamp(),\n                                nanos: 0,\n                            }),\n                        };\n\n                        if tx.send(Ok(response)).await.is_err() {\n                            break;\n                        }\n                    },\n                    Err(e) =\u003e {\n                        let _ = tx.send(Err(e)).await;\n                        break;\n                    }\n                }\n            }\n        });\n\n        Ok(Response::new(tokio_stream::wrappers::ReceiverStream::new(rx)))\n    }\n\n    async fn get_processing_status(\n        \u0026self,\n        request: Request\u003cProcessingStatusRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cProcessingStatusResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Getting processing status for: {}\", req.operation_id);\n\n        // TODO: Implement actual status tracking\n        let response = ProcessingStatusResponse {\n            operation_id: req.operation_id,\n            status: crate::proto::ProcessingStatus::Completed as i32,\n            total_documents: 1,\n            processed_documents: 1,\n            failed_documents: 0,\n            error_messages: vec![],\n            started_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp() - 60,\n                nanos: 0,\n            }),\n            updated_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn cancel_processing(\n        \u0026self,\n        request: Request\u003cCancelProcessingRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003c()\u003e, Status\u003e {\n        let req = request.into_inner();\n        info!(\"Cancelling processing operation: {}\", req.operation_id);\n\n        // TODO: Implement actual cancellation logic\n\n        Ok(Response::new(()))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use tempfile::TempDir;\n    use tonic::Request;\n    use tokio_test;\n    use std::collections::HashMap;\n\n    fn create_test_daemon_config() -\u003e DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\";\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50051,\n                max_connections: 100,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 60,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path.to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 2,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 1024 * 1024,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 10,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    async fn create_test_daemon() -\u003e Arc\u003cWorkspaceDaemon\u003e {\n        let config = create_test_daemon_config();\n        Arc::new(WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\"))\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_impl_new() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon.clone());\n\n        assert!(Arc::ptr_eq(\u0026processor.daemon, \u0026daemon));\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_impl_debug() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let debug_str = format!(\"{:?}\", processor);\n        assert!(debug_str.contains(\"DocumentProcessorImpl\"));\n        assert!(debug_str.contains(\"daemon\"));\n    }\n\n    #[tokio::test]\n    async fn test_process_document_basic() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let request = Request::new(ProcessDocumentRequest {\n            project_id: \"test_project\".to_string(),\n            document_type: crate::proto::DocumentType::Text as i32,\n            file_path: \"/test/document.txt\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n            metadata: HashMap::new(),\n            options: None,\n        });\n\n        let result = processor.process_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.document_id.is_empty());\n        assert_eq!(response.status, crate::proto::ProcessingStatus::Completed as i32);\n        assert!(response.error_message.is_empty());\n        assert_eq!(response.chunks_created, 1);\n        assert!(response.processed_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_process_document_with_metadata() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let mut metadata = HashMap::new();\n        metadata.insert(\"author\".to_string(), \"test_author\".to_string());\n        metadata.insert(\"version\".to_string(), \"1.0\".to_string());\n\n        let request = Request::new(ProcessDocumentRequest {\n            project_id: \"test_project\".to_string(),\n            document_type: crate::proto::DocumentType::Text as i32,\n            file_path: \"/test/document_with_metadata.txt\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n            metadata,\n            options: None,\n        });\n\n        let result = processor.process_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.document_id.is_empty());\n        assert_eq!(response.status, crate::proto::ProcessingStatus::Completed as i32);\n    }\n\n    #[tokio::test]\n    async fn test_process_document_different_file_types() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let file_types = [\n            \"document.txt\",\n            \"readme.md\",\n            \"script.py\",\n            \"code.rs\",\n            \"data.json\",\n            \"page.html\",\n        ];\n\n        for file_name in file_types {\n            let request = Request::new(ProcessDocumentRequest {\n                project_id: \"test_project\".to_string(),\n                document_type: crate::proto::DocumentType::Text as i32,\n                file_path: format!(\"/test/{}\", file_name),\n                collection_name: \"test_collection\".to_string(),\n                metadata: HashMap::new(),\n                options: None,\n            });\n\n            let result = processor.process_document(request).await;\n            assert!(result.is_ok(), \"Failed to process file: {}\", file_name);\n\n            let response = result.unwrap().into_inner();\n            assert!(!response.document_id.is_empty());\n            assert_eq!(response.status, crate::proto::ProcessingStatus::Completed as i32);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_processing_status() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let request = Request::new(ProcessingStatusRequest {\n            operation_id: \"test_operation_123\".to_string(),\n        });\n\n        let result = processor.get_processing_status(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.operation_id, \"test_operation_123\");\n        assert_eq!(response.status, crate::proto::ProcessingStatus::Completed as i32);\n        assert_eq!(response.total_documents, 1);\n        assert_eq!(response.processed_documents, 1);\n        assert_eq!(response.failed_documents, 0);\n        assert!(response.error_messages.is_empty());\n        assert!(response.started_at.is_some());\n        assert!(response.updated_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_get_processing_status_different_operation_ids() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let operation_ids = [\n            \"op_1\",\n            \"operation_with_underscores_123\",\n            \"uuid-like-operation-456\",\n            \"simple\",\n        ];\n\n        for op_id in operation_ids {\n            let request = Request::new(ProcessingStatusRequest {\n                operation_id: op_id.to_string(),\n            });\n\n            let result = processor.get_processing_status(request).await;\n            assert!(result.is_ok(), \"Failed for operation ID: {}\", op_id);\n\n            let response = result.unwrap().into_inner();\n            assert_eq!(response.operation_id, op_id);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_cancel_processing() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let request = Request::new(CancelProcessingRequest {\n            operation_id: \"test_cancel_operation\".to_string(),\n        });\n\n        let result = processor.cancel_processing(request).await;\n        assert!(result.is_ok());\n\n        // Response should be empty unit type\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_cancel_processing_multiple_operations() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let operation_ids = [\n            \"cancel_op_1\",\n            \"cancel_op_2\",\n            \"cancel_op_3\",\n        ];\n\n        for op_id in operation_ids {\n            let request = Request::new(CancelProcessingRequest {\n                operation_id: op_id.to_string(),\n            });\n\n            let result = processor.cancel_processing(request).await;\n            assert!(result.is_ok(), \"Failed to cancel operation: {}\", op_id);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_process_document_unique_ids() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let mut document_ids = std::collections::HashSet::new();\n\n        // Process multiple documents and verify unique IDs\n        for i in 0..5 {\n            let request = Request::new(ProcessDocumentRequest {\n                project_id: \"test_project\".to_string(),\n                document_type: crate::proto::DocumentType::Text as i32,\n                file_path: format!(\"/test/document_{}.txt\", i),\n                collection_name: \"test_collection\".to_string(),\n                metadata: HashMap::new(),\n                options: None,\n            });\n\n            let result = processor.process_document(request).await;\n            assert!(result.is_ok());\n\n            let response = result.unwrap().into_inner();\n            assert!(document_ids.insert(response.document_id.clone()),\n                    \"Duplicate document ID generated: {}\", response.document_id);\n        }\n\n        assert_eq!(document_ids.len(), 5);\n    }\n\n    #[tokio::test]\n    async fn test_process_document_timestamps() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let before_processing = chrono::Utc::now().timestamp();\n\n        let request = Request::new(ProcessDocumentRequest {\n            project_id: \"test_project\".to_string(),\n            document_type: crate::proto::DocumentType::Text as i32,\n            file_path: \"/test/timestamp_test.txt\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n            metadata: HashMap::new(),\n            options: None,\n        });\n\n        let result = processor.process_document(request).await;\n        assert!(result.is_ok());\n\n        let after_processing = chrono::Utc::now().timestamp();\n        let response = result.unwrap().into_inner();\n\n        assert!(response.processed_at.is_some());\n        let processed_timestamp = response.processed_at.unwrap().seconds;\n        assert!(processed_timestamp \u003e= before_processing);\n        assert!(processed_timestamp \u003c= after_processing);\n    }\n\n    #[tokio::test]\n    async fn test_processing_status_timestamps() {\n        let daemon = create_test_daemon().await;\n        let processor = DocumentProcessorImpl::new(daemon);\n\n        let request = Request::new(ProcessingStatusRequest {\n            operation_id: \"timestamp_test_op\".to_string(),\n        });\n\n        let result = processor.get_processing_status(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.started_at.is_some());\n        assert!(response.updated_at.is_some());\n\n        let started_timestamp = response.started_at.unwrap().seconds;\n        let updated_timestamp = response.updated_at.unwrap().seconds;\n\n        // Updated timestamp should be after started timestamp\n        assert!(updated_timestamp \u003e= started_timestamp);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_document_processing() {\n        let daemon = create_test_daemon().await;\n        let processor = Arc::new(DocumentProcessorImpl::new(daemon));\n\n        let mut handles = vec![];\n\n        // Process multiple documents concurrently\n        for i in 0..5 {\n            let processor_clone = Arc::clone(\u0026processor);\n            let handle = tokio::spawn(async move {\n                let request = Request::new(ProcessDocumentRequest {\n                    project_id: \"test_project\".to_string(),\n                    document_type: crate::proto::DocumentType::Text as i32,\n                    file_path: format!(\"/test/concurrent_doc_{}.txt\", i),\n                    collection_name: \"test_collection\".to_string(),\n                    metadata: HashMap::new(),\n                    options: None,\n                });\n\n                processor_clone.process_document(request).await\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all tasks to complete\n        let results: Vec\u003c_\u003e = futures_util::future::join_all(handles).await;\n\n        // All tasks should complete successfully\n        for (i, result) in results.into_iter().enumerate() {\n            let task_result = result.unwrap();\n            assert!(task_result.is_ok(), \"Task {} failed\", i);\n\n            let response = task_result.unwrap().into_inner();\n            assert!(!response.document_id.is_empty());\n            assert_eq!(response.status, crate::proto::ProcessingStatus::Completed as i32);\n        }\n    }\n\n    #[test]\n    fn test_document_processor_impl_send_sync() {\n        fn assert_send\u003cT: Send\u003e() {}\n        fn assert_sync\u003cT: Sync\u003e() {}\n\n        assert_send::\u003cDocumentProcessorImpl\u003e();\n        assert_sync::\u003cDocumentProcessorImpl\u003e();\n    }\n}","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":14}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}}],"covered":1,"coverable":10},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","grpc","services","memory_service.rs"],"content":"//! Memory management gRPC service implementation\n\nuse crate::daemon::WorkspaceDaemon;\nuse crate::proto::{\n    memory_service_server::MemoryService,\n    AddDocumentRequest, AddDocumentResponse,\n    UpdateDocumentRequest, UpdateDocumentResponse,\n    RemoveDocumentRequest, GetDocumentRequest, GetDocumentResponse,\n    ListDocumentsRequest, ListDocumentsResponse,\n    CreateCollectionRequest, CreateCollectionResponse,\n    DeleteCollectionRequest, ListCollectionsRequest, ListCollectionsResponse,\n    DocumentInfo, CollectionInfo, DocumentContent, CollectionConfig,\n};\nuse std::sync::Arc;\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, error, info};\n\n/// Memory service implementation\n#[derive(Debug)]\npub struct MemoryServiceImpl {\n    daemon: Arc\u003cWorkspaceDaemon\u003e,\n}\n\nimpl MemoryServiceImpl {\n    pub fn new(daemon: Arc\u003cWorkspaceDaemon\u003e) -\u003e Self {\n        Self { daemon }\n    }\n}\n\n#[tonic::async_trait]\nimpl MemoryService for MemoryServiceImpl {\n    async fn add_document(\n        \u0026self,\n        request: Request\u003cAddDocumentRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cAddDocumentResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Adding document: {}\", req.file_path);\n\n        // TODO: Implement actual document addition\n        let response = AddDocumentResponse {\n            document_id: uuid::Uuid::new_v4().to_string(),\n            success: true,\n            error_message: String::new(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn update_document(\n        \u0026self,\n        request: Request\u003cUpdateDocumentRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cUpdateDocumentResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Updating document: {}\", req.document_id);\n\n        // TODO: Implement actual document update\n        let response = UpdateDocumentResponse {\n            success: true,\n            error_message: String::new(),\n            updated_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn remove_document(\n        \u0026self,\n        request: Request\u003cRemoveDocumentRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003c()\u003e, Status\u003e {\n        let req = request.into_inner();\n        info!(\"Removing document: {} from collection: {}\", req.document_id, req.collection_name);\n\n        // TODO: Implement actual document removal\n\n        Ok(Response::new(()))\n    }\n\n    async fn get_document(\n        \u0026self,\n        request: Request\u003cGetDocumentRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cGetDocumentResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Getting document: {} from collection: {}\", req.document_id, req.collection_name);\n\n        // TODO: Implement actual document retrieval\n        let response = GetDocumentResponse {\n            document_id: req.document_id.clone(),\n            content: Some(DocumentContent {\n                text: \"Example document content\".to_string(),\n                chunks: vec![],\n                extracted_metadata: std::collections::HashMap::new(),\n            }),\n            metadata: std::collections::HashMap::new(),\n            created_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp() - 86400,\n                nanos: 0,\n            }),\n            updated_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn list_documents(\n        \u0026self,\n        request: Request\u003cListDocumentsRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cListDocumentsResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Listing documents in collection: {}\", req.collection_name);\n\n        // TODO: Implement actual document listing\n        let response = ListDocumentsResponse {\n            documents: vec![\n                DocumentInfo {\n                    document_id: uuid::Uuid::new_v4().to_string(),\n                    file_path: \"/example/document.txt\".to_string(),\n                    title: \"Example Document\".to_string(),\n                    document_type: crate::proto::DocumentType::Text as i32,\n                    file_size: 1024,\n                    metadata: std::collections::HashMap::new(),\n                    created_at: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp() - 86400,\n                        nanos: 0,\n                    }),\n                    updated_at: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n            ],\n            total_count: 1,\n            has_more: false,\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn create_collection(\n        \u0026self,\n        request: Request\u003cCreateCollectionRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cCreateCollectionResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        info!(\"Creating collection: {} for project: {}\", req.collection_name, req.project_id);\n\n        // TODO: Implement actual collection creation\n        let response = CreateCollectionResponse {\n            success: true,\n            error_message: String::new(),\n            collection_id: uuid::Uuid::new_v4().to_string(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn delete_collection(\n        \u0026self,\n        request: Request\u003cDeleteCollectionRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003c()\u003e, Status\u003e {\n        let req = request.into_inner();\n        info!(\"Deleting collection: {} for project: {} (force: {})\",\n              req.collection_name, req.project_id, req.force);\n\n        // TODO: Implement actual collection deletion\n\n        Ok(Response::new(()))\n    }\n\n    async fn list_collections(\n        \u0026self,\n        request: Request\u003cListCollectionsRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cListCollectionsResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Listing collections for project: {}\", req.project_id);\n\n        // TODO: Implement actual collection listing\n        let response = ListCollectionsResponse {\n            collections: vec![\n                CollectionInfo {\n                    collection_name: \"example-collection\".to_string(),\n                    collection_id: uuid::Uuid::new_v4().to_string(),\n                    project_id: req.project_id.clone(),\n                    document_count: 10,\n                    total_size_bytes: 10240,\n                    config: Some(CollectionConfig {\n                        vector_size: 384,\n                        distance_metric: \"Cosine\".to_string(),\n                        enable_indexing: true,\n                        metadata_schema: std::collections::HashMap::new(),\n                    }),\n                    created_at: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp() - 86400,\n                        nanos: 0,\n                    }),\n                },\n            ],\n        };\n\n        Ok(Response::new(response))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use tempfile::TempDir;\n    use tonic::Request;\n    use tokio_test;\n    use std::collections::HashMap;\n\n    fn create_test_daemon_config() -\u003e DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\";\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50053,\n                max_connections: 100,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 60,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path.to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: crate::config::CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 2,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 1024 * 1024,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 10,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    async fn create_test_daemon() -\u003e Arc\u003cWorkspaceDaemon\u003e {\n        let config = create_test_daemon_config();\n        Arc::new(WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\"))\n    }\n\n    #[tokio::test]\n    async fn test_memory_service_impl_new() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon.clone());\n\n        assert!(Arc::ptr_eq(\u0026service.daemon, \u0026daemon));\n    }\n\n    #[tokio::test]\n    async fn test_memory_service_impl_debug() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let debug_str = format!(\"{:?}\", service);\n        assert!(debug_str.contains(\"MemoryServiceImpl\"));\n        assert!(debug_str.contains(\"daemon\"));\n    }\n\n    #[tokio::test]\n    async fn test_add_document_basic() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(AddDocumentRequest {\n            file_path: \"/test/document.txt\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n            content: Some(DocumentContent {\n                text: \"Test document content\".to_string(),\n                chunks: vec![],\n                extracted_metadata: HashMap::new(),\n            }),\n            metadata: HashMap::new(),\n            project_id: \"test_project\".to_string(),\n        });\n\n        let result = service.add_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.document_id.is_empty());\n        assert!(response.success);\n        assert!(response.error_message.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_add_document_with_metadata() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let mut metadata = HashMap::new();\n        metadata.insert(\"author\".to_string(), \"John Doe\".to_string());\n        metadata.insert(\"category\".to_string(), \"documentation\".to_string());\n        metadata.insert(\"version\".to_string(), \"1.0\".to_string());\n\n        let mut extracted_metadata = HashMap::new();\n        extracted_metadata.insert(\"word_count\".to_string(), \"150\".to_string());\n        extracted_metadata.insert(\"language\".to_string(), \"en\".to_string());\n\n        let request = Request::new(AddDocumentRequest {\n            file_path: \"/test/document_with_metadata.txt\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n            content: Some(DocumentContent {\n                text: \"Test document with metadata\".to_string(),\n                chunks: vec![\n                    crate::proto::DocumentChunk {\n                        id: \"chunk1\".to_string(),\n                        content: \"First chunk content\".to_string(),\n                        start_offset: 0,\n                        end_offset: 50,\n                        metadata: HashMap::new(),\n                    },\n                    crate::proto::DocumentChunk {\n                        id: \"chunk2\".to_string(),\n                        content: \"Second chunk content\".to_string(),\n                        start_offset: 51,\n                        end_offset: 100,\n                        metadata: HashMap::new(),\n                    },\n                ],\n                extracted_metadata,\n            }),\n            metadata,\n            project_id: \"test_project\".to_string(),\n        });\n\n        let result = service.add_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.document_id.is_empty());\n        assert!(response.success);\n    }\n\n    #[tokio::test]\n    async fn test_add_document_different_file_types() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let file_types = [\n            (\"document.txt\", \"text/plain\"),\n            (\"readme.md\", \"text/markdown\"),\n            (\"script.py\", \"text/x-python\"),\n            (\"code.rs\", \"text/x-rust\"),\n            (\"data.json\", \"application/json\"),\n            (\"page.html\", \"text/html\"),\n        ];\n\n        for (file_name, _mime_type) in file_types {\n            let request = Request::new(AddDocumentRequest {\n                file_path: format!(\"/test/{}\", file_name),\n                collection_name: \"test_collection\".to_string(),\n                content: Some(DocumentContent {\n                    text: format!(\"Content for {}\", file_name),\n                    chunks: vec![],\n                    extracted_metadata: HashMap::new(),\n                }),\n                metadata: HashMap::new(),\n                project_id: \"test_project\".to_string(),\n            });\n\n            let result = service.add_document(request).await;\n            assert!(result.is_ok(), \"Failed to add document: {}\", file_name);\n\n            let response = result.unwrap().into_inner();\n            assert!(response.success);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_update_document_basic() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(UpdateDocumentRequest {\n            document_id: \"test_doc_123\".to_string(),\n            content: Some(DocumentContent {\n                text: \"Updated document content\".to_string(),\n                chunks: vec![],\n                extracted_metadata: HashMap::new(),\n            }),\n            metadata: HashMap::new(),\n        });\n\n        let result = service.update_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.success);\n        assert!(response.error_message.is_empty());\n        assert!(response.updated_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_update_document_timestamp() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let before_update = chrono::Utc::now().timestamp();\n\n        let request = Request::new(UpdateDocumentRequest {\n            document_id: \"timestamp_test_doc\".to_string(),\n            content: Some(DocumentContent {\n                text: \"Timestamp test content\".to_string(),\n                chunks: vec![],\n                extracted_metadata: HashMap::new(),\n            }),\n            metadata: HashMap::new(),\n        });\n\n        let result = service.update_document(request).await;\n        assert!(result.is_ok());\n\n        let after_update = chrono::Utc::now().timestamp();\n        let response = result.unwrap().into_inner();\n\n        assert!(response.updated_at.is_some());\n        let updated_timestamp = response.updated_at.unwrap().seconds;\n        assert!(updated_timestamp \u003e= before_update);\n        assert!(updated_timestamp \u003c= after_update);\n    }\n\n    #[tokio::test]\n    async fn test_remove_document() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(RemoveDocumentRequest {\n            document_id: \"doc_to_remove\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n        });\n\n        let result = service.remove_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_get_document() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let document_id = \"test_document_123\";\n        let collection_name = \"test_collection\";\n\n        let request = Request::new(GetDocumentRequest {\n            document_id: document_id.to_string(),\n            collection_name: collection_name.to_string(),\n        });\n\n        let result = service.get_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.document_id, document_id);\n        assert!(response.content.is_some());\n        assert!(response.created_at.is_some());\n        assert!(response.updated_at.is_some());\n\n        let content = response.content.unwrap();\n        assert_eq!(content.text, \"Example document content\");\n    }\n\n    #[tokio::test]\n    async fn test_get_document_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(GetDocumentRequest {\n            document_id: \"timestamp_doc\".to_string(),\n            collection_name: \"test_collection\".to_string(),\n        });\n\n        let result = service.get_document(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.created_at.is_some());\n        assert!(response.updated_at.is_some());\n\n        let created_timestamp = response.created_at.unwrap().seconds;\n        let updated_timestamp = response.updated_at.unwrap().seconds;\n\n        // Updated should be after created (or equal)\n        assert!(updated_timestamp \u003e= created_timestamp);\n    }\n\n    #[tokio::test]\n    async fn test_list_documents() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(ListDocumentsRequest {\n            collection_name: \"test_collection\".to_string(),\n            project_id: \"test_project\".to_string(),\n            limit: 10,\n            offset: 0,\n            filter: None,\n        });\n\n        let result = service.list_documents(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.documents.len(), 1);\n        assert_eq!(response.total_count, 1);\n        assert!(!response.has_more);\n\n        let document = \u0026response.documents[0];\n        assert!(!document.document_id.is_empty());\n        assert_eq!(document.file_path, \"/example/document.txt\");\n        assert_eq!(document.title, \"Example Document\");\n        assert_eq!(document.file_size, 1024);\n        assert!(document.created_at.is_some());\n        assert!(document.updated_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_list_documents_pagination() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let pagination_params = [\n            (10, 0),   // First page\n            (5, 5),    // Second page\n            (1, 0),    // Single result\n            (20, 10),  // Larger offset\n        ];\n\n        for (limit, offset) in pagination_params {\n            let request = Request::new(ListDocumentsRequest {\n                collection_name: \"test_collection\".to_string(),\n                project_id: \"test_project\".to_string(),\n                limit,\n                offset,\n                filter: None,\n            });\n\n            let result = service.list_documents(request).await;\n            assert!(result.is_ok(), \"Failed for limit={}, offset={}\", limit, offset);\n\n            let response = result.unwrap().into_inner();\n            assert!(response.total_count \u003e= 0);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_create_collection() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(CreateCollectionRequest {\n            collection_name: \"new_collection\".to_string(),\n            project_id: \"test_project\".to_string(),\n            config: Some(crate::proto::CollectionConfig {\n                vector_size: 384,\n                distance_metric: \"Cosine\".to_string(),\n                enable_indexing: true,\n                metadata_schema: HashMap::new(),\n            }),\n        });\n\n        let result = service.create_collection(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.success);\n        assert!(response.error_message.is_empty());\n        assert!(!response.collection_id.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_create_collection_different_configs() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let configs = [\n            (384, \"Cosine\", true),\n            (512, \"Euclidean\", false),\n            (768, \"Dot\", true),\n            (256, \"Cosine\", false),\n        ];\n\n        for (i, (vector_size, distance_metric, enable_indexing)) in configs.iter().enumerate() {\n            let request = Request::new(CreateCollectionRequest {\n                collection_name: format!(\"collection_{}\", i),\n                project_id: \"test_project\".to_string(),\n                config: Some(crate::proto::CollectionConfig {\n                    vector_size: *vector_size,\n                    distance_metric: distance_metric.to_string(),\n                    enable_indexing: *enable_indexing,\n                    metadata_schema: HashMap::new(),\n                }),\n            });\n\n            let result = service.create_collection(request).await;\n            assert!(result.is_ok(), \"Failed for config: {:?}\", (vector_size, distance_metric, enable_indexing));\n\n            let response = result.unwrap().into_inner();\n            assert!(response.success);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_delete_collection() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(DeleteCollectionRequest {\n            collection_name: \"collection_to_delete\".to_string(),\n            project_id: \"test_project\".to_string(),\n            force: false,\n        });\n\n        let result = service.delete_collection(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_delete_collection_force() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let request = Request::new(DeleteCollectionRequest {\n            collection_name: \"force_delete_collection\".to_string(),\n            project_id: \"test_project\".to_string(),\n            force: true,\n        });\n\n        let result = service.delete_collection(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_list_collections() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let project_id = \"test_project\";\n        let request = Request::new(ListCollectionsRequest {\n            project_id: project_id.to_string(),\n        });\n\n        let result = service.list_collections(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.collections.len(), 1);\n\n        let collection = \u0026response.collections[0];\n        assert_eq!(collection.collection_name, \"example-collection\");\n        assert!(!collection.collection_id.is_empty());\n        assert_eq!(collection.project_id, project_id);\n        assert_eq!(collection.document_count, 10);\n        assert_eq!(collection.total_size_bytes, 10240);\n        assert!(collection.config.is_some());\n        assert!(collection.created_at.is_some());\n\n        let config = collection.config.as_ref().unwrap();\n        assert_eq!(config.vector_size, 384);\n        assert_eq!(config.distance_metric, \"Cosine\");\n        assert!(config.enable_indexing);\n    }\n\n    #[tokio::test]\n    async fn test_list_collections_different_projects() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let project_ids = [\n            \"project_1\",\n            \"project_2\",\n            \"my-awesome-project\",\n            \"test_project_123\",\n        ];\n\n        for project_id in project_ids {\n            let request = Request::new(ListCollectionsRequest {\n                project_id: project_id.to_string(),\n            });\n\n            let result = service.list_collections(request).await;\n            assert!(result.is_ok(), \"Failed for project: {}\", project_id);\n\n            let response = result.unwrap().into_inner();\n            assert_eq!(response.collections.len(), 1);\n            assert_eq!(response.collections[0].project_id, project_id);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_memory_operations() {\n        let daemon = create_test_daemon().await;\n        let service = Arc::new(MemoryServiceImpl::new(daemon));\n\n        let mut handles = vec![];\n\n        // Perform multiple concurrent operations\n        for i in 0..5 {\n            let service_clone = Arc::clone(\u0026service);\n            let handle = tokio::spawn(async move {\n                // Add document\n                let add_request = Request::new(AddDocumentRequest {\n                    file_path: format!(\"/test/concurrent_doc_{}.txt\", i),\n                    collection_name: \"test_collection\".to_string(),\n                    content: Some(DocumentContent {\n                        text: format!(\"Concurrent document {}\", i),\n                        chunks: vec![],\n                        extracted_metadata: HashMap::new(),\n                    }),\n                    metadata: HashMap::new(),\n                    project_id: \"test_project\".to_string(),\n                });\n\n                let add_result = service_clone.add_document(add_request).await;\n\n                // List documents\n                let list_request = Request::new(ListDocumentsRequest {\n                    collection_name: \"test_collection\".to_string(),\n                    project_id: \"test_project\".to_string(),\n                    limit: 10,\n                    offset: 0,\n                    filter: None,\n                });\n\n                let list_result = service_clone.list_documents(list_request).await;\n\n                (add_result, list_result)\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all operations to complete\n        let results: Vec\u003c_\u003e = futures_util::future::join_all(handles).await;\n\n        // All operations should complete successfully\n        for (i, result) in results.into_iter().enumerate() {\n            let (add_result, list_result) = result.unwrap();\n            assert!(add_result.is_ok(), \"Add operation {} failed\", i);\n            assert!(list_result.is_ok(), \"List operation {} failed\", i);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_document_unique_ids() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let mut document_ids = std::collections::HashSet::new();\n\n        // Add multiple documents and verify unique IDs\n        for i in 0..5 {\n            let request = Request::new(AddDocumentRequest {\n                file_path: format!(\"/test/unique_doc_{}.txt\", i),\n                collection_name: \"test_collection\".to_string(),\n                content: Some(DocumentContent {\n                    text: format!(\"Unique document {}\", i),\n                    chunks: vec![],\n                    extracted_metadata: HashMap::new(),\n                }),\n                metadata: HashMap::new(),\n                project_id: \"test_project\".to_string(),\n            });\n\n            let result = service.add_document(request).await;\n            assert!(result.is_ok());\n\n            let response = result.unwrap().into_inner();\n            assert!(document_ids.insert(response.document_id.clone()),\n                    \"Duplicate document ID generated: {}\", response.document_id);\n        }\n\n        assert_eq!(document_ids.len(), 5);\n    }\n\n    #[tokio::test]\n    async fn test_collection_unique_ids() {\n        let daemon = create_test_daemon().await;\n        let service = MemoryServiceImpl::new(daemon);\n\n        let mut collection_ids = std::collections::HashSet::new();\n\n        // Create multiple collections and verify unique IDs\n        for i in 0..5 {\n            let request = Request::new(CreateCollectionRequest {\n                collection_name: format!(\"unique_collection_{}\", i),\n                project_id: \"test_project\".to_string(),\n                config: Some(crate::proto::CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    metadata_schema: HashMap::new(),\n                }),\n            });\n\n            let result = service.create_collection(request).await;\n            assert!(result.is_ok());\n\n            let response = result.unwrap().into_inner();\n            assert!(collection_ids.insert(response.collection_id.clone()),\n                    \"Duplicate collection ID generated: {}\", response.collection_id);\n        }\n\n        assert_eq!(collection_ids.len(), 5);\n    }\n\n    #[test]\n    fn test_memory_service_impl_send_sync() {\n        fn assert_send\u003cT: Send\u003e() {}\n        fn assert_sync\u003cT: Sync\u003e() {}\n\n        assert_send::\u003cMemoryServiceImpl\u003e();\n        assert_sync::\u003cMemoryServiceImpl\u003e();\n    }\n}","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":22}}],"covered":1,"coverable":1},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","grpc","services","mod.rs"],"content":"//! gRPC service implementations\n\npub mod document_processor;\npub mod search_service;\npub mod memory_service;\npub mod system_service;\n\npub use document_processor::DocumentProcessorImpl;\npub use search_service::SearchServiceImpl;\npub use memory_service::MemoryServiceImpl;\npub use system_service::SystemServiceImpl;","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","grpc","services","search_service.rs"],"content":"//! Search service gRPC implementation\n\nuse crate::daemon::WorkspaceDaemon;\nuse crate::proto::{\n    search_service_server::SearchService,\n    HybridSearchRequest, HybridSearchResponse,\n    SemanticSearchRequest, SemanticSearchResponse,\n    KeywordSearchRequest, KeywordSearchResponse,\n    SuggestionsRequest, SuggestionsResponse,\n    SearchResult, SearchMetadata,\n};\nuse std::sync::Arc;\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, error, info};\n\n/// Search service implementation\n#[derive(Debug)]\npub struct SearchServiceImpl {\n    daemon: Arc\u003cWorkspaceDaemon\u003e,\n}\n\nimpl SearchServiceImpl {\n    pub fn new(daemon: Arc\u003cWorkspaceDaemon\u003e) -\u003e Self {\n        Self { daemon }\n    }\n}\n\n#[tonic::async_trait]\nimpl SearchService for SearchServiceImpl {\n    async fn hybrid_search(\n        \u0026self,\n        request: Request\u003cHybridSearchRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cHybridSearchResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Hybrid search requested: {}\", req.query);\n\n        // TODO: Implement actual hybrid search\n        let response = HybridSearchResponse {\n            results: vec![\n                SearchResult {\n                    document_id: uuid::Uuid::new_v4().to_string(),\n                    collection_name: \"example\".to_string(),\n                    score: 0.95,\n                    semantic_score: 0.9,\n                    keyword_score: 0.85,\n                    title: \"Example Document\".to_string(),\n                    content_snippet: \"This is an example search result...\".to_string(),\n                    metadata: std::collections::HashMap::new(),\n                    file_path: \"/path/to/document.txt\".to_string(),\n                    matched_terms: vec![\"example\".to_string()],\n                },\n            ],\n            metadata: Some(SearchMetadata {\n                total_results: 1,\n                max_score: 0.95,\n                search_time: Some(prost_types::Timestamp {\n                    seconds: chrono::Utc::now().timestamp(),\n                    nanos: 0,\n                }),\n                search_duration_ms: 25,\n                searched_collections: vec![\"example\".to_string()],\n            }),\n            query_id: uuid::Uuid::new_v4().to_string(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn semantic_search(\n        \u0026self,\n        request: Request\u003cSemanticSearchRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cSemanticSearchResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Semantic search requested: {}\", req.query);\n\n        // TODO: Implement actual semantic search\n        let response = SemanticSearchResponse {\n            results: vec![],\n            metadata: Some(SearchMetadata {\n                total_results: 0,\n                max_score: 0.0,\n                search_time: Some(prost_types::Timestamp {\n                    seconds: chrono::Utc::now().timestamp(),\n                    nanos: 0,\n                }),\n                search_duration_ms: 15,\n                searched_collections: vec![],\n            }),\n            query_id: uuid::Uuid::new_v4().to_string(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn keyword_search(\n        \u0026self,\n        request: Request\u003cKeywordSearchRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cKeywordSearchResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Keyword search requested: {}\", req.query);\n\n        // TODO: Implement actual keyword search\n        let response = KeywordSearchResponse {\n            results: vec![],\n            metadata: Some(SearchMetadata {\n                total_results: 0,\n                max_score: 0.0,\n                search_time: Some(prost_types::Timestamp {\n                    seconds: chrono::Utc::now().timestamp(),\n                    nanos: 0,\n                }),\n                search_duration_ms: 10,\n                searched_collections: vec![],\n            }),\n            query_id: uuid::Uuid::new_v4().to_string(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn get_suggestions(\n        \u0026self,\n        request: Request\u003cSuggestionsRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cSuggestionsResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Suggestions requested for: {}\", req.partial_query);\n\n        // TODO: Implement actual suggestions\n        let response = SuggestionsResponse {\n            suggestions: vec![\n                format!(\"{} complete\", req.partial_query),\n                format!(\"{} suggestion\", req.partial_query),\n            ],\n            metadata: Some(SearchMetadata {\n                total_results: 2,\n                max_score: 1.0,\n                search_time: Some(prost_types::Timestamp {\n                    seconds: chrono::Utc::now().timestamp(),\n                    nanos: 0,\n                }),\n                search_duration_ms: 5,\n                searched_collections: vec![],\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use tempfile::TempDir;\n    use tonic::Request;\n    use tokio_test;\n    use std::collections::HashMap;\n\n    fn create_test_daemon_config() -\u003e DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\";\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50054,\n                max_connections: 100,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 60,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path.to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 2,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 1024 * 1024,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 10,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    async fn create_test_daemon() -\u003e Arc\u003cWorkspaceDaemon\u003e {\n        let config = create_test_daemon_config();\n        Arc::new(WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\"))\n    }\n\n    // Helper function to create proper HybridSearchRequest\n    fn create_hybrid_search_request(\n        query: \u0026str,\n        semantic_weight: f32,\n        keyword_weight: f32,\n        limit: i32,\n        collection_names: Vec\u003cString\u003e\n    ) -\u003e HybridSearchRequest {\n        HybridSearchRequest {\n            query: query.to_string(),\n            context: crate::proto::SearchContext::Project as i32,\n            options: Some(crate::proto::SearchOptions {\n                limit,\n                score_threshold: 0.0,\n                include_metadata: true,\n                include_content: true,\n                ranking: Some(crate::proto::RankingOptions {\n                    semantic_weight,\n                    keyword_weight,\n                    rrf_constant: 60.0,\n                }),\n            }),\n            project_id: \"test_project\".to_string(),\n            collection_names,\n        }\n    }\n\n    // Helper function to create SemanticSearchRequest\n    fn create_semantic_search_request(\n        query: \u0026str,\n        similarity_threshold: f32,\n        limit: i32,\n        collection_names: Vec\u003cString\u003e\n    ) -\u003e SemanticSearchRequest {\n        SemanticSearchRequest {\n            query: query.to_string(),\n            context: crate::proto::SearchContext::Project as i32,\n            options: Some(crate::proto::SearchOptions {\n                limit,\n                score_threshold: similarity_threshold,\n                include_metadata: true,\n                include_content: true,\n                ranking: None,\n            }),\n            project_id: \"test_project\".to_string(),\n            collection_names,\n        }\n    }\n\n    // Helper function to create KeywordSearchRequest\n    fn create_keyword_search_request(\n        query: \u0026str,\n        limit: i32,\n        collection_names: Vec\u003cString\u003e\n    ) -\u003e KeywordSearchRequest {\n        KeywordSearchRequest {\n            query: query.to_string(),\n            context: crate::proto::SearchContext::Project as i32,\n            options: Some(crate::proto::SearchOptions {\n                limit,\n                score_threshold: 0.0,\n                include_metadata: true,\n                include_content: true,\n                ranking: None,\n            }),\n            project_id: \"test_project\".to_string(),\n            collection_names,\n        }\n    }\n\n    // Helper function to create SuggestionsRequest\n    fn create_suggestions_request(\n        partial_query: \u0026str,\n        limit: i32,\n        collection_names: Vec\u003cString\u003e\n    ) -\u003e SuggestionsRequest {\n        SuggestionsRequest {\n            partial_query: partial_query.to_string(),\n            context: crate::proto::SearchContext::Project as i32,\n            max_suggestions: limit,\n            project_id: \"test_project\".to_string(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_search_service_impl_new() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon.clone());\n\n        assert!(Arc::ptr_eq(\u0026service.daemon, \u0026daemon));\n    }\n\n    #[tokio::test]\n    async fn test_search_service_impl_debug() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let debug_str = format!(\"{:?}\", service);\n        assert!(debug_str.contains(\"SearchServiceImpl\"));\n        assert!(debug_str.contains(\"daemon\"));\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_search_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(HybridSearchRequest {\n            query: \"test query\".to_string(),\n            context: crate::proto::SearchContext::Collection as i32,\n            options: Some(crate::proto::SearchOptions {\n                limit: 10,\n                score_threshold: 0.0,\n                include_metadata: true,\n                include_content: true,\n                ranking: Some(crate::proto::RankingOptions {\n                    semantic_weight: 0.7,\n                    keyword_weight: 0.3,\n                    rrf_constant: 60.0,\n                }),\n            }),\n            project_id: \"test_project\".to_string(),\n            collection_names: vec![\"test_collection\".to_string()],\n        });\n\n        let result = service.hybrid_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.query_id.is_empty());\n        assert_eq!(response.results.len(), 1);\n        assert!(response.metadata.is_some());\n\n        let metadata = response.metadata.unwrap();\n        assert_eq!(metadata.total_results, 1);\n        assert_eq!(metadata.max_score, 0.95);\n        assert!(metadata.search_time.is_some());\n        assert_eq!(metadata.search_duration_ms, 25);\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_search_different_queries() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let queries = [\n            \"simple query\",\n            \"complex search with multiple terms\",\n            \"\", // Unicode characters\n            \"query with symbols !@#$%\",\n            \"12345 numeric query\",\n        ];\n\n        for query in queries {\n            let request = Request::new(create_hybrid_search_request(\n                query,\n                0.6,\n                0.4,\n                5,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.hybrid_search(request).await;\n            assert!(result.is_ok(), \"Failed for query: {}\", query);\n\n            let response = result.unwrap().into_inner();\n            assert!(!response.query_id.is_empty());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_search_different_weights() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let weight_combinations = [\n            (1.0, 0.0), // Pure semantic\n            (0.0, 1.0), // Pure keyword\n            (0.5, 0.5), // Equal weights\n            (0.8, 0.2), // Semantic-heavy\n            (0.3, 0.7), // Keyword-heavy\n        ];\n\n        for (semantic, keyword) in weight_combinations {\n            let request = Request::new(create_hybrid_search_request(\n                \"test query\",\n                semantic,\n                keyword,\n                10,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.hybrid_search(request).await;\n            assert!(result.is_ok(), \"Failed for weights: semantic={}, keyword={}\", semantic, keyword);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_search_metadata_validation() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(create_hybrid_search_request(\n            \"test query with metadata\",\n            0.7,\n            0.3,\n            10,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.hybrid_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.query_id.is_empty());\n        assert!(response.metadata.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_search_pagination() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let pagination_params = [\n            (10, 0),   // First page\n            (10, 10),  // Second page\n            (5, 0),    // Smaller page size\n            (20, 40),  // Larger offset\n            (1, 0),    // Single result\n        ];\n\n        for (limit, _offset) in pagination_params {\n            let request = Request::new(create_hybrid_search_request(\n                \"pagination test\",\n                0.7,\n                0.3,\n                limit,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.hybrid_search(request).await;\n            assert!(result.is_ok(), \"Failed for limit={}\", limit);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_semantic_search_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(create_semantic_search_request(\n            \"semantic search query\",\n            0.7,\n            10,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.semantic_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.query_id.is_empty());\n        assert!(response.metadata.is_some());\n\n        let metadata = response.metadata.unwrap();\n        assert!(metadata.search_time.is_some());\n        assert_eq!(metadata.search_duration_ms, 15);\n    }\n\n    #[tokio::test]\n    async fn test_semantic_search_different_thresholds() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let thresholds = [0.1, 0.3, 0.5, 0.7, 0.9];\n\n        for threshold in thresholds {\n            let request = Request::new(create_semantic_search_request(\n                \"threshold test\",\n                threshold,\n                10,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.semantic_search(request).await;\n            assert!(result.is_ok(), \"Failed for threshold: {}\", threshold);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_keyword_search_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(create_keyword_search_request(\n            \"keyword search\",\n            10,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.keyword_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.query_id.is_empty());\n        assert!(response.metadata.is_some());\n\n        let metadata = response.metadata.unwrap();\n        assert!(metadata.search_time.is_some());\n        assert_eq!(metadata.search_duration_ms, 10);\n    }\n\n    #[tokio::test]\n    async fn test_keyword_search_with_different_limits() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let limits = [1, 5, 10, 20, 50];\n\n        for limit in limits {\n            let request = Request::new(create_keyword_search_request(\n                \"limit test search\",\n                limit,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.keyword_search(request).await;\n            assert!(result.is_ok(), \"Failed for limit: {}\", limit);\n\n            let response = result.unwrap().into_inner();\n            assert!(!response.query_id.is_empty());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_keyword_search_different_queries() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let queries = [\"simple\", \"complex search terms\", \"special!@#$%\", \"numbers123\"];\n\n        for query in queries {\n            let request = Request::new(create_keyword_search_request(\n                query,\n                10,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.keyword_search(request).await;\n            assert!(result.is_ok(), \"Failed for query: {}\", query);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_suggestions_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(create_suggestions_request(\n            \"test\",\n            5,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.get_suggestions(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.suggestions.len(), 2);\n        assert!(response.suggestions[0].contains(\"test\"));\n        assert!(response.suggestions[1].contains(\"test\"));\n        assert!(response.metadata.is_some());\n\n        let metadata = response.metadata.unwrap();\n        assert_eq!(metadata.total_results, 2);\n        assert_eq!(metadata.search_duration_ms, 5);\n    }\n\n    #[tokio::test]\n    async fn test_get_suggestions_different_queries() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let partial_queries = [\n            \"t\",\n            \"te\",\n            \"test\",\n            \"testing\",\n            \"query\",\n            \"search\",\n        ];\n\n        for partial in partial_queries {\n            let request = Request::new(create_suggestions_request(\n                partial,\n                5,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.get_suggestions(request).await;\n            assert!(result.is_ok(), \"Failed for partial query: {}\", partial);\n\n            let response = result.unwrap().into_inner();\n            assert_eq!(response.suggestions.len(), 2);\n            for suggestion in \u0026response.suggestions {\n                assert!(suggestion.contains(partial));\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_suggestions_different_limits() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let limits = [1, 3, 5, 10, 20];\n\n        for limit in limits {\n            let request = Request::new(create_suggestions_request(\n                \"suggestion\",\n                limit,\n                vec![\"test_collection\".to_string()]\n            ));\n\n            let result = service.get_suggestions(request).await;\n            assert!(result.is_ok(), \"Failed for limit: {}\", limit);\n\n            let response = result.unwrap().into_inner();\n            // Current implementation returns 2 suggestions regardless of limit\n            assert_eq!(response.suggestions.len(), 2);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_search_service_multiple_collections() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let collections = vec![\n            \"collection1\".to_string(),\n            \"collection2\".to_string(),\n            \"documents\".to_string(),\n            \"code\".to_string(),\n        ];\n\n        let request = Request::new(create_hybrid_search_request(\n            \"multi-collection search\",\n            0.7,\n            0.3,\n            10,\n            collections.clone()\n        ));\n\n        let result = service.hybrid_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.query_id.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_search_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let before_search = chrono::Utc::now().timestamp();\n\n        let request = Request::new(create_hybrid_search_request(\n            \"timestamp test\",\n            0.7,\n            0.3,\n            10,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.hybrid_search(request).await;\n        assert!(result.is_ok());\n\n        let after_search = chrono::Utc::now().timestamp();\n        let response = result.unwrap().into_inner();\n\n        assert!(response.metadata.is_some());\n        let metadata = response.metadata.unwrap();\n        assert!(metadata.search_time.is_some());\n\n        let search_timestamp = metadata.search_time.unwrap().seconds;\n        assert!(search_timestamp \u003e= before_search);\n        assert!(search_timestamp \u003c= after_search);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_searches() {\n        let daemon = create_test_daemon().await;\n        let service = Arc::new(SearchServiceImpl::new(daemon));\n\n        let mut handles = vec![];\n\n        // Perform multiple concurrent searches\n        for i in 0..5 {\n            let service_clone = Arc::clone(\u0026service);\n            let handle = tokio::spawn(async move {\n                let request = Request::new(create_hybrid_search_request(\n                    \u0026format!(\"concurrent search {}\", i),\n                    0.7,\n                    0.3,\n                    10,\n                    vec![\"test_collection\".to_string()]\n                ));\n\n                service_clone.hybrid_search(request).await\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all searches to complete\n        let results: Vec\u003c_\u003e = futures_util::future::join_all(handles).await;\n\n        // All searches should complete successfully\n        for (i, result) in results.into_iter().enumerate() {\n            let task_result = result.unwrap();\n            assert!(task_result.is_ok(), \"Search {} failed\", i);\n\n            let response = task_result.unwrap().into_inner();\n            assert!(!response.query_id.is_empty());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_search_result_structure() {\n        let daemon = create_test_daemon().await;\n        let service = SearchServiceImpl::new(daemon);\n\n        let request = Request::new(create_hybrid_search_request(\n            \"structure test\",\n            0.7,\n            0.3,\n            10,\n            vec![\"test_collection\".to_string()]\n        ));\n\n        let result = service.hybrid_search(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.results.len(), 1);\n\n        let search_result = \u0026response.results[0];\n        assert!(!search_result.document_id.is_empty());\n        assert_eq!(search_result.collection_name, \"example\");\n        assert_eq!(search_result.score, 0.95);\n        assert_eq!(search_result.semantic_score, 0.9);\n        assert_eq!(search_result.keyword_score, 0.85);\n        assert_eq!(search_result.title, \"Example Document\");\n        assert!(!search_result.content_snippet.is_empty());\n        assert!(!search_result.file_path.is_empty());\n        assert_eq!(search_result.matched_terms.len(), 1);\n    }\n\n    #[test]\n    fn test_search_service_impl_send_sync() {\n        fn assert_send\u003cT: Send\u003e() {}\n        fn assert_sync\u003cT: Sync\u003e() {}\n\n        assert_send::\u003cSearchServiceImpl\u003e();\n        assert_sync::\u003cSearchServiceImpl\u003e();\n    }\n}","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":20}}],"covered":1,"coverable":1},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","grpc","services","system_service.rs"],"content":"//! System administration gRPC service implementation\n\nuse crate::daemon::WorkspaceDaemon;\nuse crate::proto::{\n    system_service_server::SystemService,\n    HealthCheckResponse, SystemStatusResponse, MetricsRequest, MetricsResponse,\n    ConfigResponse, UpdateConfigRequest, DetectProjectRequest, DetectProjectResponse,\n    ListProjectsResponse, ServiceStatus, ComponentHealth, SystemMetrics, ProjectInfo,\n};\nuse std::sync::Arc;\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, error, info};\n\n/// System service implementation\n#[derive(Debug)]\npub struct SystemServiceImpl {\n    daemon: Arc\u003cWorkspaceDaemon\u003e,\n}\n\nimpl SystemServiceImpl {\n    pub fn new(daemon: Arc\u003cWorkspaceDaemon\u003e) -\u003e Self {\n        Self { daemon }\n    }\n}\n\n#[tonic::async_trait]\nimpl SystemService for SystemServiceImpl {\n    async fn health_check(\n        \u0026self,\n        _request: Request\u003c()\u003e,\n    ) -\u003e Result\u003cResponse\u003cHealthCheckResponse\u003e, Status\u003e {\n        debug!(\"Health check requested\");\n\n        // TODO: Implement actual health checks\n        let response = HealthCheckResponse {\n            status: ServiceStatus::Healthy as i32,\n            components: vec![\n                ComponentHealth {\n                    component_name: \"database\".to_string(),\n                    status: ServiceStatus::Healthy as i32,\n                    message: \"SQLite database operational\".to_string(),\n                    last_check: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n                ComponentHealth {\n                    component_name: \"qdrant\".to_string(),\n                    status: ServiceStatus::Healthy as i32,\n                    message: \"Qdrant connection active\".to_string(),\n                    last_check: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n                ComponentHealth {\n                    component_name: \"file_watcher\".to_string(),\n                    status: ServiceStatus::Healthy as i32,\n                    message: \"File watching active\".to_string(),\n                    last_check: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n            ],\n            timestamp: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn get_status(\n        \u0026self,\n        _request: Request\u003c()\u003e,\n    ) -\u003e Result\u003cResponse\u003cSystemStatusResponse\u003e, Status\u003e {\n        debug!(\"System status requested\");\n\n        // TODO: Implement actual system status collection\n        let response = SystemStatusResponse {\n            status: ServiceStatus::Healthy as i32,\n            metrics: Some(SystemMetrics {\n                cpu_usage_percent: 15.5,\n                memory_usage_bytes: 128 * 1024 * 1024, // 128MB\n                memory_total_bytes: 8 * 1024 * 1024 * 1024, // 8GB\n                disk_usage_bytes: 2 * 1024 * 1024 * 1024, // 2GB\n                disk_total_bytes: 500 * 1024 * 1024 * 1024, // 500GB\n                active_connections: 5,\n                pending_operations: 0,\n            }),\n            active_projects: vec![\"workspace-qdrant-mcp\".to_string()],\n            total_documents: 1000,\n            total_collections: 5,\n            uptime_since: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp() - 3600, // 1 hour ago\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn get_metrics(\n        \u0026self,\n        request: Request\u003cMetricsRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cMetricsResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Metrics requested: {:?}\", req.metric_names);\n\n        // TODO: Implement actual metrics collection\n        let response = MetricsResponse {\n            metrics: vec![\n                crate::proto::Metric {\n                    name: \"grpc_requests_total\".to_string(),\n                    r#type: \"counter\".to_string(),\n                    labels: [(\"method\".to_string(), \"ProcessDocument\".to_string())].into_iter().collect(),\n                    value: 150.0,\n                    timestamp: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n                crate::proto::Metric {\n                    name: \"document_processing_duration_seconds\".to_string(),\n                    r#type: \"histogram\".to_string(),\n                    labels: [(\"status\".to_string(), \"success\".to_string())].into_iter().collect(),\n                    value: 2.5,\n                    timestamp: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp(),\n                        nanos: 0,\n                    }),\n                },\n            ],\n            collected_at: Some(prost_types::Timestamp {\n                seconds: chrono::Utc::now().timestamp(),\n                nanos: 0,\n            }),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn get_config(\n        \u0026self,\n        _request: Request\u003c()\u003e,\n    ) -\u003e Result\u003cResponse\u003cConfigResponse\u003e, Status\u003e {\n        debug!(\"Configuration requested\");\n\n        let config = self.daemon.config();\n\n        // Convert configuration to string map\n        let mut configuration = std::collections::HashMap::new();\n        configuration.insert(\"server.host\".to_string(), config.server.host.clone());\n        configuration.insert(\"server.port\".to_string(), config.server.port.to_string());\n        configuration.insert(\"qdrant.url\".to_string(), config.qdrant.url.clone());\n        configuration.insert(\"database.sqlite_path\".to_string(), config.database.sqlite_path.clone());\n        configuration.insert(\"processing.max_concurrent_tasks\".to_string(), config.processing.max_concurrent_tasks.to_string());\n\n        let response = ConfigResponse {\n            configuration,\n            version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn update_config(\n        \u0026self,\n        request: Request\u003cUpdateConfigRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003c()\u003e, Status\u003e {\n        let req = request.into_inner();\n        info!(\"Configuration update requested: {:?}\", req.configuration);\n\n        // TODO: Implement configuration updates\n        // For now, just log the request\n\n        if req.restart_required {\n            info!(\"Configuration update requires restart\");\n        }\n\n        Ok(Response::new(()))\n    }\n\n    async fn detect_project(\n        \u0026self,\n        request: Request\u003cDetectProjectRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cDetectProjectResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        debug!(\"Project detection requested for: {}\", req.path);\n\n        // TODO: Implement actual project detection\n        let response = DetectProjectResponse {\n            project: Some(ProjectInfo {\n                project_id: uuid::Uuid::new_v4().to_string(),\n                name: \"example-project\".to_string(),\n                root_path: req.path.clone(),\n                git_repository: \"https://github.com/example/project.git\".to_string(),\n                git_branch: \"main\".to_string(),\n                submodules: vec![],\n                metadata: [(\"detected_at\".to_string(), chrono::Utc::now().to_rfc3339())].into_iter().collect(),\n                detected_at: Some(prost_types::Timestamp {\n                    seconds: chrono::Utc::now().timestamp(),\n                    nanos: 0,\n                }),\n            }),\n            is_valid_project: true,\n            reasons: vec![\"Git repository detected\".to_string()],\n        };\n\n        Ok(Response::new(response))\n    }\n\n    async fn list_projects(\n        \u0026self,\n        _request: Request\u003c()\u003e,\n    ) -\u003e Result\u003cResponse\u003cListProjectsResponse\u003e, Status\u003e {\n        debug!(\"Project list requested\");\n\n        // TODO: Implement actual project listing\n        let response = ListProjectsResponse {\n            projects: vec![\n                ProjectInfo {\n                    project_id: uuid::Uuid::new_v4().to_string(),\n                    name: \"workspace-qdrant-mcp\".to_string(),\n                    root_path: \"/Users/example/workspace-qdrant-mcp\".to_string(),\n                    git_repository: \"https://github.com/example/workspace-qdrant-mcp.git\".to_string(),\n                    git_branch: \"main\".to_string(),\n                    submodules: vec![],\n                    metadata: [(\"language\".to_string(), \"rust,python\".to_string())].into_iter().collect(),\n                    detected_at: Some(prost_types::Timestamp {\n                        seconds: chrono::Utc::now().timestamp() - 86400, // 1 day ago\n                        nanos: 0,\n                    }),\n                },\n            ],\n        };\n\n        Ok(Response::new(response))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::*;\n    use tempfile::TempDir;\n    use tonic::Request;\n    use tokio_test;\n    use std::collections::HashMap;\n\n    fn create_test_daemon_config() -\u003e DaemonConfig {\n        // Use in-memory SQLite database for tests\n        let db_path = \":memory:\";\n\n        DaemonConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 50051,\n                max_connections: 100,\n                connection_timeout_secs: 30,\n                request_timeout_secs: 60,\n                enable_tls: false,\n            },\n            database: DatabaseConfig {\n                sqlite_path: db_path.to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            qdrant: QdrantConfig {\n                url: \"http://localhost:6333\".to_string(),\n                api_key: None,\n                timeout_secs: 30,\n                max_retries: 3,\n                default_collection: crate::config::CollectionConfig {\n                    vector_size: 384,\n                    distance_metric: \"Cosine\".to_string(),\n                    enable_indexing: true,\n                    replication_factor: 1,\n                    shard_number: 1,\n                },\n            },\n            processing: ProcessingConfig {\n                max_concurrent_tasks: 4,\n                default_chunk_size: 1000,\n                default_chunk_overlap: 200,\n                max_file_size_bytes: 1024 * 1024,\n                supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n                enable_lsp: false,\n                lsp_timeout_secs: 10,\n            },\n            file_watcher: FileWatcherConfig {\n                enabled: false,\n                debounce_ms: 500,\n                max_watched_dirs: 10,\n                ignore_patterns: vec![],\n                recursive: true,\n            },\n            metrics: MetricsConfig {\n                enabled: false,\n                collection_interval_secs: 60,\n                retention_days: 30,\n                enable_prometheus: false,\n                prometheus_port: 9090,\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                file_path: None,\n                json_format: false,\n                max_file_size_mb: 100,\n                max_files: 5,\n            },\n        }\n    }\n\n    async fn create_test_daemon() -\u003e Arc\u003cWorkspaceDaemon\u003e {\n        let config = create_test_daemon_config();\n        Arc::new(WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\"))\n    }\n\n    #[tokio::test]\n    async fn test_system_service_impl_new() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon.clone());\n\n        assert!(Arc::ptr_eq(\u0026service.daemon, \u0026daemon));\n    }\n\n    #[tokio::test]\n    async fn test_system_service_impl_debug() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let debug_str = format!(\"{:?}\", service);\n        assert!(debug_str.contains(\"SystemServiceImpl\"));\n        assert!(debug_str.contains(\"daemon\"));\n    }\n\n    #[tokio::test]\n    async fn test_health_check() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.health_check(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.status, ServiceStatus::Healthy as i32);\n        assert_eq!(response.components.len(), 3);\n        assert!(response.timestamp.is_some());\n\n        // Check individual components\n        let component_names: Vec\u003c_\u003e = response.components.iter()\n            .map(|c| c.component_name.as_str())\n            .collect();\n        assert!(component_names.contains(\u0026\"database\"));\n        assert!(component_names.contains(\u0026\"qdrant\"));\n        assert!(component_names.contains(\u0026\"file_watcher\"));\n\n        // All components should be healthy\n        for component in \u0026response.components {\n            assert_eq!(component.status, ServiceStatus::Healthy as i32);\n            assert!(!component.message.is_empty());\n            assert!(component.last_check.is_some());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_health_check_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let before_check = chrono::Utc::now().timestamp();\n        let request = Request::new(());\n        let result = service.health_check(request).await;\n        let after_check = chrono::Utc::now().timestamp();\n\n        assert!(result.is_ok());\n        let response = result.unwrap().into_inner();\n\n        // Main timestamp\n        assert!(response.timestamp.is_some());\n        let timestamp = response.timestamp.unwrap().seconds;\n        assert!(timestamp \u003e= before_check \u0026\u0026 timestamp \u003c= after_check);\n\n        // Component timestamps\n        for component in \u0026response.components {\n            assert!(component.last_check.is_some());\n            let component_timestamp = component.last_check.as_ref().unwrap().seconds;\n            assert!(component_timestamp \u003e= before_check \u0026\u0026 component_timestamp \u003c= after_check);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_status() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.get_status(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.status, ServiceStatus::Healthy as i32);\n        assert!(response.metrics.is_some());\n        assert_eq!(response.active_projects.len(), 1);\n        assert_eq!(response.active_projects[0], \"workspace-qdrant-mcp\");\n        assert_eq!(response.total_documents, 1000);\n        assert_eq!(response.total_collections, 5);\n        assert!(response.uptime_since.is_some());\n\n        // Check metrics\n        let metrics = response.metrics.unwrap();\n        assert_eq!(metrics.cpu_usage_percent, 15.5);\n        assert_eq!(metrics.memory_usage_bytes, 128 * 1024 * 1024);\n        assert_eq!(metrics.memory_total_bytes, 8 * 1024 * 1024 * 1024);\n        assert_eq!(metrics.disk_usage_bytes, 2 * 1024 * 1024 * 1024);\n        assert_eq!(metrics.disk_total_bytes, 500 * 1024 * 1024 * 1024);\n        assert_eq!(metrics.active_connections, 5);\n        assert_eq!(metrics.pending_operations, 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_status_uptime() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.get_status(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.uptime_since.is_some());\n\n        let uptime_timestamp = response.uptime_since.unwrap().seconds;\n        let current_time = chrono::Utc::now().timestamp();\n\n        // Uptime should be in the past (simulated as 1 hour ago)\n        assert!(uptime_timestamp \u003c current_time);\n        assert!(current_time - uptime_timestamp \u003e= 3500); // Allow some margin\n    }\n\n    #[tokio::test]\n    async fn test_get_metrics_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(MetricsRequest {\n            since: None,\n            metric_names: vec![\"grpc_requests_total\".to_string()],\n        });\n\n        let result = service.get_metrics(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.metrics.len(), 2);\n        assert!(response.collected_at.is_some());\n\n        // Check specific metrics\n        let grpc_metric = response.metrics.iter()\n            .find(|m| m.name == \"grpc_requests_total\")\n            .expect(\"grpc_requests_total metric not found\");\n        assert_eq!(grpc_metric.r#type, \"counter\");\n        assert_eq!(grpc_metric.value, 150.0);\n        assert!(grpc_metric.labels.contains_key(\"method\"));\n        assert!(grpc_metric.timestamp.is_some());\n\n        let duration_metric = response.metrics.iter()\n            .find(|m| m.name == \"document_processing_duration_seconds\")\n            .expect(\"duration metric not found\");\n        assert_eq!(duration_metric.r#type, \"histogram\");\n        assert_eq!(duration_metric.value, 2.5);\n        assert!(duration_metric.labels.contains_key(\"status\"));\n    }\n\n    #[tokio::test]\n    async fn test_get_metrics_different_requests() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let metric_requests = [\n            vec![\"grpc_requests_total\".to_string()],\n            vec![\"document_processing_duration_seconds\".to_string()],\n            vec![\"grpc_requests_total\".to_string(), \"document_processing_duration_seconds\".to_string()],\n            vec![], // Empty list\n            vec![\"nonexistent_metric\".to_string()],\n        ];\n\n        for metrics in metric_requests {\n            let request = Request::new(MetricsRequest {\n                since: None,\n                metric_names: metrics.clone(),\n            });\n\n            let result = service.get_metrics(request).await;\n            assert!(result.is_ok(), \"Failed for metrics: {:?}\", metrics);\n\n            let response = result.unwrap().into_inner();\n            // Current implementation returns 2 metrics regardless of request\n            assert_eq!(response.metrics.len(), 2);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_metrics_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let before_request = chrono::Utc::now().timestamp();\n        let request = Request::new(MetricsRequest {\n            since: Some(prost_types::Timestamp {\n                seconds: before_request - 3600,\n                nanos: 0,\n            }),\n            metric_names: vec![\"test_metric\".to_string()],\n        });\n\n        let result = service.get_metrics(request).await;\n        let after_request = chrono::Utc::now().timestamp();\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.collected_at.is_some());\n\n        let collected_timestamp = response.collected_at.unwrap().seconds;\n        assert!(collected_timestamp \u003e= before_request \u0026\u0026 collected_timestamp \u003c= after_request);\n\n        // Check individual metric timestamps\n        for metric in \u0026response.metrics {\n            assert!(metric.timestamp.is_some());\n            let metric_timestamp = metric.timestamp.as_ref().unwrap().seconds;\n            assert!(metric_timestamp \u003e= before_request \u0026\u0026 metric_timestamp \u003c= after_request);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_config() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.get_config(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(!response.configuration.is_empty());\n        assert!(!response.version.is_empty());\n\n        // Check specific configuration values\n        assert_eq!(response.configuration.get(\"server.host\").unwrap(), \"127.0.0.1\");\n        assert_eq!(response.configuration.get(\"server.port\").unwrap(), \"50051\");\n        assert_eq!(response.configuration.get(\"qdrant.url\").unwrap(), \"http://localhost:6333\");\n        assert!(response.configuration.contains_key(\"database.sqlite_path\"));\n        assert_eq!(response.configuration.get(\"processing.max_concurrent_tasks\").unwrap(), \"4\");\n\n        // Check version format\n        let version = \u0026response.version;\n        assert!(version.contains('.'), \"Version should contain dots: {}\", version);\n    }\n\n    #[tokio::test]\n    async fn test_update_config_basic() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let mut config_updates = HashMap::new();\n        config_updates.insert(\"server.port\".to_string(), \"8080\".to_string());\n        config_updates.insert(\"processing.max_concurrent_tasks\".to_string(), \"8\".to_string());\n\n        let request = Request::new(UpdateConfigRequest {\n            configuration: config_updates,\n            restart_required: false,\n        });\n\n        let result = service.update_config(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_update_config_restart_required() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let mut config_updates = HashMap::new();\n        config_updates.insert(\"qdrant.url\".to_string(), \"http://new-host:6333\".to_string());\n\n        let request = Request::new(UpdateConfigRequest {\n            configuration: config_updates,\n            restart_required: true,\n        });\n\n        let result = service.update_config(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response, ());\n    }\n\n    #[tokio::test]\n    async fn test_detect_project() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(DetectProjectRequest {\n            path: \"/path/to/project\".to_string(),\n        });\n\n        let result = service.detect_project(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.project.is_some());\n        assert!(response.is_valid_project);\n        assert_eq!(response.reasons.len(), 1);\n        assert_eq!(response.reasons[0], \"Git repository detected\");\n\n        let project = response.project.unwrap();\n        assert!(!project.project_id.is_empty());\n        assert_eq!(project.name, \"example-project\");\n        assert_eq!(project.root_path, \"/path/to/project\");\n        assert_eq!(project.git_repository, \"https://github.com/example/project.git\");\n        assert_eq!(project.git_branch, \"main\");\n        assert!(project.submodules.is_empty());\n        assert!(project.metadata.contains_key(\"detected_at\"));\n        assert!(project.detected_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_detect_project_different_paths() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let test_paths = [\n            \"/home/user/project\",\n            \"/Users/developer/workspace/my-app\",\n            \"./relative/path\",\n            \"../parent/project\",\n            \"/very/deep/nested/project/structure\",\n        ];\n\n        for path in test_paths {\n            let request = Request::new(DetectProjectRequest {\n                path: path.to_string(),\n            });\n\n            let result = service.detect_project(request).await;\n            assert!(result.is_ok(), \"Failed for path: {}\", path);\n\n            let response = result.unwrap().into_inner();\n            assert!(response.project.is_some());\n            assert_eq!(response.project.unwrap().root_path, path);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_detect_project_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let before_detection = chrono::Utc::now().timestamp();\n        let request = Request::new(DetectProjectRequest {\n            path: \"/timestamp/test/project\".to_string(),\n        });\n\n        let result = service.detect_project(request).await;\n        let after_detection = chrono::Utc::now().timestamp();\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert!(response.project.is_some());\n\n        let project = response.project.unwrap();\n        assert!(project.detected_at.is_some());\n\n        let detected_timestamp = project.detected_at.unwrap().seconds;\n        assert!(detected_timestamp \u003e= before_detection \u0026\u0026 detected_timestamp \u003c= after_detection);\n    }\n\n    #[tokio::test]\n    async fn test_list_projects() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.list_projects(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.projects.len(), 1);\n\n        let project = \u0026response.projects[0];\n        assert!(!project.project_id.is_empty());\n        assert_eq!(project.name, \"workspace-qdrant-mcp\");\n        assert_eq!(project.root_path, \"/Users/example/workspace-qdrant-mcp\");\n        assert_eq!(project.git_repository, \"https://github.com/example/workspace-qdrant-mcp.git\");\n        assert_eq!(project.git_branch, \"main\");\n        assert!(project.submodules.is_empty());\n        assert!(project.metadata.contains_key(\"language\"));\n        assert_eq!(project.metadata.get(\"language\").unwrap(), \"rust,python\");\n        assert!(project.detected_at.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_list_projects_timestamps() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(());\n        let result = service.list_projects(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.projects.len(), 1);\n\n        let project = \u0026response.projects[0];\n        assert!(project.detected_at.is_some());\n\n        let detected_timestamp = project.detected_at.as_ref().unwrap().seconds;\n        let current_time = chrono::Utc::now().timestamp();\n\n        // Should be detected in the past (simulated as 1 day ago)\n        assert!(detected_timestamp \u003c current_time);\n        assert!(current_time - detected_timestamp \u003e= 86300); // Allow some margin for 1 day\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_system_operations() {\n        let daemon = create_test_daemon().await;\n        let service = Arc::new(SystemServiceImpl::new(daemon));\n\n        let mut handles = vec![];\n\n        // Perform multiple concurrent system operations\n        for i in 0..5 {\n            let service_clone = Arc::clone(\u0026service);\n            let handle = tokio::spawn(async move {\n                // Health check\n                let health_request = Request::new(());\n                let health_result = service_clone.health_check(health_request).await;\n\n                // Get status\n                let status_request = Request::new(());\n                let status_result = service_clone.get_status(status_request).await;\n\n                // Get config\n                let config_request = Request::new(());\n                let config_result = service_clone.get_config(config_request).await;\n\n                // Project detection\n                let detect_request = Request::new(DetectProjectRequest {\n                    path: format!(\"/test/project_{}\", i),\n                });\n                let detect_result = service_clone.detect_project(detect_request).await;\n\n                (health_result, status_result, config_result, detect_result)\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all operations to complete\n        let results: Vec\u003c_\u003e = futures_util::future::join_all(handles).await;\n\n        // All operations should complete successfully\n        for (i, result) in results.into_iter().enumerate() {\n            let (health_result, status_result, config_result, detect_result) = result.unwrap();\n            assert!(health_result.is_ok(), \"Health check {} failed\", i);\n            assert!(status_result.is_ok(), \"Status check {} failed\", i);\n            assert!(config_result.is_ok(), \"Config check {} failed\", i);\n            assert!(detect_result.is_ok(), \"Project detection {} failed\", i);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_project_unique_ids() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let mut project_ids = std::collections::HashSet::new();\n\n        // Detect multiple projects and verify unique IDs\n        for i in 0..5 {\n            let request = Request::new(DetectProjectRequest {\n                path: format!(\"/test/unique_project_{}\", i),\n            });\n\n            let result = service.detect_project(request).await;\n            assert!(result.is_ok());\n\n            let response = result.unwrap().into_inner();\n            assert!(response.project.is_some());\n\n            let project = response.project.unwrap();\n            assert!(project_ids.insert(project.project_id.clone()),\n                    \"Duplicate project ID generated: {}\", project.project_id);\n        }\n\n        assert_eq!(project_ids.len(), 5);\n    }\n\n    #[tokio::test]\n    async fn test_metrics_labels_structure() {\n        let daemon = create_test_daemon().await;\n        let service = SystemServiceImpl::new(daemon);\n\n        let request = Request::new(MetricsRequest {\n            since: None,\n            metric_names: vec![\"test_metric\".to_string()],\n        });\n\n        let result = service.get_metrics(request).await;\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_inner();\n        assert_eq!(response.metrics.len(), 2);\n\n        for metric in \u0026response.metrics {\n            assert!(!metric.name.is_empty());\n            assert!(!metric.r#type.is_empty());\n            assert!(!metric.labels.is_empty());\n            assert!(metric.value \u003e= 0.0);\n            assert!(metric.timestamp.is_some());\n        }\n    }\n\n    #[test]\n    fn test_system_service_impl_send_sync() {\n        fn assert_send\u003cT: Send\u003e() {}\n        fn assert_sync\u003cT: Sync\u003e() {}\n\n        assert_send::\u003cSystemServiceImpl\u003e();\n        assert_sync::\u003cSystemServiceImpl\u003e();\n    }\n}","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":21}}],"covered":1,"coverable":1},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","lib.rs"],"content":"//! Workspace Qdrant Daemon Library\n//!\n//! This library provides the core functionality for the workspace document processing\n//! and vector search daemon.\n\npub mod config;\npub mod error;\npub mod daemon;\npub mod grpc;\n\n// Include generated protobuf code\npub mod proto {\n    tonic::include_proto!(\"workspace_daemon\");\n}\n\n// Re-export commonly used types\npub use config::*;\npub use error::*;","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","src","main.rs"],"content":"//! Workspace Qdrant Daemon\n//!\n//! High-performance Rust daemon for workspace document processing and vector search.\n//! Provides gRPC services for document processing, search operations, memory management,\n//! and system administration.\n\nuse anyhow::Result;\nuse clap::Parser;\nuse std::net::SocketAddr;\nuse tracing::{info, warn};\n\nmod grpc;\nmod daemon;\nmod config;\nmod error;\n\n// Include generated protobuf code\npub mod proto {\n    tonic::include_proto!(\"workspace_daemon\");\n}\n\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    /// gRPC server address\n    #[arg(short, long, default_value = \"127.0.0.1:50051\")]\n    address: SocketAddr,\n\n    /// Configuration file path\n    #[arg(short, long)]\n    config: Option\u003cstd::path::PathBuf\u003e,\n\n    /// Log level\n    #[arg(short, long, default_value = \"info\")]\n    log_level: String,\n\n    /// Enable metrics collection\n    #[arg(long)]\n    enable_metrics: bool,\n\n    /// Daemon mode (run in background)\n    #[arg(short, long)]\n    daemon: bool,\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let args = Args::parse();\n\n    // Initialize tracing\n    init_tracing(\u0026args.log_level)?;\n\n    info!(\"Starting Workspace Qdrant Daemon v{}\", env!(\"CARGO_PKG_VERSION\"));\n    info!(\"gRPC server will listen on: {}\", args.address);\n\n    // Load configuration\n    let config = config::DaemonConfig::load(args.config.as_deref())?;\n    info!(\"Configuration loaded successfully\");\n\n    // Initialize daemon\n    let mut daemon = daemon::WorkspaceDaemon::new(config).await?;\n\n    // Start daemon services\n    daemon.start().await?;\n\n    // Start gRPC server\n    let grpc_server = grpc::server::GrpcServer::new(daemon, args.address);\n\n    if args.daemon {\n        info!(\"Running in daemon mode\");\n        grpc_server.serve_daemon().await?;\n    } else {\n        info!(\"Running in foreground mode\");\n        grpc_server.serve().await?;\n    }\n\n    Ok(())\n}\n\nfn init_tracing(level: \u0026str) -\u003e Result\u003c()\u003e {\n    use tracing_subscriber::{fmt, prelude::*, EnvFilter};\n\n    let filter = EnvFilter::try_from_default_env()\n        .or_else(|_| EnvFilter::try_new(level))\n        .map_err(|e| anyhow::anyhow!(\"Invalid log level: {}\", e))?;\n\n    tracing_subscriber::registry()\n        .with(fmt::layer().with_target(false))\n        .with(filter)\n        .init();\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::Parser;\n\n    #[test]\n    fn test_args_default_values() {\n        let args = Args::parse_from(\u0026[\"test\"]);\n\n        assert_eq!(args.address.to_string(), \"127.0.0.1:50051\");\n        assert_eq!(args.log_level, \"info\");\n        assert!(!args.enable_metrics);\n        assert!(!args.daemon);\n        assert!(args.config.is_none());\n    }\n\n    #[test]\n    fn test_args_custom_values() {\n        let args = Args::parse_from(\u0026[\n            \"test\",\n            \"-a\", \"0.0.0.0:8080\",\n            \"-l\", \"debug\",\n            \"--enable-metrics\",\n            \"--daemon\",\n            \"-c\", \"/path/to/config.yaml\"\n        ]);\n\n        assert_eq!(args.address.to_string(), \"0.0.0.0:8080\");\n        assert_eq!(args.log_level, \"debug\");\n        assert!(args.enable_metrics);\n        assert!(args.daemon);\n        assert_eq!(args.config.unwrap().to_string_lossy(), \"/path/to/config.yaml\");\n    }\n\n    #[test]\n    fn test_args_debug_format() {\n        let args = Args::parse_from(\u0026[\"test\"]);\n        let debug_str = format!(\"{:?}\", args);\n\n        assert!(debug_str.contains(\"Args\"));\n        assert!(debug_str.contains(\"127.0.0.1:50051\"));\n        assert!(debug_str.contains(\"info\"));\n    }\n\n    #[test]\n    fn test_init_tracing_valid_levels() {\n        // Test various valid log levels\n        let valid_levels = vec![\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n\n        for level in valid_levels {\n            // Note: We can't actually call init_tracing multiple times in tests\n            // because it would panic, so we just test the validation logic\n            let result = std::panic::catch_unwind(|| {\n                init_tracing(level)\n            });\n            // Should not panic for valid levels (though it may fail due to already initialized)\n            assert!(result.is_ok() || result.is_err()); // Either succeeds or fails gracefully\n        }\n    }\n\n    #[test]\n    fn test_init_tracing_invalid_level() {\n        let result = init_tracing(\"invalid_level\");\n        assert!(result.is_err());\n\n        let error_msg = result.unwrap_err().to_string();\n        assert!(error_msg.contains(\"Invalid log level\"));\n    }\n\n    #[test]\n    fn test_args_parser_help() {\n        // Test that the help text can be generated without panicking\n        let result = std::panic::catch_unwind(|| {\n            Args::parse_from(\u0026[\"test\", \"--help\"])\n        });\n        // Should panic with help message (this is expected behavior for --help)\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_args_with_ipv6_address() {\n        let args = Args::parse_from(\u0026[\n            \"test\",\n            \"-a\", \"[::1]:9090\"\n        ]);\n\n        assert_eq!(args.address.to_string(), \"[::1]:9090\");\n    }\n\n    #[test]\n    fn test_args_long_flags() {\n        let args = Args::parse_from(\u0026[\n            \"test\",\n            \"--address\", \"192.168.1.1:3000\",\n            \"--log-level\", \"debug\",\n            \"--enable-metrics\",\n            \"--daemon\",\n            \"--config\", \"/etc/daemon.yaml\"\n        ]);\n\n        assert_eq!(args.address.to_string(), \"192.168.1.1:3000\");\n        assert_eq!(args.log_level, \"debug\");\n        assert!(args.enable_metrics);\n        assert!(args.daemon);\n        assert_eq!(args.config.unwrap().to_string_lossy(), \"/etc/daemon.yaml\");\n    }\n\n    #[test]\n    fn test_args_mixed_flags() {\n        let args = Args::parse_from(\u0026[\n            \"test\",\n            \"-a\", \"0.0.0.0:8080\",\n            \"--log-level\", \"warn\",\n            \"--enable-metrics\"\n        ]);\n\n        assert_eq!(args.address.to_string(), \"0.0.0.0:8080\");\n        assert_eq!(args.log_level, \"warn\");\n        assert!(args.enable_metrics);\n        assert!(!args.daemon);\n    }\n\n    #[test]\n    fn test_args_version_flag() {\n        let result = std::panic::catch_unwind(|| {\n            Args::parse_from(\u0026[\"test\", \"--version\"])\n        });\n        // Should panic with version message (this is expected behavior for --version)\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_args_invalid_address() {\n        let result = std::panic::catch_unwind(|| {\n            Args::parse_from(\u0026[\"test\", \"-a\", \"invalid_address\"])\n        });\n        // Should panic due to invalid socket address format\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_args_invalid_port() {\n        let result = std::panic::catch_unwind(|| {\n            Args::parse_from(\u0026[\"test\", \"-a\", \"127.0.0.1:99999\"])\n        });\n        // Should panic due to invalid port number\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_args_empty_config_path() {\n        let args = Args::parse_from(\u0026[\n            \"test\",\n            \"--config\", \"\"\n        ]);\n\n        assert_eq!(args.config.unwrap().to_string_lossy(), \"\");\n    }\n\n    #[test]\n    fn test_args_relative_config_path() {\n        let args = Args::parse_from(\u0026[\n            \"test\",\n            \"--config\", \"./config.yaml\"\n        ]);\n\n        assert_eq!(args.config.unwrap().to_string_lossy(), \"./config.yaml\");\n    }\n\n    #[test]\n    fn test_args_all_log_levels() {\n        let log_levels = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n\n        for level in log_levels {\n            let args = Args::parse_from(\u0026[\n                \"test\",\n                \"--log-level\", level\n            ]);\n            assert_eq!(args.log_level, level);\n        }\n    }\n\n    #[test]\n    fn test_args_different_ports() {\n        let ports = [\"8080\", \"3000\", \"9090\", \"50051\"];\n\n        for port in ports {\n            let address = format!(\"127.0.0.1:{}\", port);\n            let args = Args::parse_from(\u0026[\n                \"test\",\n                \"-a\", \u0026address\n            ]);\n            assert_eq!(args.address.to_string(), address);\n        }\n    }\n\n    #[test]\n    fn test_args_different_hosts() {\n        let hosts = [\n            \"127.0.0.1:8080\",\n            \"0.0.0.0:8080\",\n            \"localhost:8080\",\n            \"[::]:8080\",\n            \"[::1]:8080\"\n        ];\n\n        for host in hosts {\n            let result = std::panic::catch_unwind(|| {\n                Args::parse_from(\u0026[\"test\", \"-a\", host])\n            });\n            // Some hosts may be valid, others may not be parseable\n            // We're just testing that the parser handles various formats\n            let _ = result;\n        }\n    }\n\n    #[test]\n    fn test_args_boolean_flags_combinations() {\n        // Test all combinations of boolean flags\n        let combinations = [\n            (false, false),\n            (true, false),\n            (false, true),\n            (true, true),\n        ];\n\n        for (enable_metrics, daemon) in combinations {\n            let mut cmd = vec![\"test\"];\n            if enable_metrics {\n                cmd.push(\"--enable-metrics\");\n            }\n            if daemon {\n                cmd.push(\"--daemon\");\n            }\n\n            let args = Args::parse_from(\u0026cmd);\n            assert_eq!(args.enable_metrics, enable_metrics);\n            assert_eq!(args.daemon, daemon);\n        }\n    }\n\n    #[test]\n    fn test_args_config_file_extensions() {\n        let extensions = [\n            \"config.yaml\",\n            \"config.yml\",\n            \"config.json\",\n            \"config.toml\",\n            \"config.conf\",\n            \"daemon.cfg\"\n        ];\n\n        for ext in extensions {\n            let args = Args::parse_from(\u0026[\n                \"test\",\n                \"--config\", ext\n            ]);\n            assert_eq!(args.config.unwrap().to_string_lossy(), ext);\n        }\n    }\n\n    #[test]\n    fn test_init_tracing_case_insensitive() {\n        let levels = [\"INFO\", \"Debug\", \"WARN\", \"error\", \"TRACE\"];\n\n        for level in levels {\n            let result = std::panic::catch_unwind(|| {\n                init_tracing(level)\n            });\n            // Should handle case variations gracefully\n            let _ = result;\n        }\n    }\n\n    #[test]\n    fn test_init_tracing_with_numbers() {\n        let result = init_tracing(\"info,hyper=warn,tonic=debug\");\n        // Complex log filter should work or fail gracefully\n        let _ = result;\n    }\n\n    #[test]\n    fn test_init_tracing_empty_string() {\n        let result = init_tracing(\"\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_init_tracing_with_whitespace() {\n        let result = init_tracing(\" info \");\n        // Should handle whitespace gracefully\n        let _ = result;\n    }\n\n    #[test]\n    fn test_proto_module_access() {\n        // Test that the proto module is properly included\n        // We can't test the actual protobuf types without the generated code,\n        // but we can ensure the module exists\n        let _proto_module = stringify!(proto);\n        assert_eq!(_proto_module, \"proto\");\n    }\n\n    #[test]\n    fn test_cargo_pkg_version_constant() {\n        // Test that the version constant is accessible\n        let version = env!(\"CARGO_PKG_VERSION\");\n        assert!(!version.is_empty());\n        assert!(version.contains('.'));\n    }\n\n    #[tokio::test]\n    async fn test_args_async_compatibility() {\n        // Test that Args can be used in async context\n        let args = Args::parse_from(\u0026[\"test\"]);\n\n        tokio::time::sleep(tokio::time::Duration::from_millis(1)).await;\n\n        assert_eq!(args.address.to_string(), \"127.0.0.1:50051\");\n    }\n\n    #[test]\n    fn test_multiple_args_parsing() {\n        // Test parsing multiple times doesn't interfere\n        let args1 = Args::parse_from(\u0026[\"test\", \"-a\", \"127.0.0.1:8080\"]);\n        let args2 = Args::parse_from(\u0026[\"test\", \"-a\", \"127.0.0.1:9090\"]);\n\n        assert_eq!(args1.address.to_string(), \"127.0.0.1:8080\");\n        assert_eq!(args2.address.to_string(), \"127.0.0.1:9090\");\n    }\n\n    #[test]\n    fn test_args_serialization_friendly() {\n        let args = Args::parse_from(\u0026[\"test\"]);\n\n        // Test that Args fields are accessible for serialization\n        let _address = \u0026args.address;\n        let _config = \u0026args.config;\n        let _log_level = \u0026args.log_level;\n        let _enable_metrics = args.enable_metrics;\n        let _daemon = args.daemon;\n\n        // All fields should be accessible\n        assert_eq!(args.log_level, \"info\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","target-cov","debug","build","crunchy-f65bc0d837723aac","out","lib.rs"],"content":"\n/// Unroll the given for loop\n///\n/// Example:\n///\n/// ```ignore\n/// unroll! {\n///   for i in 0..5 {\n///     println!(\"Iteration {}\", i);\n///   }\n/// }\n/// ```\n///\n/// will expand into:\n///\n/// ```ignore\n/// { println!(\"Iteration {}\", 0); }\n/// { println!(\"Iteration {}\", 1); }\n/// { println!(\"Iteration {}\", 2); }\n/// { println!(\"Iteration {}\", 3); }\n/// { println!(\"Iteration {}\", 4); }\n/// ```\n#[macro_export]\nmacro_rules! unroll {\n    (for $v:ident in 0..0 $c:block) =\u003e {};\n\n    (for $v:ident \u003c $max:tt in ($start:tt..$end:tt).step_by($val:expr) {$($c:tt)*}) =\u003e {\n        {\n            let step = $val;\n            let start = $start;\n            let end = start + ($end - start) / step;\n            unroll! {\n                for val \u003c $max in start..end {\n                    let $v: usize = ((val - start) * step) + start;\n\n                    $($c)*\n                }\n            }\n        }\n    };\n\n    (for $v:ident in ($start:tt..$end:tt).step_by($val:expr) {$($c:tt)*}) =\u003e {\n        unroll! {\n            for $v \u003c $end in ($start..$end).step_by($val) {$($c)*}\n        }\n    };\n\n    (for $v:ident in ($start:tt..$end:tt) {$($c:tt)*}) =\u003e {\n        unroll!{\n            for $v in $start..$end {$($c)*}\n        }\n    };\n\n    (for $v:ident in $start:tt..$end:tt {$($c:tt)*}) =\u003e {\n        #[allow(non_upper_case_globals)]\n        #[allow(unused_comparisons)]\n        {\n            unroll!(@$v, 0, $end, {\n                    if $v \u003e= $start {$($c)*}\n                }\n            );\n        }\n    };\n\n    (for $v:ident \u003c $max:tt in $start:tt..$end:tt $c:block) =\u003e {\n        #[allow(non_upper_case_globals)]\n        {\n            let range = $start..$end;\n            assert!(\n                $max \u003e= range.end,\n                \"`{}` out of range `{:?}`\",\n                stringify!($max),\n                range,\n            );\n            unroll!(\n                @$v,\n                0,\n                $max,\n                {\n                    if $v \u003e= range.start \u0026\u0026 $v \u003c range.end {\n                        $c\n                    }\n                }\n            );\n        }\n    };\n\n    (for $v:ident in 0..$end:tt {$($statement:tt)*}) =\u003e {\n        #[allow(non_upper_case_globals)]\n        { unroll!(@$v, 0, $end, {$($statement)*}); }\n    };\n\n    (@$v:ident, $a:expr, 0, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n    };\n\n    (@$v:ident, $a:expr, 1, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n    };\n\n    (@$v:ident, $a:expr, 2, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n    };\n\n    (@$v:ident, $a:expr, 3, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n    };\n\n    (@$v:ident, $a:expr, 4, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n    };\n\n    (@$v:ident, $a:expr, 5, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n    };\n\n    (@$v:ident, $a:expr, 6, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n    };\n\n    (@$v:ident, $a:expr, 7, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n    };\n\n    (@$v:ident, $a:expr, 8, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n    };\n\n    (@$v:ident, $a:expr, 9, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n    };\n\n    (@$v:ident, $a:expr, 10, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n    };\n\n    (@$v:ident, $a:expr, 11, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n    };\n\n    (@$v:ident, $a:expr, 12, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n    };\n\n    (@$v:ident, $a:expr, 13, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n    };\n\n    (@$v:ident, $a:expr, 14, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n        { const $v: usize = $a + 13; $c }\n    };\n\n    (@$v:ident, $a:expr, 15, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n        { const $v: usize = $a + 13; $c }\n        { const $v: usize = $a + 14; $c }\n    };\n\n    (@$v:ident, $a:expr, 16, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n        { const $v: usize = $a + 13; $c }\n        { const $v: usize = $a + 14; $c }\n        { const $v: usize = $a + 15; $c }\n    };\n\n    (@$v:ident, $a:expr, 17, $c:block) =\u003e {\n        unroll!(@$v, $a, 16, $c);\n        { const $v: usize = $a + 16; $c }\n    };\n\n    (@$v:ident, $a:expr, 18, $c:block) =\u003e {\n        unroll!(@$v, $a, 9, $c);\n        unroll!(@$v, $a + 9, 9, $c);\n    };\n\n    (@$v:ident, $a:expr, 19, $c:block) =\u003e {\n        unroll!(@$v, $a, 18, $c);\n        { const $v: usize = $a + 18; $c }\n    };\n\n    (@$v:ident, $a:expr, 20, $c:block) =\u003e {\n        unroll!(@$v, $a, 10, $c);\n        unroll!(@$v, $a + 10, 10, $c);\n    };\n\n    (@$v:ident, $a:expr, 21, $c:block) =\u003e {\n        unroll!(@$v, $a, 20, $c);\n        { const $v: usize = $a + 20; $c }\n    };\n\n    (@$v:ident, $a:expr, 22, $c:block) =\u003e {\n        unroll!(@$v, $a, 11, $c);\n        unroll!(@$v, $a + 11, 11, $c);\n    };\n\n    (@$v:ident, $a:expr, 23, $c:block) =\u003e {\n        unroll!(@$v, $a, 22, $c);\n        { const $v: usize = $a + 22; $c }\n    };\n\n    (@$v:ident, $a:expr, 24, $c:block) =\u003e {\n        unroll!(@$v, $a, 12, $c);\n        unroll!(@$v, $a + 12, 12, $c);\n    };\n\n    (@$v:ident, $a:expr, 25, $c:block) =\u003e {\n        unroll!(@$v, $a, 24, $c);\n        { const $v: usize = $a + 24; $c }\n    };\n\n    (@$v:ident, $a:expr, 26, $c:block) =\u003e {\n        unroll!(@$v, $a, 13, $c);\n        unroll!(@$v, $a + 13, 13, $c);\n    };\n\n    (@$v:ident, $a:expr, 27, $c:block) =\u003e {\n        unroll!(@$v, $a, 26, $c);\n        { const $v: usize = $a + 26; $c }\n    };\n\n    (@$v:ident, $a:expr, 28, $c:block) =\u003e {\n        unroll!(@$v, $a, 14, $c);\n        unroll!(@$v, $a + 14, 14, $c);\n    };\n\n    (@$v:ident, $a:expr, 29, $c:block) =\u003e {\n        unroll!(@$v, $a, 28, $c);\n        { const $v: usize = $a + 28; $c }\n    };\n\n    (@$v:ident, $a:expr, 30, $c:block) =\u003e {\n        unroll!(@$v, $a, 15, $c);\n        unroll!(@$v, $a + 15, 15, $c);\n    };\n\n    (@$v:ident, $a:expr, 31, $c:block) =\u003e {\n        unroll!(@$v, $a, 30, $c);\n        { const $v: usize = $a + 30; $c }\n    };\n\n    (@$v:ident, $a:expr, 32, $c:block) =\u003e {\n        unroll!(@$v, $a, 16, $c);\n        unroll!(@$v, $a + 16, 16, $c);\n    };\n\n    (@$v:ident, $a:expr, 33, $c:block) =\u003e {\n        unroll!(@$v, $a, 32, $c);\n        { const $v: usize = $a + 32; $c }\n    };\n\n    (@$v:ident, $a:expr, 34, $c:block) =\u003e {\n        unroll!(@$v, $a, 17, $c);\n        unroll!(@$v, $a + 17, 17, $c);\n    };\n\n    (@$v:ident, $a:expr, 35, $c:block) =\u003e {\n        unroll!(@$v, $a, 34, $c);\n        { const $v: usize = $a + 34; $c }\n    };\n\n    (@$v:ident, $a:expr, 36, $c:block) =\u003e {\n        unroll!(@$v, $a, 18, $c);\n        unroll!(@$v, $a + 18, 18, $c);\n    };\n\n    (@$v:ident, $a:expr, 37, $c:block) =\u003e {\n        unroll!(@$v, $a, 36, $c);\n        { const $v: usize = $a + 36; $c }\n    };\n\n    (@$v:ident, $a:expr, 38, $c:block) =\u003e {\n        unroll!(@$v, $a, 19, $c);\n        unroll!(@$v, $a + 19, 19, $c);\n    };\n\n    (@$v:ident, $a:expr, 39, $c:block) =\u003e {\n        unroll!(@$v, $a, 38, $c);\n        { const $v: usize = $a + 38; $c }\n    };\n\n    (@$v:ident, $a:expr, 40, $c:block) =\u003e {\n        unroll!(@$v, $a, 20, $c);\n        unroll!(@$v, $a + 20, 20, $c);\n    };\n\n    (@$v:ident, $a:expr, 41, $c:block) =\u003e {\n        unroll!(@$v, $a, 40, $c);\n        { const $v: usize = $a + 40; $c }\n    };\n\n    (@$v:ident, $a:expr, 42, $c:block) =\u003e {\n        unroll!(@$v, $a, 21, $c);\n        unroll!(@$v, $a + 21, 21, $c);\n    };\n\n    (@$v:ident, $a:expr, 43, $c:block) =\u003e {\n        unroll!(@$v, $a, 42, $c);\n        { const $v: usize = $a + 42; $c }\n    };\n\n    (@$v:ident, $a:expr, 44, $c:block) =\u003e {\n        unroll!(@$v, $a, 22, $c);\n        unroll!(@$v, $a + 22, 22, $c);\n    };\n\n    (@$v:ident, $a:expr, 45, $c:block) =\u003e {\n        unroll!(@$v, $a, 44, $c);\n        { const $v: usize = $a + 44; $c }\n    };\n\n    (@$v:ident, $a:expr, 46, $c:block) =\u003e {\n        unroll!(@$v, $a, 23, $c);\n        unroll!(@$v, $a + 23, 23, $c);\n    };\n\n    (@$v:ident, $a:expr, 47, $c:block) =\u003e {\n        unroll!(@$v, $a, 46, $c);\n        { const $v: usize = $a + 46; $c }\n    };\n\n    (@$v:ident, $a:expr, 48, $c:block) =\u003e {\n        unroll!(@$v, $a, 24, $c);\n        unroll!(@$v, $a + 24, 24, $c);\n    };\n\n    (@$v:ident, $a:expr, 49, $c:block) =\u003e {\n        unroll!(@$v, $a, 48, $c);\n        { const $v: usize = $a + 48; $c }\n    };\n\n    (@$v:ident, $a:expr, 50, $c:block) =\u003e {\n        unroll!(@$v, $a, 25, $c);\n        unroll!(@$v, $a + 25, 25, $c);\n    };\n\n    (@$v:ident, $a:expr, 51, $c:block) =\u003e {\n        unroll!(@$v, $a, 50, $c);\n        { const $v: usize = $a + 50; $c }\n    };\n\n    (@$v:ident, $a:expr, 52, $c:block) =\u003e {\n        unroll!(@$v, $a, 26, $c);\n        unroll!(@$v, $a + 26, 26, $c);\n    };\n\n    (@$v:ident, $a:expr, 53, $c:block) =\u003e {\n        unroll!(@$v, $a, 52, $c);\n        { const $v: usize = $a + 52; $c }\n    };\n\n    (@$v:ident, $a:expr, 54, $c:block) =\u003e {\n        unroll!(@$v, $a, 27, $c);\n        unroll!(@$v, $a + 27, 27, $c);\n    };\n\n    (@$v:ident, $a:expr, 55, $c:block) =\u003e {\n        unroll!(@$v, $a, 54, $c);\n        { const $v: usize = $a + 54; $c }\n    };\n\n    (@$v:ident, $a:expr, 56, $c:block) =\u003e {\n        unroll!(@$v, $a, 28, $c);\n        unroll!(@$v, $a + 28, 28, $c);\n    };\n\n    (@$v:ident, $a:expr, 57, $c:block) =\u003e {\n        unroll!(@$v, $a, 56, $c);\n        { const $v: usize = $a + 56; $c }\n    };\n\n    (@$v:ident, $a:expr, 58, $c:block) =\u003e {\n        unroll!(@$v, $a, 29, $c);\n        unroll!(@$v, $a + 29, 29, $c);\n    };\n\n    (@$v:ident, $a:expr, 59, $c:block) =\u003e {\n        unroll!(@$v, $a, 58, $c);\n        { const $v: usize = $a + 58; $c }\n    };\n\n    (@$v:ident, $a:expr, 60, $c:block) =\u003e {\n        unroll!(@$v, $a, 30, $c);\n        unroll!(@$v, $a + 30, 30, $c);\n    };\n\n    (@$v:ident, $a:expr, 61, $c:block) =\u003e {\n        unroll!(@$v, $a, 60, $c);\n        { const $v: usize = $a + 60; $c }\n    };\n\n    (@$v:ident, $a:expr, 62, $c:block) =\u003e {\n        unroll!(@$v, $a, 31, $c);\n        unroll!(@$v, $a + 31, 31, $c);\n    };\n\n    (@$v:ident, $a:expr, 63, $c:block) =\u003e {\n        unroll!(@$v, $a, 62, $c);\n        { const $v: usize = $a + 62; $c }\n    };\n\n    (@$v:ident, $a:expr, 64, $c:block) =\u003e {\n        unroll!(@$v, $a, 32, $c);\n        unroll!(@$v, $a + 32, 32, $c);\n    };\n\n    (@$v:ident, $a:expr, 65, $c:block) =\u003e {\n        unroll!(@$v, $a, 64, $c);\n        { const $v: usize = $a + 64; $c }\n    };\n\n    (@$v:ident, $a:expr, 66, $c:block) =\u003e {\n        unroll!(@$v, $a, 33, $c);\n        unroll!(@$v, $a + 33, 33, $c);\n    };\n\n    (@$v:ident, $a:expr, 67, $c:block) =\u003e {\n        unroll!(@$v, $a, 66, $c);\n        { const $v: usize = $a + 66; $c }\n    };\n\n    (@$v:ident, $a:expr, 68, $c:block) =\u003e {\n        unroll!(@$v, $a, 34, $c);\n        unroll!(@$v, $a + 34, 34, $c);\n    };\n\n    (@$v:ident, $a:expr, 69, $c:block) =\u003e {\n        unroll!(@$v, $a, 68, $c);\n        { const $v: usize = $a + 68; $c }\n    };\n\n    (@$v:ident, $a:expr, 70, $c:block) =\u003e {\n        unroll!(@$v, $a, 35, $c);\n        unroll!(@$v, $a + 35, 35, $c);\n    };\n\n    (@$v:ident, $a:expr, 71, $c:block) =\u003e {\n        unroll!(@$v, $a, 70, $c);\n        { const $v: usize = $a + 70; $c }\n    };\n\n    (@$v:ident, $a:expr, 72, $c:block) =\u003e {\n        unroll!(@$v, $a, 36, $c);\n        unroll!(@$v, $a + 36, 36, $c);\n    };\n\n    (@$v:ident, $a:expr, 73, $c:block) =\u003e {\n        unroll!(@$v, $a, 72, $c);\n        { const $v: usize = $a + 72; $c }\n    };\n\n    (@$v:ident, $a:expr, 74, $c:block) =\u003e {\n        unroll!(@$v, $a, 37, $c);\n        unroll!(@$v, $a + 37, 37, $c);\n    };\n\n    (@$v:ident, $a:expr, 75, $c:block) =\u003e {\n        unroll!(@$v, $a, 74, $c);\n        { const $v: usize = $a + 74; $c }\n    };\n\n    (@$v:ident, $a:expr, 76, $c:block) =\u003e {\n        unroll!(@$v, $a, 38, $c);\n        unroll!(@$v, $a + 38, 38, $c);\n    };\n\n    (@$v:ident, $a:expr, 77, $c:block) =\u003e {\n        unroll!(@$v, $a, 76, $c);\n        { const $v: usize = $a + 76; $c }\n    };\n\n    (@$v:ident, $a:expr, 78, $c:block) =\u003e {\n        unroll!(@$v, $a, 39, $c);\n        unroll!(@$v, $a + 39, 39, $c);\n    };\n\n    (@$v:ident, $a:expr, 79, $c:block) =\u003e {\n        unroll!(@$v, $a, 78, $c);\n        { const $v: usize = $a + 78; $c }\n    };\n\n    (@$v:ident, $a:expr, 80, $c:block) =\u003e {\n        unroll!(@$v, $a, 40, $c);\n        unroll!(@$v, $a + 40, 40, $c);\n    };\n\n    (@$v:ident, $a:expr, 81, $c:block) =\u003e {\n        unroll!(@$v, $a, 80, $c);\n        { const $v: usize = $a + 80; $c }\n    };\n\n    (@$v:ident, $a:expr, 82, $c:block) =\u003e {\n        unroll!(@$v, $a, 41, $c);\n        unroll!(@$v, $a + 41, 41, $c);\n    };\n\n    (@$v:ident, $a:expr, 83, $c:block) =\u003e {\n        unroll!(@$v, $a, 82, $c);\n        { const $v: usize = $a + 82; $c }\n    };\n\n    (@$v:ident, $a:expr, 84, $c:block) =\u003e {\n        unroll!(@$v, $a, 42, $c);\n        unroll!(@$v, $a + 42, 42, $c);\n    };\n\n    (@$v:ident, $a:expr, 85, $c:block) =\u003e {\n        unroll!(@$v, $a, 84, $c);\n        { const $v: usize = $a + 84; $c }\n    };\n\n    (@$v:ident, $a:expr, 86, $c:block) =\u003e {\n        unroll!(@$v, $a, 43, $c);\n        unroll!(@$v, $a + 43, 43, $c);\n    };\n\n    (@$v:ident, $a:expr, 87, $c:block) =\u003e {\n        unroll!(@$v, $a, 86, $c);\n        { const $v: usize = $a + 86; $c }\n    };\n\n    (@$v:ident, $a:expr, 88, $c:block) =\u003e {\n        unroll!(@$v, $a, 44, $c);\n        unroll!(@$v, $a + 44, 44, $c);\n    };\n\n    (@$v:ident, $a:expr, 89, $c:block) =\u003e {\n        unroll!(@$v, $a, 88, $c);\n        { const $v: usize = $a + 88; $c }\n    };\n\n    (@$v:ident, $a:expr, 90, $c:block) =\u003e {\n        unroll!(@$v, $a, 45, $c);\n        unroll!(@$v, $a + 45, 45, $c);\n    };\n\n    (@$v:ident, $a:expr, 91, $c:block) =\u003e {\n        unroll!(@$v, $a, 90, $c);\n        { const $v: usize = $a + 90; $c }\n    };\n\n    (@$v:ident, $a:expr, 92, $c:block) =\u003e {\n        unroll!(@$v, $a, 46, $c);\n        unroll!(@$v, $a + 46, 46, $c);\n    };\n\n    (@$v:ident, $a:expr, 93, $c:block) =\u003e {\n        unroll!(@$v, $a, 92, $c);\n        { const $v: usize = $a + 92; $c }\n    };\n\n    (@$v:ident, $a:expr, 94, $c:block) =\u003e {\n        unroll!(@$v, $a, 47, $c);\n        unroll!(@$v, $a + 47, 47, $c);\n    };\n\n    (@$v:ident, $a:expr, 95, $c:block) =\u003e {\n        unroll!(@$v, $a, 94, $c);\n        { const $v: usize = $a + 94; $c }\n    };\n\n    (@$v:ident, $a:expr, 96, $c:block) =\u003e {\n        unroll!(@$v, $a, 48, $c);\n        unroll!(@$v, $a + 48, 48, $c);\n    };\n\n    (@$v:ident, $a:expr, 97, $c:block) =\u003e {\n        unroll!(@$v, $a, 96, $c);\n        { const $v: usize = $a + 96; $c }\n    };\n\n    (@$v:ident, $a:expr, 98, $c:block) =\u003e {\n        unroll!(@$v, $a, 49, $c);\n        unroll!(@$v, $a + 49, 49, $c);\n    };\n\n    (@$v:ident, $a:expr, 99, $c:block) =\u003e {\n        unroll!(@$v, $a, 98, $c);\n        { const $v: usize = $a + 98; $c }\n    };\n\n    (@$v:ident, $a:expr, 100, $c:block) =\u003e {\n        unroll!(@$v, $a, 50, $c);\n        unroll!(@$v, $a + 50, 50, $c);\n    };\n\n    (@$v:ident, $a:expr, 101, $c:block) =\u003e {\n        unroll!(@$v, $a, 100, $c);\n        { const $v: usize = $a + 100; $c }\n    };\n\n    (@$v:ident, $a:expr, 102, $c:block) =\u003e {\n        unroll!(@$v, $a, 51, $c);\n        unroll!(@$v, $a + 51, 51, $c);\n    };\n\n    (@$v:ident, $a:expr, 103, $c:block) =\u003e {\n        unroll!(@$v, $a, 102, $c);\n        { const $v: usize = $a + 102; $c }\n    };\n\n    (@$v:ident, $a:expr, 104, $c:block) =\u003e {\n        unroll!(@$v, $a, 52, $c);\n        unroll!(@$v, $a + 52, 52, $c);\n    };\n\n    (@$v:ident, $a:expr, 105, $c:block) =\u003e {\n        unroll!(@$v, $a, 104, $c);\n        { const $v: usize = $a + 104; $c }\n    };\n\n    (@$v:ident, $a:expr, 106, $c:block) =\u003e {\n        unroll!(@$v, $a, 53, $c);\n        unroll!(@$v, $a + 53, 53, $c);\n    };\n\n    (@$v:ident, $a:expr, 107, $c:block) =\u003e {\n        unroll!(@$v, $a, 106, $c);\n        { const $v: usize = $a + 106; $c }\n    };\n\n    (@$v:ident, $a:expr, 108, $c:block) =\u003e {\n        unroll!(@$v, $a, 54, $c);\n        unroll!(@$v, $a + 54, 54, $c);\n    };\n\n    (@$v:ident, $a:expr, 109, $c:block) =\u003e {\n        unroll!(@$v, $a, 108, $c);\n        { const $v: usize = $a + 108; $c }\n    };\n\n    (@$v:ident, $a:expr, 110, $c:block) =\u003e {\n        unroll!(@$v, $a, 55, $c);\n        unroll!(@$v, $a + 55, 55, $c);\n    };\n\n    (@$v:ident, $a:expr, 111, $c:block) =\u003e {\n        unroll!(@$v, $a, 110, $c);\n        { const $v: usize = $a + 110; $c }\n    };\n\n    (@$v:ident, $a:expr, 112, $c:block) =\u003e {\n        unroll!(@$v, $a, 56, $c);\n        unroll!(@$v, $a + 56, 56, $c);\n    };\n\n    (@$v:ident, $a:expr, 113, $c:block) =\u003e {\n        unroll!(@$v, $a, 112, $c);\n        { const $v: usize = $a + 112; $c }\n    };\n\n    (@$v:ident, $a:expr, 114, $c:block) =\u003e {\n        unroll!(@$v, $a, 57, $c);\n        unroll!(@$v, $a + 57, 57, $c);\n    };\n\n    (@$v:ident, $a:expr, 115, $c:block) =\u003e {\n        unroll!(@$v, $a, 114, $c);\n        { const $v: usize = $a + 114; $c }\n    };\n\n    (@$v:ident, $a:expr, 116, $c:block) =\u003e {\n        unroll!(@$v, $a, 58, $c);\n        unroll!(@$v, $a + 58, 58, $c);\n    };\n\n    (@$v:ident, $a:expr, 117, $c:block) =\u003e {\n        unroll!(@$v, $a, 116, $c);\n        { const $v: usize = $a + 116; $c }\n    };\n\n    (@$v:ident, $a:expr, 118, $c:block) =\u003e {\n        unroll!(@$v, $a, 59, $c);\n        unroll!(@$v, $a + 59, 59, $c);\n    };\n\n    (@$v:ident, $a:expr, 119, $c:block) =\u003e {\n        unroll!(@$v, $a, 118, $c);\n        { const $v: usize = $a + 118; $c }\n    };\n\n    (@$v:ident, $a:expr, 120, $c:block) =\u003e {\n        unroll!(@$v, $a, 60, $c);\n        unroll!(@$v, $a + 60, 60, $c);\n    };\n\n    (@$v:ident, $a:expr, 121, $c:block) =\u003e {\n        unroll!(@$v, $a, 120, $c);\n        { const $v: usize = $a + 120; $c }\n    };\n\n    (@$v:ident, $a:expr, 122, $c:block) =\u003e {\n        unroll!(@$v, $a, 61, $c);\n        unroll!(@$v, $a + 61, 61, $c);\n    };\n\n    (@$v:ident, $a:expr, 123, $c:block) =\u003e {\n        unroll!(@$v, $a, 122, $c);\n        { const $v: usize = $a + 122; $c }\n    };\n\n    (@$v:ident, $a:expr, 124, $c:block) =\u003e {\n        unroll!(@$v, $a, 62, $c);\n        unroll!(@$v, $a + 62, 62, $c);\n    };\n\n    (@$v:ident, $a:expr, 125, $c:block) =\u003e {\n        unroll!(@$v, $a, 124, $c);\n        { const $v: usize = $a + 124; $c }\n    };\n\n    (@$v:ident, $a:expr, 126, $c:block) =\u003e {\n        unroll!(@$v, $a, 63, $c);\n        unroll!(@$v, $a + 63, 63, $c);\n    };\n\n    (@$v:ident, $a:expr, 127, $c:block) =\u003e {\n        unroll!(@$v, $a, 126, $c);\n        { const $v: usize = $a + 126; $c }\n    };\n\n    (@$v:ident, $a:expr, 128, $c:block) =\u003e {\n        unroll!(@$v, $a, 64, $c);\n        unroll!(@$v, $a + 64, 64, $c);\n    };\n\n}\n\n\n#[cfg(all(test, feature = \"std\"))]\nmod tests {\n    #[test]\n    fn invalid_range() {\n        let mut a: Vec\u003cusize\u003e = vec![];\n        unroll! {\n                for i in (5..4) {\n                    a.push(i);\n                }\n            }\n        assert_eq!(a, vec![]);\n    }\n\n    #[test]\n    fn start_at_one_with_step() {\n        let mut a: Vec\u003cusize\u003e = vec![];\n        unroll! {\n                for i in (2..4).step_by(1) {\n                    a.push(i);\n                }\n            }\n        assert_eq!(a, vec![2, 3]);\n    }\n\n    #[test]\n    fn start_at_one() {\n        let mut a: Vec\u003cusize\u003e = vec![];\n        unroll! {\n                for i in 1..4 {\n                    a.push(i);\n                }\n            }\n        assert_eq!(a, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_all() {\n        {\n            let a: Vec\u003cusize\u003e = vec![];\n            unroll! {\n                for i in 0..0 {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..0).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n        {\n            let mut a: Vec\u003cusize\u003e = vec![];\n            unroll! {\n                for i in 0..1 {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..1).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n        {\n            let mut a: Vec\u003cusize\u003e = vec![];\n            unroll! {\n                for i in 0..128 {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..128).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n        {\n            let mut a: Vec\u003cusize\u003e = vec![];\n            let start = 128 / 4;\n            let end = start * 3;\n            unroll! {\n                for i \u003c 128 in start..end {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (start..end).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n        {\n            let mut a: Vec\u003cusize\u003e = vec![];\n            unroll! {\n                for i in (0..128).step_by(2) {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..128 / 2).map(|x| x * 2).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n        {\n            let mut a: Vec\u003cusize\u003e = vec![];\n            let start = 128 / 4;\n            let end = start * 3;\n            unroll! {\n                for i \u003c 128 in (start..end).step_by(2) {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (start..end).filter(|x| x % 2 == 0).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","target-cov","debug","build","libsqlite3-sys-eb8239674874f9fc","out","bindgen.rs"],"content":"/* automatically generated by rust-bindgen 0.69.4 */\n\nextern \"C\" {\n    pub fn sqlite3_auto_extension(\n        xEntryPoint: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                db: *mut sqlite3,\n                pzErrMsg: *mut *mut ::std::os::raw::c_char,\n                _: *const sqlite3_api_routines,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_cancel_auto_extension(\n        xEntryPoint: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                db: *mut sqlite3,\n                pzErrMsg: *mut *mut ::std::os::raw::c_char,\n                _: *const sqlite3_api_routines,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\n\npub const SQLITE_VERSION: \u0026[u8; 7] = b\"3.46.0\\0\";\npub const SQLITE_VERSION_NUMBER: i32 = 3046000;\npub const SQLITE_SOURCE_ID: \u0026[u8; 85] =\n    b\"2024-05-23 13:25:27 96c92aba00c8375bc32fafcdf12429c58bd8aabfcadab6683e35bbb9cdebf19e\\0\";\npub const SQLITE_OK: i32 = 0;\npub const SQLITE_ERROR: i32 = 1;\npub const SQLITE_INTERNAL: i32 = 2;\npub const SQLITE_PERM: i32 = 3;\npub const SQLITE_ABORT: i32 = 4;\npub const SQLITE_BUSY: i32 = 5;\npub const SQLITE_LOCKED: i32 = 6;\npub const SQLITE_NOMEM: i32 = 7;\npub const SQLITE_READONLY: i32 = 8;\npub const SQLITE_INTERRUPT: i32 = 9;\npub const SQLITE_IOERR: i32 = 10;\npub const SQLITE_CORRUPT: i32 = 11;\npub const SQLITE_NOTFOUND: i32 = 12;\npub const SQLITE_FULL: i32 = 13;\npub const SQLITE_CANTOPEN: i32 = 14;\npub const SQLITE_PROTOCOL: i32 = 15;\npub const SQLITE_EMPTY: i32 = 16;\npub const SQLITE_SCHEMA: i32 = 17;\npub const SQLITE_TOOBIG: i32 = 18;\npub const SQLITE_CONSTRAINT: i32 = 19;\npub const SQLITE_MISMATCH: i32 = 20;\npub const SQLITE_MISUSE: i32 = 21;\npub const SQLITE_NOLFS: i32 = 22;\npub const SQLITE_AUTH: i32 = 23;\npub const SQLITE_FORMAT: i32 = 24;\npub const SQLITE_RANGE: i32 = 25;\npub const SQLITE_NOTADB: i32 = 26;\npub const SQLITE_NOTICE: i32 = 27;\npub const SQLITE_WARNING: i32 = 28;\npub const SQLITE_ROW: i32 = 100;\npub const SQLITE_DONE: i32 = 101;\npub const SQLITE_ERROR_MISSING_COLLSEQ: i32 = 257;\npub const SQLITE_ERROR_RETRY: i32 = 513;\npub const SQLITE_ERROR_SNAPSHOT: i32 = 769;\npub const SQLITE_IOERR_READ: i32 = 266;\npub const SQLITE_IOERR_SHORT_READ: i32 = 522;\npub const SQLITE_IOERR_WRITE: i32 = 778;\npub const SQLITE_IOERR_FSYNC: i32 = 1034;\npub const SQLITE_IOERR_DIR_FSYNC: i32 = 1290;\npub const SQLITE_IOERR_TRUNCATE: i32 = 1546;\npub const SQLITE_IOERR_FSTAT: i32 = 1802;\npub const SQLITE_IOERR_UNLOCK: i32 = 2058;\npub const SQLITE_IOERR_RDLOCK: i32 = 2314;\npub const SQLITE_IOERR_DELETE: i32 = 2570;\npub const SQLITE_IOERR_BLOCKED: i32 = 2826;\npub const SQLITE_IOERR_NOMEM: i32 = 3082;\npub const SQLITE_IOERR_ACCESS: i32 = 3338;\npub const SQLITE_IOERR_CHECKRESERVEDLOCK: i32 = 3594;\npub const SQLITE_IOERR_LOCK: i32 = 3850;\npub const SQLITE_IOERR_CLOSE: i32 = 4106;\npub const SQLITE_IOERR_DIR_CLOSE: i32 = 4362;\npub const SQLITE_IOERR_SHMOPEN: i32 = 4618;\npub const SQLITE_IOERR_SHMSIZE: i32 = 4874;\npub const SQLITE_IOERR_SHMLOCK: i32 = 5130;\npub const SQLITE_IOERR_SHMMAP: i32 = 5386;\npub const SQLITE_IOERR_SEEK: i32 = 5642;\npub const SQLITE_IOERR_DELETE_NOENT: i32 = 5898;\npub const SQLITE_IOERR_MMAP: i32 = 6154;\npub const SQLITE_IOERR_GETTEMPPATH: i32 = 6410;\npub const SQLITE_IOERR_CONVPATH: i32 = 6666;\npub const SQLITE_IOERR_VNODE: i32 = 6922;\npub const SQLITE_IOERR_AUTH: i32 = 7178;\npub const SQLITE_IOERR_BEGIN_ATOMIC: i32 = 7434;\npub const SQLITE_IOERR_COMMIT_ATOMIC: i32 = 7690;\npub const SQLITE_IOERR_ROLLBACK_ATOMIC: i32 = 7946;\npub const SQLITE_IOERR_DATA: i32 = 8202;\npub const SQLITE_IOERR_CORRUPTFS: i32 = 8458;\npub const SQLITE_IOERR_IN_PAGE: i32 = 8714;\npub const SQLITE_LOCKED_SHAREDCACHE: i32 = 262;\npub const SQLITE_LOCKED_VTAB: i32 = 518;\npub const SQLITE_BUSY_RECOVERY: i32 = 261;\npub const SQLITE_BUSY_SNAPSHOT: i32 = 517;\npub const SQLITE_BUSY_TIMEOUT: i32 = 773;\npub const SQLITE_CANTOPEN_NOTEMPDIR: i32 = 270;\npub const SQLITE_CANTOPEN_ISDIR: i32 = 526;\npub const SQLITE_CANTOPEN_FULLPATH: i32 = 782;\npub const SQLITE_CANTOPEN_CONVPATH: i32 = 1038;\npub const SQLITE_CANTOPEN_DIRTYWAL: i32 = 1294;\npub const SQLITE_CANTOPEN_SYMLINK: i32 = 1550;\npub const SQLITE_CORRUPT_VTAB: i32 = 267;\npub const SQLITE_CORRUPT_SEQUENCE: i32 = 523;\npub const SQLITE_CORRUPT_INDEX: i32 = 779;\npub const SQLITE_READONLY_RECOVERY: i32 = 264;\npub const SQLITE_READONLY_CANTLOCK: i32 = 520;\npub const SQLITE_READONLY_ROLLBACK: i32 = 776;\npub const SQLITE_READONLY_DBMOVED: i32 = 1032;\npub const SQLITE_READONLY_CANTINIT: i32 = 1288;\npub const SQLITE_READONLY_DIRECTORY: i32 = 1544;\npub const SQLITE_ABORT_ROLLBACK: i32 = 516;\npub const SQLITE_CONSTRAINT_CHECK: i32 = 275;\npub const SQLITE_CONSTRAINT_COMMITHOOK: i32 = 531;\npub const SQLITE_CONSTRAINT_FOREIGNKEY: i32 = 787;\npub const SQLITE_CONSTRAINT_FUNCTION: i32 = 1043;\npub const SQLITE_CONSTRAINT_NOTNULL: i32 = 1299;\npub const SQLITE_CONSTRAINT_PRIMARYKEY: i32 = 1555;\npub const SQLITE_CONSTRAINT_TRIGGER: i32 = 1811;\npub const SQLITE_CONSTRAINT_UNIQUE: i32 = 2067;\npub const SQLITE_CONSTRAINT_VTAB: i32 = 2323;\npub const SQLITE_CONSTRAINT_ROWID: i32 = 2579;\npub const SQLITE_CONSTRAINT_PINNED: i32 = 2835;\npub const SQLITE_CONSTRAINT_DATATYPE: i32 = 3091;\npub const SQLITE_NOTICE_RECOVER_WAL: i32 = 283;\npub const SQLITE_NOTICE_RECOVER_ROLLBACK: i32 = 539;\npub const SQLITE_NOTICE_RBU: i32 = 795;\npub const SQLITE_WARNING_AUTOINDEX: i32 = 284;\npub const SQLITE_AUTH_USER: i32 = 279;\npub const SQLITE_OK_LOAD_PERMANENTLY: i32 = 256;\npub const SQLITE_OK_SYMLINK: i32 = 512;\npub const SQLITE_OPEN_READONLY: i32 = 1;\npub const SQLITE_OPEN_READWRITE: i32 = 2;\npub const SQLITE_OPEN_CREATE: i32 = 4;\npub const SQLITE_OPEN_DELETEONCLOSE: i32 = 8;\npub const SQLITE_OPEN_EXCLUSIVE: i32 = 16;\npub const SQLITE_OPEN_AUTOPROXY: i32 = 32;\npub const SQLITE_OPEN_URI: i32 = 64;\npub const SQLITE_OPEN_MEMORY: i32 = 128;\npub const SQLITE_OPEN_MAIN_DB: i32 = 256;\npub const SQLITE_OPEN_TEMP_DB: i32 = 512;\npub const SQLITE_OPEN_TRANSIENT_DB: i32 = 1024;\npub const SQLITE_OPEN_MAIN_JOURNAL: i32 = 2048;\npub const SQLITE_OPEN_TEMP_JOURNAL: i32 = 4096;\npub const SQLITE_OPEN_SUBJOURNAL: i32 = 8192;\npub const SQLITE_OPEN_SUPER_JOURNAL: i32 = 16384;\npub const SQLITE_OPEN_NOMUTEX: i32 = 32768;\npub const SQLITE_OPEN_FULLMUTEX: i32 = 65536;\npub const SQLITE_OPEN_SHAREDCACHE: i32 = 131072;\npub const SQLITE_OPEN_PRIVATECACHE: i32 = 262144;\npub const SQLITE_OPEN_WAL: i32 = 524288;\npub const SQLITE_OPEN_NOFOLLOW: i32 = 16777216;\npub const SQLITE_OPEN_EXRESCODE: i32 = 33554432;\npub const SQLITE_OPEN_MASTER_JOURNAL: i32 = 16384;\npub const SQLITE_IOCAP_ATOMIC: i32 = 1;\npub const SQLITE_IOCAP_ATOMIC512: i32 = 2;\npub const SQLITE_IOCAP_ATOMIC1K: i32 = 4;\npub const SQLITE_IOCAP_ATOMIC2K: i32 = 8;\npub const SQLITE_IOCAP_ATOMIC4K: i32 = 16;\npub const SQLITE_IOCAP_ATOMIC8K: i32 = 32;\npub const SQLITE_IOCAP_ATOMIC16K: i32 = 64;\npub const SQLITE_IOCAP_ATOMIC32K: i32 = 128;\npub const SQLITE_IOCAP_ATOMIC64K: i32 = 256;\npub const SQLITE_IOCAP_SAFE_APPEND: i32 = 512;\npub const SQLITE_IOCAP_SEQUENTIAL: i32 = 1024;\npub const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN: i32 = 2048;\npub const SQLITE_IOCAP_POWERSAFE_OVERWRITE: i32 = 4096;\npub const SQLITE_IOCAP_IMMUTABLE: i32 = 8192;\npub const SQLITE_IOCAP_BATCH_ATOMIC: i32 = 16384;\npub const SQLITE_LOCK_NONE: i32 = 0;\npub const SQLITE_LOCK_SHARED: i32 = 1;\npub const SQLITE_LOCK_RESERVED: i32 = 2;\npub const SQLITE_LOCK_PENDING: i32 = 3;\npub const SQLITE_LOCK_EXCLUSIVE: i32 = 4;\npub const SQLITE_SYNC_NORMAL: i32 = 2;\npub const SQLITE_SYNC_FULL: i32 = 3;\npub const SQLITE_SYNC_DATAONLY: i32 = 16;\npub const SQLITE_FCNTL_LOCKSTATE: i32 = 1;\npub const SQLITE_FCNTL_GET_LOCKPROXYFILE: i32 = 2;\npub const SQLITE_FCNTL_SET_LOCKPROXYFILE: i32 = 3;\npub const SQLITE_FCNTL_LAST_ERRNO: i32 = 4;\npub const SQLITE_FCNTL_SIZE_HINT: i32 = 5;\npub const SQLITE_FCNTL_CHUNK_SIZE: i32 = 6;\npub const SQLITE_FCNTL_FILE_POINTER: i32 = 7;\npub const SQLITE_FCNTL_SYNC_OMITTED: i32 = 8;\npub const SQLITE_FCNTL_WIN32_AV_RETRY: i32 = 9;\npub const SQLITE_FCNTL_PERSIST_WAL: i32 = 10;\npub const SQLITE_FCNTL_OVERWRITE: i32 = 11;\npub const SQLITE_FCNTL_VFSNAME: i32 = 12;\npub const SQLITE_FCNTL_POWERSAFE_OVERWRITE: i32 = 13;\npub const SQLITE_FCNTL_PRAGMA: i32 = 14;\npub const SQLITE_FCNTL_BUSYHANDLER: i32 = 15;\npub const SQLITE_FCNTL_TEMPFILENAME: i32 = 16;\npub const SQLITE_FCNTL_MMAP_SIZE: i32 = 18;\npub const SQLITE_FCNTL_TRACE: i32 = 19;\npub const SQLITE_FCNTL_HAS_MOVED: i32 = 20;\npub const SQLITE_FCNTL_SYNC: i32 = 21;\npub const SQLITE_FCNTL_COMMIT_PHASETWO: i32 = 22;\npub const SQLITE_FCNTL_WIN32_SET_HANDLE: i32 = 23;\npub const SQLITE_FCNTL_WAL_BLOCK: i32 = 24;\npub const SQLITE_FCNTL_ZIPVFS: i32 = 25;\npub const SQLITE_FCNTL_RBU: i32 = 26;\npub const SQLITE_FCNTL_VFS_POINTER: i32 = 27;\npub const SQLITE_FCNTL_JOURNAL_POINTER: i32 = 28;\npub const SQLITE_FCNTL_WIN32_GET_HANDLE: i32 = 29;\npub const SQLITE_FCNTL_PDB: i32 = 30;\npub const SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: i32 = 31;\npub const SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: i32 = 32;\npub const SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: i32 = 33;\npub const SQLITE_FCNTL_LOCK_TIMEOUT: i32 = 34;\npub const SQLITE_FCNTL_DATA_VERSION: i32 = 35;\npub const SQLITE_FCNTL_SIZE_LIMIT: i32 = 36;\npub const SQLITE_FCNTL_CKPT_DONE: i32 = 37;\npub const SQLITE_FCNTL_RESERVE_BYTES: i32 = 38;\npub const SQLITE_FCNTL_CKPT_START: i32 = 39;\npub const SQLITE_FCNTL_EXTERNAL_READER: i32 = 40;\npub const SQLITE_FCNTL_CKSM_FILE: i32 = 41;\npub const SQLITE_FCNTL_RESET_CACHE: i32 = 42;\npub const SQLITE_GET_LOCKPROXYFILE: i32 = 2;\npub const SQLITE_SET_LOCKPROXYFILE: i32 = 3;\npub const SQLITE_LAST_ERRNO: i32 = 4;\npub const SQLITE_ACCESS_EXISTS: i32 = 0;\npub const SQLITE_ACCESS_READWRITE: i32 = 1;\npub const SQLITE_ACCESS_READ: i32 = 2;\npub const SQLITE_SHM_UNLOCK: i32 = 1;\npub const SQLITE_SHM_LOCK: i32 = 2;\npub const SQLITE_SHM_SHARED: i32 = 4;\npub const SQLITE_SHM_EXCLUSIVE: i32 = 8;\npub const SQLITE_SHM_NLOCK: i32 = 8;\npub const SQLITE_CONFIG_SINGLETHREAD: i32 = 1;\npub const SQLITE_CONFIG_MULTITHREAD: i32 = 2;\npub const SQLITE_CONFIG_SERIALIZED: i32 = 3;\npub const SQLITE_CONFIG_MALLOC: i32 = 4;\npub const SQLITE_CONFIG_GETMALLOC: i32 = 5;\npub const SQLITE_CONFIG_SCRATCH: i32 = 6;\npub const SQLITE_CONFIG_PAGECACHE: i32 = 7;\npub const SQLITE_CONFIG_HEAP: i32 = 8;\npub const SQLITE_CONFIG_MEMSTATUS: i32 = 9;\npub const SQLITE_CONFIG_MUTEX: i32 = 10;\npub const SQLITE_CONFIG_GETMUTEX: i32 = 11;\npub const SQLITE_CONFIG_LOOKASIDE: i32 = 13;\npub const SQLITE_CONFIG_PCACHE: i32 = 14;\npub const SQLITE_CONFIG_GETPCACHE: i32 = 15;\npub const SQLITE_CONFIG_LOG: i32 = 16;\npub const SQLITE_CONFIG_URI: i32 = 17;\npub const SQLITE_CONFIG_PCACHE2: i32 = 18;\npub const SQLITE_CONFIG_GETPCACHE2: i32 = 19;\npub const SQLITE_CONFIG_COVERING_INDEX_SCAN: i32 = 20;\npub const SQLITE_CONFIG_SQLLOG: i32 = 21;\npub const SQLITE_CONFIG_MMAP_SIZE: i32 = 22;\npub const SQLITE_CONFIG_WIN32_HEAPSIZE: i32 = 23;\npub const SQLITE_CONFIG_PCACHE_HDRSZ: i32 = 24;\npub const SQLITE_CONFIG_PMASZ: i32 = 25;\npub const SQLITE_CONFIG_STMTJRNL_SPILL: i32 = 26;\npub const SQLITE_CONFIG_SMALL_MALLOC: i32 = 27;\npub const SQLITE_CONFIG_SORTERREF_SIZE: i32 = 28;\npub const SQLITE_CONFIG_MEMDB_MAXSIZE: i32 = 29;\npub const SQLITE_CONFIG_ROWID_IN_VIEW: i32 = 30;\npub const SQLITE_DBCONFIG_MAINDBNAME: i32 = 1000;\npub const SQLITE_DBCONFIG_LOOKASIDE: i32 = 1001;\npub const SQLITE_DBCONFIG_ENABLE_FKEY: i32 = 1002;\npub const SQLITE_DBCONFIG_ENABLE_TRIGGER: i32 = 1003;\npub const SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER: i32 = 1004;\npub const SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION: i32 = 1005;\npub const SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE: i32 = 1006;\npub const SQLITE_DBCONFIG_ENABLE_QPSG: i32 = 1007;\npub const SQLITE_DBCONFIG_TRIGGER_EQP: i32 = 1008;\npub const SQLITE_DBCONFIG_RESET_DATABASE: i32 = 1009;\npub const SQLITE_DBCONFIG_DEFENSIVE: i32 = 1010;\npub const SQLITE_DBCONFIG_WRITABLE_SCHEMA: i32 = 1011;\npub const SQLITE_DBCONFIG_LEGACY_ALTER_TABLE: i32 = 1012;\npub const SQLITE_DBCONFIG_DQS_DML: i32 = 1013;\npub const SQLITE_DBCONFIG_DQS_DDL: i32 = 1014;\npub const SQLITE_DBCONFIG_ENABLE_VIEW: i32 = 1015;\npub const SQLITE_DBCONFIG_LEGACY_FILE_FORMAT: i32 = 1016;\npub const SQLITE_DBCONFIG_TRUSTED_SCHEMA: i32 = 1017;\npub const SQLITE_DBCONFIG_STMT_SCANSTATUS: i32 = 1018;\npub const SQLITE_DBCONFIG_REVERSE_SCANORDER: i32 = 1019;\npub const SQLITE_DBCONFIG_MAX: i32 = 1019;\npub const SQLITE_DENY: i32 = 1;\npub const SQLITE_IGNORE: i32 = 2;\npub const SQLITE_CREATE_INDEX: i32 = 1;\npub const SQLITE_CREATE_TABLE: i32 = 2;\npub const SQLITE_CREATE_TEMP_INDEX: i32 = 3;\npub const SQLITE_CREATE_TEMP_TABLE: i32 = 4;\npub const SQLITE_CREATE_TEMP_TRIGGER: i32 = 5;\npub const SQLITE_CREATE_TEMP_VIEW: i32 = 6;\npub const SQLITE_CREATE_TRIGGER: i32 = 7;\npub const SQLITE_CREATE_VIEW: i32 = 8;\npub const SQLITE_DELETE: i32 = 9;\npub const SQLITE_DROP_INDEX: i32 = 10;\npub const SQLITE_DROP_TABLE: i32 = 11;\npub const SQLITE_DROP_TEMP_INDEX: i32 = 12;\npub const SQLITE_DROP_TEMP_TABLE: i32 = 13;\npub const SQLITE_DROP_TEMP_TRIGGER: i32 = 14;\npub const SQLITE_DROP_TEMP_VIEW: i32 = 15;\npub const SQLITE_DROP_TRIGGER: i32 = 16;\npub const SQLITE_DROP_VIEW: i32 = 17;\npub const SQLITE_INSERT: i32 = 18;\npub const SQLITE_PRAGMA: i32 = 19;\npub const SQLITE_READ: i32 = 20;\npub const SQLITE_SELECT: i32 = 21;\npub const SQLITE_TRANSACTION: i32 = 22;\npub const SQLITE_UPDATE: i32 = 23;\npub const SQLITE_ATTACH: i32 = 24;\npub const SQLITE_DETACH: i32 = 25;\npub const SQLITE_ALTER_TABLE: i32 = 26;\npub const SQLITE_REINDEX: i32 = 27;\npub const SQLITE_ANALYZE: i32 = 28;\npub const SQLITE_CREATE_VTABLE: i32 = 29;\npub const SQLITE_DROP_VTABLE: i32 = 30;\npub const SQLITE_FUNCTION: i32 = 31;\npub const SQLITE_SAVEPOINT: i32 = 32;\npub const SQLITE_COPY: i32 = 0;\npub const SQLITE_RECURSIVE: i32 = 33;\npub const SQLITE_TRACE_STMT: i32 = 1;\npub const SQLITE_TRACE_PROFILE: i32 = 2;\npub const SQLITE_TRACE_ROW: i32 = 4;\npub const SQLITE_TRACE_CLOSE: i32 = 8;\npub const SQLITE_LIMIT_LENGTH: i32 = 0;\npub const SQLITE_LIMIT_SQL_LENGTH: i32 = 1;\npub const SQLITE_LIMIT_COLUMN: i32 = 2;\npub const SQLITE_LIMIT_EXPR_DEPTH: i32 = 3;\npub const SQLITE_LIMIT_COMPOUND_SELECT: i32 = 4;\npub const SQLITE_LIMIT_VDBE_OP: i32 = 5;\npub const SQLITE_LIMIT_FUNCTION_ARG: i32 = 6;\npub const SQLITE_LIMIT_ATTACHED: i32 = 7;\npub const SQLITE_LIMIT_LIKE_PATTERN_LENGTH: i32 = 8;\npub const SQLITE_LIMIT_VARIABLE_NUMBER: i32 = 9;\npub const SQLITE_LIMIT_TRIGGER_DEPTH: i32 = 10;\npub const SQLITE_LIMIT_WORKER_THREADS: i32 = 11;\npub const SQLITE_PREPARE_PERSISTENT: ::std::os::raw::c_uint = 1;\npub const SQLITE_PREPARE_NORMALIZE: ::std::os::raw::c_uint = 2;\npub const SQLITE_PREPARE_NO_VTAB: ::std::os::raw::c_uint = 4;\npub const SQLITE_INTEGER: i32 = 1;\npub const SQLITE_FLOAT: i32 = 2;\npub const SQLITE_BLOB: i32 = 4;\npub const SQLITE_NULL: i32 = 5;\npub const SQLITE_TEXT: i32 = 3;\npub const SQLITE3_TEXT: i32 = 3;\npub const SQLITE_UTF8: i32 = 1;\npub const SQLITE_UTF16LE: i32 = 2;\npub const SQLITE_UTF16BE: i32 = 3;\npub const SQLITE_UTF16: i32 = 4;\npub const SQLITE_ANY: i32 = 5;\npub const SQLITE_UTF16_ALIGNED: i32 = 8;\npub const SQLITE_DETERMINISTIC: i32 = 2048;\npub const SQLITE_DIRECTONLY: i32 = 524288;\npub const SQLITE_SUBTYPE: i32 = 1048576;\npub const SQLITE_INNOCUOUS: i32 = 2097152;\npub const SQLITE_RESULT_SUBTYPE: i32 = 16777216;\npub const SQLITE_WIN32_DATA_DIRECTORY_TYPE: i32 = 1;\npub const SQLITE_WIN32_TEMP_DIRECTORY_TYPE: i32 = 2;\npub const SQLITE_TXN_NONE: i32 = 0;\npub const SQLITE_TXN_READ: i32 = 1;\npub const SQLITE_TXN_WRITE: i32 = 2;\npub const SQLITE_INDEX_SCAN_UNIQUE: i32 = 1;\npub const SQLITE_INDEX_CONSTRAINT_EQ: i32 = 2;\npub const SQLITE_INDEX_CONSTRAINT_GT: i32 = 4;\npub const SQLITE_INDEX_CONSTRAINT_LE: i32 = 8;\npub const SQLITE_INDEX_CONSTRAINT_LT: i32 = 16;\npub const SQLITE_INDEX_CONSTRAINT_GE: i32 = 32;\npub const SQLITE_INDEX_CONSTRAINT_MATCH: i32 = 64;\npub const SQLITE_INDEX_CONSTRAINT_LIKE: i32 = 65;\npub const SQLITE_INDEX_CONSTRAINT_GLOB: i32 = 66;\npub const SQLITE_INDEX_CONSTRAINT_REGEXP: i32 = 67;\npub const SQLITE_INDEX_CONSTRAINT_NE: i32 = 68;\npub const SQLITE_INDEX_CONSTRAINT_ISNOT: i32 = 69;\npub const SQLITE_INDEX_CONSTRAINT_ISNOTNULL: i32 = 70;\npub const SQLITE_INDEX_CONSTRAINT_ISNULL: i32 = 71;\npub const SQLITE_INDEX_CONSTRAINT_IS: i32 = 72;\npub const SQLITE_INDEX_CONSTRAINT_LIMIT: i32 = 73;\npub const SQLITE_INDEX_CONSTRAINT_OFFSET: i32 = 74;\npub const SQLITE_INDEX_CONSTRAINT_FUNCTION: i32 = 150;\npub const SQLITE_MUTEX_FAST: i32 = 0;\npub const SQLITE_MUTEX_RECURSIVE: i32 = 1;\npub const SQLITE_MUTEX_STATIC_MAIN: i32 = 2;\npub const SQLITE_MUTEX_STATIC_MEM: i32 = 3;\npub const SQLITE_MUTEX_STATIC_MEM2: i32 = 4;\npub const SQLITE_MUTEX_STATIC_OPEN: i32 = 4;\npub const SQLITE_MUTEX_STATIC_PRNG: i32 = 5;\npub const SQLITE_MUTEX_STATIC_LRU: i32 = 6;\npub const SQLITE_MUTEX_STATIC_LRU2: i32 = 7;\npub const SQLITE_MUTEX_STATIC_PMEM: i32 = 7;\npub const SQLITE_MUTEX_STATIC_APP1: i32 = 8;\npub const SQLITE_MUTEX_STATIC_APP2: i32 = 9;\npub const SQLITE_MUTEX_STATIC_APP3: i32 = 10;\npub const SQLITE_MUTEX_STATIC_VFS1: i32 = 11;\npub const SQLITE_MUTEX_STATIC_VFS2: i32 = 12;\npub const SQLITE_MUTEX_STATIC_VFS3: i32 = 13;\npub const SQLITE_MUTEX_STATIC_MASTER: i32 = 2;\npub const SQLITE_TESTCTRL_FIRST: i32 = 5;\npub const SQLITE_TESTCTRL_PRNG_SAVE: i32 = 5;\npub const SQLITE_TESTCTRL_PRNG_RESTORE: i32 = 6;\npub const SQLITE_TESTCTRL_PRNG_RESET: i32 = 7;\npub const SQLITE_TESTCTRL_FK_NO_ACTION: i32 = 7;\npub const SQLITE_TESTCTRL_BITVEC_TEST: i32 = 8;\npub const SQLITE_TESTCTRL_FAULT_INSTALL: i32 = 9;\npub const SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: i32 = 10;\npub const SQLITE_TESTCTRL_PENDING_BYTE: i32 = 11;\npub const SQLITE_TESTCTRL_ASSERT: i32 = 12;\npub const SQLITE_TESTCTRL_ALWAYS: i32 = 13;\npub const SQLITE_TESTCTRL_RESERVE: i32 = 14;\npub const SQLITE_TESTCTRL_JSON_SELFCHECK: i32 = 14;\npub const SQLITE_TESTCTRL_OPTIMIZATIONS: i32 = 15;\npub const SQLITE_TESTCTRL_ISKEYWORD: i32 = 16;\npub const SQLITE_TESTCTRL_SCRATCHMALLOC: i32 = 17;\npub const SQLITE_TESTCTRL_INTERNAL_FUNCTIONS: i32 = 17;\npub const SQLITE_TESTCTRL_LOCALTIME_FAULT: i32 = 18;\npub const SQLITE_TESTCTRL_EXPLAIN_STMT: i32 = 19;\npub const SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD: i32 = 19;\npub const SQLITE_TESTCTRL_NEVER_CORRUPT: i32 = 20;\npub const SQLITE_TESTCTRL_VDBE_COVERAGE: i32 = 21;\npub const SQLITE_TESTCTRL_BYTEORDER: i32 = 22;\npub const SQLITE_TESTCTRL_ISINIT: i32 = 23;\npub const SQLITE_TESTCTRL_SORTER_MMAP: i32 = 24;\npub const SQLITE_TESTCTRL_IMPOSTER: i32 = 25;\npub const SQLITE_TESTCTRL_PARSER_COVERAGE: i32 = 26;\npub const SQLITE_TESTCTRL_RESULT_INTREAL: i32 = 27;\npub const SQLITE_TESTCTRL_PRNG_SEED: i32 = 28;\npub const SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS: i32 = 29;\npub const SQLITE_TESTCTRL_SEEK_COUNT: i32 = 30;\npub const SQLITE_TESTCTRL_TRACEFLAGS: i32 = 31;\npub const SQLITE_TESTCTRL_TUNE: i32 = 32;\npub const SQLITE_TESTCTRL_LOGEST: i32 = 33;\npub const SQLITE_TESTCTRL_USELONGDOUBLE: i32 = 34;\npub const SQLITE_TESTCTRL_LAST: i32 = 34;\npub const SQLITE_STATUS_MEMORY_USED: i32 = 0;\npub const SQLITE_STATUS_PAGECACHE_USED: i32 = 1;\npub const SQLITE_STATUS_PAGECACHE_OVERFLOW: i32 = 2;\npub const SQLITE_STATUS_SCRATCH_USED: i32 = 3;\npub const SQLITE_STATUS_SCRATCH_OVERFLOW: i32 = 4;\npub const SQLITE_STATUS_MALLOC_SIZE: i32 = 5;\npub const SQLITE_STATUS_PARSER_STACK: i32 = 6;\npub const SQLITE_STATUS_PAGECACHE_SIZE: i32 = 7;\npub const SQLITE_STATUS_SCRATCH_SIZE: i32 = 8;\npub const SQLITE_STATUS_MALLOC_COUNT: i32 = 9;\npub const SQLITE_DBSTATUS_LOOKASIDE_USED: i32 = 0;\npub const SQLITE_DBSTATUS_CACHE_USED: i32 = 1;\npub const SQLITE_DBSTATUS_SCHEMA_USED: i32 = 2;\npub const SQLITE_DBSTATUS_STMT_USED: i32 = 3;\npub const SQLITE_DBSTATUS_LOOKASIDE_HIT: i32 = 4;\npub const SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE: i32 = 5;\npub const SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: i32 = 6;\npub const SQLITE_DBSTATUS_CACHE_HIT: i32 = 7;\npub const SQLITE_DBSTATUS_CACHE_MISS: i32 = 8;\npub const SQLITE_DBSTATUS_CACHE_WRITE: i32 = 9;\npub const SQLITE_DBSTATUS_DEFERRED_FKS: i32 = 10;\npub const SQLITE_DBSTATUS_CACHE_USED_SHARED: i32 = 11;\npub const SQLITE_DBSTATUS_CACHE_SPILL: i32 = 12;\npub const SQLITE_DBSTATUS_MAX: i32 = 12;\npub const SQLITE_STMTSTATUS_FULLSCAN_STEP: i32 = 1;\npub const SQLITE_STMTSTATUS_SORT: i32 = 2;\npub const SQLITE_STMTSTATUS_AUTOINDEX: i32 = 3;\npub const SQLITE_STMTSTATUS_VM_STEP: i32 = 4;\npub const SQLITE_STMTSTATUS_REPREPARE: i32 = 5;\npub const SQLITE_STMTSTATUS_RUN: i32 = 6;\npub const SQLITE_STMTSTATUS_FILTER_MISS: i32 = 7;\npub const SQLITE_STMTSTATUS_FILTER_HIT: i32 = 8;\npub const SQLITE_STMTSTATUS_MEMUSED: i32 = 99;\npub const SQLITE_CHECKPOINT_PASSIVE: i32 = 0;\npub const SQLITE_CHECKPOINT_FULL: i32 = 1;\npub const SQLITE_CHECKPOINT_RESTART: i32 = 2;\npub const SQLITE_CHECKPOINT_TRUNCATE: i32 = 3;\npub const SQLITE_VTAB_CONSTRAINT_SUPPORT: i32 = 1;\npub const SQLITE_VTAB_INNOCUOUS: i32 = 2;\npub const SQLITE_VTAB_DIRECTONLY: i32 = 3;\npub const SQLITE_VTAB_USES_ALL_SCHEMAS: i32 = 4;\npub const SQLITE_ROLLBACK: i32 = 1;\npub const SQLITE_FAIL: i32 = 3;\npub const SQLITE_REPLACE: i32 = 5;\npub const SQLITE_SCANSTAT_NLOOP: i32 = 0;\npub const SQLITE_SCANSTAT_NVISIT: i32 = 1;\npub const SQLITE_SCANSTAT_EST: i32 = 2;\npub const SQLITE_SCANSTAT_NAME: i32 = 3;\npub const SQLITE_SCANSTAT_EXPLAIN: i32 = 4;\npub const SQLITE_SCANSTAT_SELECTID: i32 = 5;\npub const SQLITE_SCANSTAT_PARENTID: i32 = 6;\npub const SQLITE_SCANSTAT_NCYCLE: i32 = 7;\npub const SQLITE_SCANSTAT_COMPLEX: i32 = 1;\npub const SQLITE_SERIALIZE_NOCOPY: ::std::os::raw::c_uint = 1;\npub const SQLITE_DESERIALIZE_FREEONCLOSE: ::std::os::raw::c_uint = 1;\npub const SQLITE_DESERIALIZE_RESIZEABLE: ::std::os::raw::c_uint = 2;\npub const SQLITE_DESERIALIZE_READONLY: ::std::os::raw::c_uint = 4;\npub const NOT_WITHIN: i32 = 0;\npub const PARTLY_WITHIN: i32 = 1;\npub const FULLY_WITHIN: i32 = 2;\npub const SQLITE_SESSION_OBJCONFIG_SIZE: i32 = 1;\npub const SQLITE_SESSION_OBJCONFIG_ROWID: i32 = 2;\npub const SQLITE_CHANGESETSTART_INVERT: i32 = 2;\npub const SQLITE_CHANGESETAPPLY_NOSAVEPOINT: i32 = 1;\npub const SQLITE_CHANGESETAPPLY_INVERT: i32 = 2;\npub const SQLITE_CHANGESETAPPLY_IGNORENOOP: i32 = 4;\npub const SQLITE_CHANGESETAPPLY_FKNOACTION: i32 = 8;\npub const SQLITE_CHANGESET_DATA: i32 = 1;\npub const SQLITE_CHANGESET_NOTFOUND: i32 = 2;\npub const SQLITE_CHANGESET_CONFLICT: i32 = 3;\npub const SQLITE_CHANGESET_CONSTRAINT: i32 = 4;\npub const SQLITE_CHANGESET_FOREIGN_KEY: i32 = 5;\npub const SQLITE_CHANGESET_OMIT: i32 = 0;\npub const SQLITE_CHANGESET_REPLACE: i32 = 1;\npub const SQLITE_CHANGESET_ABORT: i32 = 2;\npub const SQLITE_SESSION_CONFIG_STRMSIZE: i32 = 1;\npub const FTS5_TOKENIZE_QUERY: i32 = 1;\npub const FTS5_TOKENIZE_PREFIX: i32 = 2;\npub const FTS5_TOKENIZE_DOCUMENT: i32 = 4;\npub const FTS5_TOKENIZE_AUX: i32 = 8;\npub const FTS5_TOKEN_COLOCATED: i32 = 1;\nextern \"C\" {\n    pub static sqlite3_version: [::std::os::raw::c_char; 0usize];\n}\nextern \"C\" {\n    pub fn sqlite3_libversion() -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_sourceid() -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_libversion_number() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_compileoption_used(\n        zOptName: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_compileoption_get(N: ::std::os::raw::c_int) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_threadsafe() -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3 {\n    _unused: [u8; 0],\n}\npub type sqlite_int64 = ::std::os::raw::c_longlong;\npub type sqlite_uint64 = ::std::os::raw::c_ulonglong;\npub type sqlite3_int64 = sqlite_int64;\npub type sqlite3_uint64 = sqlite_uint64;\nextern \"C\" {\n    pub fn sqlite3_close(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\npub type sqlite3_callback = ::std::option::Option\u003c\n    unsafe extern \"C\" fn(\n        arg1: *mut ::std::os::raw::c_void,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut *mut ::std::os::raw::c_char,\n        arg4: *mut *mut ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int,\n\u003e;\nextern \"C\" {\n    pub fn sqlite3_exec(\n        arg1: *mut sqlite3,\n        sql: *const ::std::os::raw::c_char,\n        callback: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut ::std::os::raw::c_char,\n                arg4: *mut *mut ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        arg2: *mut ::std::os::raw::c_void,\n        errmsg: *mut *mut ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_file {\n    pub pMethods: *const sqlite3_io_methods,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_io_methods {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xClose: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRead: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: *mut ::std::os::raw::c_void,\n            iAmt: ::std::os::raw::c_int,\n            iOfst: sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xWrite: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: *const ::std::os::raw::c_void,\n            iAmt: ::std::os::raw::c_int,\n            iOfst: sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xTruncate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file, size: sqlite3_int64) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSync: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            flags: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFileSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            pSize: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xLock: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xUnlock: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xCheckReservedLock: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            pResOut: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFileControl: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            op: ::std::os::raw::c_int,\n            pArg: *mut ::std::os::raw::c_void,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSectorSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDeviceCharacteristics: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShmMap: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            iPg: ::std::os::raw::c_int,\n            pgsz: ::std::os::raw::c_int,\n            arg2: ::std::os::raw::c_int,\n            arg3: *mut *mut ::std::os::raw::c_void,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShmLock: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            offset: ::std::os::raw::c_int,\n            n: ::std::os::raw::c_int,\n            flags: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShmBarrier: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_file)\u003e,\n    pub xShmUnmap: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            deleteFlag: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFetch: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            iOfst: sqlite3_int64,\n            iAmt: ::std::os::raw::c_int,\n            pp: *mut *mut ::std::os::raw::c_void,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xUnfetch: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            iOfst: sqlite3_int64,\n            p: *mut ::std::os::raw::c_void,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_mutex {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_api_routines {\n    _unused: [u8; 0],\n}\npub type sqlite3_filename = *const ::std::os::raw::c_char;\npub type sqlite3_syscall_ptr = ::std::option::Option\u003cunsafe extern \"C\" fn()\u003e;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_vfs {\n    pub iVersion: ::std::os::raw::c_int,\n    pub szOsFile: ::std::os::raw::c_int,\n    pub mxPathname: ::std::os::raw::c_int,\n    pub pNext: *mut sqlite3_vfs,\n    pub zName: *const ::std::os::raw::c_char,\n    pub pAppData: *mut ::std::os::raw::c_void,\n    pub xOpen: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: sqlite3_filename,\n            arg2: *mut sqlite3_file,\n            flags: ::std::os::raw::c_int,\n            pOutFlags: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDelete: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            syncDir: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xAccess: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            flags: ::std::os::raw::c_int,\n            pResOut: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFullPathname: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            nOut: ::std::os::raw::c_int,\n            zOut: *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDlOpen: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zFilename: *const ::std::os::raw::c_char,\n        ) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xDlError: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            nByte: ::std::os::raw::c_int,\n            zErrMsg: *mut ::std::os::raw::c_char,\n        ),\n    \u003e,\n    pub xDlSym: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            arg2: *mut ::std::os::raw::c_void,\n            zSymbol: *const ::std::os::raw::c_char,\n        ) -\u003e ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_vfs,\n                arg2: *mut ::std::os::raw::c_void,\n                zSymbol: *const ::std::os::raw::c_char,\n            ),\n        \u003e,\n    \u003e,\n    pub xDlClose: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vfs, arg2: *mut ::std::os::raw::c_void),\n    \u003e,\n    pub xRandomness: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            nByte: ::std::os::raw::c_int,\n            zOut: *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSleep: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            microseconds: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xCurrentTime: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vfs, arg2: *mut f64) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xGetLastError: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            arg2: ::std::os::raw::c_int,\n            arg3: *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xCurrentTimeInt64: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            arg2: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSetSystemCall: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            arg2: sqlite3_syscall_ptr,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xGetSystemCall: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n        ) -\u003e sqlite3_syscall_ptr,\n    \u003e,\n    pub xNextSystemCall: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n        ) -\u003e *const ::std::os::raw::c_char,\n    \u003e,\n}\nextern \"C\" {\n    pub fn sqlite3_initialize() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_shutdown() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_os_init() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_os_end() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_config(arg1: ::std::os::raw::c_int, ...) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_config(\n        arg1: *mut sqlite3,\n        op: ::std::os::raw::c_int,\n        ...\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_mem_methods {\n    pub xMalloc: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: ::std::os::raw::c_int) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xFree: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    pub xRealloc: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: ::std::os::raw::c_int,\n        ) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRoundup: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: ::std::os::raw::c_int) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xInit: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShutdown: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    pub pAppData: *mut ::std::os::raw::c_void,\n}\nextern \"C\" {\n    pub fn sqlite3_extended_result_codes(\n        arg1: *mut sqlite3,\n        onoff: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_last_insert_rowid(arg1: *mut sqlite3) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_set_last_insert_rowid(arg1: *mut sqlite3, arg2: sqlite3_int64);\n}\nextern \"C\" {\n    pub fn sqlite3_changes(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_changes64(arg1: *mut sqlite3) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_total_changes(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_total_changes64(arg1: *mut sqlite3) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_interrupt(arg1: *mut sqlite3);\n}\nextern \"C\" {\n    pub fn sqlite3_is_interrupted(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_complete(sql: *const ::std::os::raw::c_char) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_busy_handler(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_busy_timeout(\n        arg1: *mut sqlite3,\n        ms: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_get_table(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_char,\n        pazResult: *mut *mut *mut ::std::os::raw::c_char,\n        pnRow: *mut ::std::os::raw::c_int,\n        pnColumn: *mut ::std::os::raw::c_int,\n        pzErrmsg: *mut *mut ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_free_table(result: *mut *mut ::std::os::raw::c_char);\n}\nextern \"C\" {\n    pub fn sqlite3_mprintf(arg1: *const ::std::os::raw::c_char, ...)\n        -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_snprintf(\n        arg1: ::std::os::raw::c_int,\n        arg2: *mut ::std::os::raw::c_char,\n        arg3: *const ::std::os::raw::c_char,\n        ...\n    ) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_malloc(arg1: ::std::os::raw::c_int) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_malloc64(arg1: sqlite3_uint64) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_realloc(\n        arg1: *mut ::std::os::raw::c_void,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_realloc64(\n        arg1: *mut ::std::os::raw::c_void,\n        arg2: sqlite3_uint64,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_free(arg1: *mut ::std::os::raw::c_void);\n}\nextern \"C\" {\n    pub fn sqlite3_msize(arg1: *mut ::std::os::raw::c_void) -\u003e sqlite3_uint64;\n}\nextern \"C\" {\n    pub fn sqlite3_memory_used() -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_memory_highwater(resetFlag: ::std::os::raw::c_int) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_randomness(N: ::std::os::raw::c_int, P: *mut ::std::os::raw::c_void);\n}\nextern \"C\" {\n    pub fn sqlite3_set_authorizer(\n        arg1: *mut sqlite3,\n        xAuth: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_char,\n                arg4: *const ::std::os::raw::c_char,\n                arg5: *const ::std::os::raw::c_char,\n                arg6: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pUserData: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_trace(\n        arg1: *mut sqlite3,\n        xTrace: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *const ::std::os::raw::c_char,\n            ),\n        \u003e,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_profile(\n        arg1: *mut sqlite3,\n        xProfile: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *const ::std::os::raw::c_char,\n                arg3: sqlite3_uint64,\n            ),\n        \u003e,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_trace_v2(\n        arg1: *mut sqlite3,\n        uMask: ::std::os::raw::c_uint,\n        xCallback: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: ::std::os::raw::c_uint,\n                arg2: *mut ::std::os::raw::c_void,\n                arg3: *mut ::std::os::raw::c_void,\n                arg4: *mut ::std::os::raw::c_void,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_progress_handler(\n        arg1: *mut sqlite3,\n        arg2: ::std::os::raw::c_int,\n        arg3: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        arg4: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_open(\n        filename: *const ::std::os::raw::c_char,\n        ppDb: *mut *mut sqlite3,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_open_v2(\n        filename: *const ::std::os::raw::c_char,\n        ppDb: *mut *mut sqlite3,\n        flags: ::std::os::raw::c_int,\n        zVfs: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_parameter(\n        z: sqlite3_filename,\n        zParam: *const ::std::os::raw::c_char,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_boolean(\n        z: sqlite3_filename,\n        zParam: *const ::std::os::raw::c_char,\n        bDefault: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_int64(\n        arg1: sqlite3_filename,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: sqlite3_int64,\n    ) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_key(\n        z: sqlite3_filename,\n        N: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_filename_database(arg1: sqlite3_filename) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_filename_journal(arg1: sqlite3_filename) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_filename_wal(arg1: sqlite3_filename) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_database_file_object(arg1: *const ::std::os::raw::c_char) -\u003e *mut sqlite3_file;\n}\nextern \"C\" {\n    pub fn sqlite3_create_filename(\n        zDatabase: *const ::std::os::raw::c_char,\n        zJournal: *const ::std::os::raw::c_char,\n        zWal: *const ::std::os::raw::c_char,\n        nParam: ::std::os::raw::c_int,\n        azParam: *mut *const ::std::os::raw::c_char,\n    ) -\u003e sqlite3_filename;\n}\nextern \"C\" {\n    pub fn sqlite3_free_filename(arg1: sqlite3_filename);\n}\nextern \"C\" {\n    pub fn sqlite3_errcode(db: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_extended_errcode(db: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_errmsg(arg1: *mut sqlite3) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_errstr(arg1: ::std::os::raw::c_int) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_error_offset(db: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_stmt {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_limit(\n        arg1: *mut sqlite3,\n        id: ::std::os::raw::c_int,\n        newVal: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_prepare_v2(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_char,\n        nByte: ::std::os::raw::c_int,\n        ppStmt: *mut *mut sqlite3_stmt,\n        pzTail: *mut *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_prepare_v3(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_char,\n        nByte: ::std::os::raw::c_int,\n        prepFlags: ::std::os::raw::c_uint,\n        ppStmt: *mut *mut sqlite3_stmt,\n        pzTail: *mut *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_sql(pStmt: *mut sqlite3_stmt) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_expanded_sql(pStmt: *mut sqlite3_stmt) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_readonly(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_isexplain(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_explain(\n        pStmt: *mut sqlite3_stmt,\n        eMode: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_busy(arg1: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_value {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_context {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_bind_blob(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_void,\n        n: ::std::os::raw::c_int,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_blob64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_void,\n        arg4: sqlite3_uint64,\n        arg5: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_double(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: f64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_int(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_int64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: sqlite3_int64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_null(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_text(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_char,\n        arg4: ::std::os::raw::c_int,\n        arg5: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_text64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_char,\n        arg4: sqlite3_uint64,\n        arg5: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        encoding: ::std::os::raw::c_uchar,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_value(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_pointer(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut ::std::os::raw::c_void,\n        arg4: *const ::std::os::raw::c_char,\n        arg5: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_zeroblob(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        n: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_zeroblob64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: sqlite3_uint64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_parameter_count(arg1: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_parameter_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_parameter_index(\n        arg1: *mut sqlite3_stmt,\n        zName: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_clear_bindings(arg1: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_name(\n        arg1: *mut sqlite3_stmt,\n        N: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_database_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_table_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_origin_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_decltype(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_step(arg1: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_data_count(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_blob(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_column_double(arg1: *mut sqlite3_stmt, iCol: ::std::os::raw::c_int) -\u003e f64;\n}\nextern \"C\" {\n    pub fn sqlite3_column_int(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_int64(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_column_text(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_uchar;\n}\nextern \"C\" {\n    pub fn sqlite3_column_value(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e *mut sqlite3_value;\n}\nextern \"C\" {\n    pub fn sqlite3_column_bytes(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_type(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_function_v2(\n        db: *mut sqlite3,\n        zFunctionName: *const ::std::os::raw::c_char,\n        nArg: ::std::os::raw::c_int,\n        eTextRep: ::std::os::raw::c_int,\n        pApp: *mut ::std::os::raw::c_void,\n        xFunc: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xStep: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xFinal: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_context)\u003e,\n        xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_window_function(\n        db: *mut sqlite3,\n        zFunctionName: *const ::std::os::raw::c_char,\n        nArg: ::std::os::raw::c_int,\n        eTextRep: ::std::os::raw::c_int,\n        pApp: *mut ::std::os::raw::c_void,\n        xStep: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xFinal: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_context)\u003e,\n        xValue: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_context)\u003e,\n        xInverse: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_aggregate_count(arg1: *mut sqlite3_context) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_expired(arg1: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_transfer_bindings(\n        arg1: *mut sqlite3_stmt,\n        arg2: *mut sqlite3_stmt,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_global_recover() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_thread_cleanup();\n}\nextern \"C\" {\n    pub fn sqlite3_memory_alarm(\n        arg1: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: sqlite3_int64,\n                arg3: ::std::os::raw::c_int,\n            ),\n        \u003e,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: sqlite3_int64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_blob(arg1: *mut sqlite3_value) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_value_double(arg1: *mut sqlite3_value) -\u003e f64;\n}\nextern \"C\" {\n    pub fn sqlite3_value_int(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_int64(arg1: *mut sqlite3_value) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_value_pointer(\n        arg1: *mut sqlite3_value,\n        arg2: *const ::std::os::raw::c_char,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_value_text(arg1: *mut sqlite3_value) -\u003e *const ::std::os::raw::c_uchar;\n}\nextern \"C\" {\n    pub fn sqlite3_value_bytes(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_type(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_numeric_type(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_nochange(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_frombind(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_encoding(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_subtype(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_uint;\n}\nextern \"C\" {\n    pub fn sqlite3_value_dup(arg1: *const sqlite3_value) -\u003e *mut sqlite3_value;\n}\nextern \"C\" {\n    pub fn sqlite3_value_free(arg1: *mut sqlite3_value);\n}\nextern \"C\" {\n    pub fn sqlite3_aggregate_context(\n        arg1: *mut sqlite3_context,\n        nBytes: ::std::os::raw::c_int,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_user_data(arg1: *mut sqlite3_context) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_context_db_handle(arg1: *mut sqlite3_context) -\u003e *mut sqlite3;\n}\nextern \"C\" {\n    pub fn sqlite3_get_auxdata(\n        arg1: *mut sqlite3_context,\n        N: ::std::os::raw::c_int,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_set_auxdata(\n        arg1: *mut sqlite3_context,\n        N: ::std::os::raw::c_int,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_get_clientdata(\n        arg1: *mut sqlite3,\n        arg2: *const ::std::os::raw::c_char,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_set_clientdata(\n        arg1: *mut sqlite3,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: *mut ::std::os::raw::c_void,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\npub type sqlite3_destructor_type =\n    ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e;\nextern \"C\" {\n    pub fn sqlite3_result_blob(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_void,\n        arg3: ::std::os::raw::c_int,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_blob64(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_void,\n        arg3: sqlite3_uint64,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_double(arg1: *mut sqlite3_context, arg2: f64);\n}\nextern \"C\" {\n    pub fn sqlite3_result_error(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: ::std::os::raw::c_int,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_error_toobig(arg1: *mut sqlite3_context);\n}\nextern \"C\" {\n    pub fn sqlite3_result_error_nomem(arg1: *mut sqlite3_context);\n}\nextern \"C\" {\n    pub fn sqlite3_result_error_code(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_result_int(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_result_int64(arg1: *mut sqlite3_context, arg2: sqlite3_int64);\n}\nextern \"C\" {\n    pub fn sqlite3_result_null(arg1: *mut sqlite3_context);\n}\nextern \"C\" {\n    pub fn sqlite3_result_text(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: ::std::os::raw::c_int,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_text64(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: sqlite3_uint64,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        encoding: ::std::os::raw::c_uchar,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_value(arg1: *mut sqlite3_context, arg2: *mut sqlite3_value);\n}\nextern \"C\" {\n    pub fn sqlite3_result_pointer(\n        arg1: *mut sqlite3_context,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: *const ::std::os::raw::c_char,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_zeroblob(arg1: *mut sqlite3_context, n: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_result_zeroblob64(\n        arg1: *mut sqlite3_context,\n        n: sqlite3_uint64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_result_subtype(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_uint);\n}\nextern \"C\" {\n    pub fn sqlite3_create_collation_v2(\n        arg1: *mut sqlite3,\n        zName: *const ::std::os::raw::c_char,\n        eTextRep: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n        xCompare: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_void,\n                arg4: ::std::os::raw::c_int,\n                arg5: *const ::std::os::raw::c_void,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_collation_needed(\n        arg1: *mut sqlite3,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *mut sqlite3,\n                eTextRep: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_char,\n            ),\n        \u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_sleep(arg1: ::std::os::raw::c_int) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub static mut sqlite3_temp_directory: *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub static mut sqlite3_data_directory: *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_win32_set_directory(\n        type_: ::std::os::raw::c_ulong,\n        zValue: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_win32_set_directory8(\n        type_: ::std::os::raw::c_ulong,\n        zValue: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_get_autocommit(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_handle(arg1: *mut sqlite3_stmt) -\u003e *mut sqlite3;\n}\nextern \"C\" {\n    pub fn sqlite3_db_name(\n        db: *mut sqlite3,\n        N: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_db_filename(\n        db: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n    ) -\u003e sqlite3_filename;\n}\nextern \"C\" {\n    pub fn sqlite3_db_readonly(\n        db: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_txn_state(\n        arg1: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_next_stmt(pDb: *mut sqlite3, pStmt: *mut sqlite3_stmt) -\u003e *mut sqlite3_stmt;\n}\nextern \"C\" {\n    pub fn sqlite3_commit_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_rollback_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_autovacuum_pages(\n        db: *mut sqlite3,\n        arg1: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *const ::std::os::raw::c_char,\n                arg3: ::std::os::raw::c_uint,\n                arg4: ::std::os::raw::c_uint,\n                arg5: ::std::os::raw::c_uint,\n            ) -\u003e ::std::os::raw::c_uint,\n        \u003e,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_update_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_char,\n                arg4: *const ::std::os::raw::c_char,\n                arg5: sqlite3_int64,\n            ),\n        \u003e,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_enable_shared_cache(arg1: ::std::os::raw::c_int) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_release_memory(arg1: ::std::os::raw::c_int) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_release_memory(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_soft_heap_limit64(N: sqlite3_int64) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_hard_heap_limit64(N: sqlite3_int64) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_soft_heap_limit(N: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_table_column_metadata(\n        db: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n        zTableName: *const ::std::os::raw::c_char,\n        zColumnName: *const ::std::os::raw::c_char,\n        pzDataType: *mut *const ::std::os::raw::c_char,\n        pzCollSeq: *mut *const ::std::os::raw::c_char,\n        pNotNull: *mut ::std::os::raw::c_int,\n        pPrimaryKey: *mut ::std::os::raw::c_int,\n        pAutoinc: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_load_extension(\n        db: *mut sqlite3,\n        zFile: *const ::std::os::raw::c_char,\n        zProc: *const ::std::os::raw::c_char,\n        pzErrMsg: *mut *mut ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_enable_load_extension(\n        db: *mut sqlite3,\n        onoff: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_reset_auto_extension();\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_module {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xCreate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3,\n            pAux: *mut ::std::os::raw::c_void,\n            argc: ::std::os::raw::c_int,\n            argv: *const *const ::std::os::raw::c_char,\n            ppVTab: *mut *mut sqlite3_vtab,\n            arg2: *mut *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xConnect: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3,\n            pAux: *mut ::std::os::raw::c_void,\n            argc: ::std::os::raw::c_int,\n            argv: *const *const ::std::os::raw::c_char,\n            ppVTab: *mut *mut sqlite3_vtab,\n            arg2: *mut *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xBestIndex: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: *mut sqlite3_index_info,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDisconnect: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDestroy: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xOpen: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            ppCursor: *mut *mut sqlite3_vtab_cursor,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xClose: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vtab_cursor) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFilter: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab_cursor,\n            idxNum: ::std::os::raw::c_int,\n            idxStr: *const ::std::os::raw::c_char,\n            argc: ::std::os::raw::c_int,\n            argv: *mut *mut sqlite3_value,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xNext: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vtab_cursor) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xEof: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vtab_cursor) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xColumn: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab_cursor,\n            arg2: *mut sqlite3_context,\n            arg3: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRowid: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab_cursor,\n            pRowid: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xUpdate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab,\n            arg2: ::std::os::raw::c_int,\n            arg3: *mut *mut sqlite3_value,\n            arg4: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xBegin: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSync: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xCommit: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRollback: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFindFunction: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVtab: *mut sqlite3_vtab,\n            nArg: ::std::os::raw::c_int,\n            zName: *const ::std::os::raw::c_char,\n            pxFunc: *mut ::std::option::Option\u003c\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: ::std::os::raw::c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            \u003e,\n            ppArg: *mut *mut ::std::os::raw::c_void,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRename: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVtab: *mut sqlite3_vtab,\n            zNew: *const ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSavepoint: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRelease: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRollbackTo: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShadowName: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *const ::std::os::raw::c_char) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xIntegrity: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            zSchema: *const ::std::os::raw::c_char,\n            zTabName: *const ::std::os::raw::c_char,\n            mFlags: ::std::os::raw::c_int,\n            pzErr: *mut *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_info {\n    pub nConstraint: ::std::os::raw::c_int,\n    pub aConstraint: *mut sqlite3_index_constraint,\n    pub nOrderBy: ::std::os::raw::c_int,\n    pub aOrderBy: *mut sqlite3_index_orderby,\n    pub aConstraintUsage: *mut sqlite3_index_constraint_usage,\n    pub idxNum: ::std::os::raw::c_int,\n    pub idxStr: *mut ::std::os::raw::c_char,\n    pub needToFreeIdxStr: ::std::os::raw::c_int,\n    pub orderByConsumed: ::std::os::raw::c_int,\n    pub estimatedCost: f64,\n    pub estimatedRows: sqlite3_int64,\n    pub idxFlags: ::std::os::raw::c_int,\n    pub colUsed: sqlite3_uint64,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_constraint {\n    pub iColumn: ::std::os::raw::c_int,\n    pub op: ::std::os::raw::c_uchar,\n    pub usable: ::std::os::raw::c_uchar,\n    pub iTermOffset: ::std::os::raw::c_int,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_orderby {\n    pub iColumn: ::std::os::raw::c_int,\n    pub desc: ::std::os::raw::c_uchar,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_constraint_usage {\n    pub argvIndex: ::std::os::raw::c_int,\n    pub omit: ::std::os::raw::c_uchar,\n}\nextern \"C\" {\n    pub fn sqlite3_create_module_v2(\n        db: *mut sqlite3,\n        zName: *const ::std::os::raw::c_char,\n        p: *const sqlite3_module,\n        pClientData: *mut ::std::os::raw::c_void,\n        xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_drop_modules(\n        db: *mut sqlite3,\n        azKeep: *mut *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_vtab {\n    pub pModule: *const sqlite3_module,\n    pub nRef: ::std::os::raw::c_int,\n    pub zErrMsg: *mut ::std::os::raw::c_char,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_vtab_cursor {\n    pub pVtab: *mut sqlite3_vtab,\n}\nextern \"C\" {\n    pub fn sqlite3_declare_vtab(\n        arg1: *mut sqlite3,\n        zSQL: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_overload_function(\n        arg1: *mut sqlite3,\n        zFuncName: *const ::std::os::raw::c_char,\n        nArg: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_blob {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_blob_open(\n        arg1: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        zTable: *const ::std::os::raw::c_char,\n        zColumn: *const ::std::os::raw::c_char,\n        iRow: sqlite3_int64,\n        flags: ::std::os::raw::c_int,\n        ppBlob: *mut *mut sqlite3_blob,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_reopen(\n        arg1: *mut sqlite3_blob,\n        arg2: sqlite3_int64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_close(arg1: *mut sqlite3_blob) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_bytes(arg1: *mut sqlite3_blob) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_read(\n        arg1: *mut sqlite3_blob,\n        Z: *mut ::std::os::raw::c_void,\n        N: ::std::os::raw::c_int,\n        iOffset: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_write(\n        arg1: *mut sqlite3_blob,\n        z: *const ::std::os::raw::c_void,\n        n: ::std::os::raw::c_int,\n        iOffset: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vfs_find(zVfsName: *const ::std::os::raw::c_char) -\u003e *mut sqlite3_vfs;\n}\nextern \"C\" {\n    pub fn sqlite3_vfs_register(\n        arg1: *mut sqlite3_vfs,\n        makeDflt: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vfs_unregister(arg1: *mut sqlite3_vfs) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_alloc(arg1: ::std::os::raw::c_int) -\u003e *mut sqlite3_mutex;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_free(arg1: *mut sqlite3_mutex);\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_enter(arg1: *mut sqlite3_mutex);\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_try(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_leave(arg1: *mut sqlite3_mutex);\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_mutex_methods {\n    pub xMutexInit: ::std::option::Option\u003cunsafe extern \"C\" fn() -\u003e ::std::os::raw::c_int\u003e,\n    pub xMutexEnd: ::std::option::Option\u003cunsafe extern \"C\" fn() -\u003e ::std::os::raw::c_int\u003e,\n    pub xMutexAlloc: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: ::std::os::raw::c_int) -\u003e *mut sqlite3_mutex,\n    \u003e,\n    pub xMutexFree: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_mutex)\u003e,\n    pub xMutexEnter: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_mutex)\u003e,\n    pub xMutexTry: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xMutexLeave: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_mutex)\u003e,\n    pub xMutexHeld: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xMutexNotheld: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_held(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_notheld(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_mutex(arg1: *mut sqlite3) -\u003e *mut sqlite3_mutex;\n}\nextern \"C\" {\n    pub fn sqlite3_file_control(\n        arg1: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n        op: ::std::os::raw::c_int,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_test_control(op: ::std::os::raw::c_int, ...) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_keyword_count() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_keyword_name(\n        arg1: ::std::os::raw::c_int,\n        arg2: *mut *const ::std::os::raw::c_char,\n        arg3: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_keyword_check(\n        arg1: *const ::std::os::raw::c_char,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_str {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_str_new(arg1: *mut sqlite3) -\u003e *mut sqlite3_str;\n}\nextern \"C\" {\n    pub fn sqlite3_str_finish(arg1: *mut sqlite3_str) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_str_appendf(arg1: *mut sqlite3_str, zFormat: *const ::std::os::raw::c_char, ...);\n}\nextern \"C\" {\n    pub fn sqlite3_str_append(\n        arg1: *mut sqlite3_str,\n        zIn: *const ::std::os::raw::c_char,\n        N: ::std::os::raw::c_int,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_str_appendall(arg1: *mut sqlite3_str, zIn: *const ::std::os::raw::c_char);\n}\nextern \"C\" {\n    pub fn sqlite3_str_appendchar(\n        arg1: *mut sqlite3_str,\n        N: ::std::os::raw::c_int,\n        C: ::std::os::raw::c_char,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_str_reset(arg1: *mut sqlite3_str);\n}\nextern \"C\" {\n    pub fn sqlite3_str_errcode(arg1: *mut sqlite3_str) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_str_length(arg1: *mut sqlite3_str) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_str_value(arg1: *mut sqlite3_str) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_status(\n        op: ::std::os::raw::c_int,\n        pCurrent: *mut ::std::os::raw::c_int,\n        pHighwater: *mut ::std::os::raw::c_int,\n        resetFlag: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_status64(\n        op: ::std::os::raw::c_int,\n        pCurrent: *mut sqlite3_int64,\n        pHighwater: *mut sqlite3_int64,\n        resetFlag: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_status(\n        arg1: *mut sqlite3,\n        op: ::std::os::raw::c_int,\n        pCur: *mut ::std::os::raw::c_int,\n        pHiwtr: *mut ::std::os::raw::c_int,\n        resetFlg: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_status(\n        arg1: *mut sqlite3_stmt,\n        op: ::std::os::raw::c_int,\n        resetFlg: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache_page {\n    pub pBuf: *mut ::std::os::raw::c_void,\n    pub pExtra: *mut ::std::os::raw::c_void,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache_methods2 {\n    pub iVersion: ::std::os::raw::c_int,\n    pub pArg: *mut ::std::os::raw::c_void,\n    pub xInit: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShutdown: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    pub xCreate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            szPage: ::std::os::raw::c_int,\n            szExtra: ::std::os::raw::c_int,\n            bPurgeable: ::std::os::raw::c_int,\n        ) -\u003e *mut sqlite3_pcache,\n    \u003e,\n    pub xCachesize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, nCachesize: ::std::os::raw::c_int),\n    \u003e,\n    pub xPagecount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFetch: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            key: ::std::os::raw::c_uint,\n            createFlag: ::std::os::raw::c_int,\n        ) -\u003e *mut sqlite3_pcache_page,\n    \u003e,\n    pub xUnpin: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut sqlite3_pcache_page,\n            discard: ::std::os::raw::c_int,\n        ),\n    \u003e,\n    pub xRekey: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut sqlite3_pcache_page,\n            oldKey: ::std::os::raw::c_uint,\n            newKey: ::std::os::raw::c_uint,\n        ),\n    \u003e,\n    pub xTruncate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, iLimit: ::std::os::raw::c_uint),\n    \u003e,\n    pub xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_pcache)\u003e,\n    pub xShrink: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_pcache)\u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache_methods {\n    pub pArg: *mut ::std::os::raw::c_void,\n    pub xInit: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShutdown: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    pub xCreate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            szPage: ::std::os::raw::c_int,\n            bPurgeable: ::std::os::raw::c_int,\n        ) -\u003e *mut sqlite3_pcache,\n    \u003e,\n    pub xCachesize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, nCachesize: ::std::os::raw::c_int),\n    \u003e,\n    pub xPagecount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFetch: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            key: ::std::os::raw::c_uint,\n            createFlag: ::std::os::raw::c_int,\n        ) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xUnpin: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut ::std::os::raw::c_void,\n            discard: ::std::os::raw::c_int,\n        ),\n    \u003e,\n    pub xRekey: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut ::std::os::raw::c_void,\n            oldKey: ::std::os::raw::c_uint,\n            newKey: ::std::os::raw::c_uint,\n        ),\n    \u003e,\n    pub xTruncate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, iLimit: ::std::os::raw::c_uint),\n    \u003e,\n    pub xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_pcache)\u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_backup {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_backup_init(\n        pDest: *mut sqlite3,\n        zDestName: *const ::std::os::raw::c_char,\n        pSource: *mut sqlite3,\n        zSourceName: *const ::std::os::raw::c_char,\n    ) -\u003e *mut sqlite3_backup;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_step(\n        p: *mut sqlite3_backup,\n        nPage: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_finish(p: *mut sqlite3_backup) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_remaining(p: *mut sqlite3_backup) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_pagecount(p: *mut sqlite3_backup) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_unlock_notify(\n        pBlocked: *mut sqlite3,\n        xNotify: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                apArg: *mut *mut ::std::os::raw::c_void,\n                nArg: ::std::os::raw::c_int,\n            ),\n        \u003e,\n        pNotifyArg: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stricmp(\n        arg1: *const ::std::os::raw::c_char,\n        arg2: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_strnicmp(\n        arg1: *const ::std::os::raw::c_char,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_strglob(\n        zGlob: *const ::std::os::raw::c_char,\n        zStr: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_strlike(\n        zGlob: *const ::std::os::raw::c_char,\n        zStr: *const ::std::os::raw::c_char,\n        cEsc: ::std::os::raw::c_uint,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_log(\n        iErrCode: ::std::os::raw::c_int,\n        zFormat: *const ::std::os::raw::c_char,\n        ...\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_wal_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *mut sqlite3,\n                arg3: *const ::std::os::raw::c_char,\n                arg4: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_wal_autocheckpoint(\n        db: *mut sqlite3,\n        N: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_wal_checkpoint(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_wal_checkpoint_v2(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        eMode: ::std::os::raw::c_int,\n        pnLog: *mut ::std::os::raw::c_int,\n        pnCkpt: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_config(\n        arg1: *mut sqlite3,\n        op: ::std::os::raw::c_int,\n        ...\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_on_conflict(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_nochange(arg1: *mut sqlite3_context) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_collation(\n        arg1: *mut sqlite3_index_info,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_distinct(arg1: *mut sqlite3_index_info) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_in(\n        arg1: *mut sqlite3_index_info,\n        iCons: ::std::os::raw::c_int,\n        bHandle: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_in_first(\n        pVal: *mut sqlite3_value,\n        ppOut: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_in_next(\n        pVal: *mut sqlite3_value,\n        ppOut: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_rhs_value(\n        arg1: *mut sqlite3_index_info,\n        arg2: ::std::os::raw::c_int,\n        ppVal: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_scanstatus(\n        pStmt: *mut sqlite3_stmt,\n        idx: ::std::os::raw::c_int,\n        iScanStatusOp: ::std::os::raw::c_int,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_scanstatus_v2(\n        pStmt: *mut sqlite3_stmt,\n        idx: ::std::os::raw::c_int,\n        iScanStatusOp: ::std::os::raw::c_int,\n        flags: ::std::os::raw::c_int,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_scanstatus_reset(arg1: *mut sqlite3_stmt);\n}\nextern \"C\" {\n    pub fn sqlite3_db_cacheflush(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_hook(\n        db: *mut sqlite3,\n        xPreUpdate: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                db: *mut sqlite3,\n                op: ::std::os::raw::c_int,\n                zDb: *const ::std::os::raw::c_char,\n                zName: *const ::std::os::raw::c_char,\n                iKey1: sqlite3_int64,\n                iKey2: sqlite3_int64,\n            ),\n        \u003e,\n        arg1: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_old(\n        arg1: *mut sqlite3,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_count(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_depth(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_new(\n        arg1: *mut sqlite3,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_blobwrite(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_system_errno(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_snapshot {\n    pub hidden: [::std::os::raw::c_uchar; 48usize],\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_get(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        ppSnapshot: *mut *mut sqlite3_snapshot,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_open(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        pSnapshot: *mut sqlite3_snapshot,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_free(arg1: *mut sqlite3_snapshot);\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_cmp(\n        p1: *mut sqlite3_snapshot,\n        p2: *mut sqlite3_snapshot,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_recover(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_serialize(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        piSize: *mut sqlite3_int64,\n        mFlags: ::std::os::raw::c_uint,\n    ) -\u003e *mut ::std::os::raw::c_uchar;\n}\nextern \"C\" {\n    pub fn sqlite3_deserialize(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        pData: *mut ::std::os::raw::c_uchar,\n        szDb: sqlite3_int64,\n        szBuf: sqlite3_int64,\n        mFlags: ::std::os::raw::c_uint,\n    ) -\u003e ::std::os::raw::c_int;\n}\npub type sqlite3_rtree_dbl = f64;\nextern \"C\" {\n    pub fn sqlite3_rtree_geometry_callback(\n        db: *mut sqlite3,\n        zGeom: *const ::std::os::raw::c_char,\n        xGeom: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_rtree_geometry,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut sqlite3_rtree_dbl,\n                arg4: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pContext: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_rtree_geometry {\n    pub pContext: *mut ::std::os::raw::c_void,\n    pub nParam: ::std::os::raw::c_int,\n    pub aParam: *mut sqlite3_rtree_dbl,\n    pub pUser: *mut ::std::os::raw::c_void,\n    pub xDelUser: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n}\nextern \"C\" {\n    pub fn sqlite3_rtree_query_callback(\n        db: *mut sqlite3,\n        zQueryFunc: *const ::std::os::raw::c_char,\n        xQueryFunc: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(arg1: *mut sqlite3_rtree_query_info) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pContext: *mut ::std::os::raw::c_void,\n        xDestructor: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_rtree_query_info {\n    pub pContext: *mut ::std::os::raw::c_void,\n    pub nParam: ::std::os::raw::c_int,\n    pub aParam: *mut sqlite3_rtree_dbl,\n    pub pUser: *mut ::std::os::raw::c_void,\n    pub xDelUser: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    pub aCoord: *mut sqlite3_rtree_dbl,\n    pub anQueue: *mut ::std::os::raw::c_uint,\n    pub nCoord: ::std::os::raw::c_int,\n    pub iLevel: ::std::os::raw::c_int,\n    pub mxLevel: ::std::os::raw::c_int,\n    pub iRowid: sqlite3_int64,\n    pub rParentScore: sqlite3_rtree_dbl,\n    pub eParentWithin: ::std::os::raw::c_int,\n    pub eWithin: ::std::os::raw::c_int,\n    pub rScore: sqlite3_rtree_dbl,\n    pub apSqlParam: *mut *mut sqlite3_value,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_session {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_changeset_iter {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3session_create(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        ppSession: *mut *mut sqlite3_session,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_delete(pSession: *mut sqlite3_session);\n}\nextern \"C\" {\n    pub fn sqlite3session_object_config(\n        arg1: *mut sqlite3_session,\n        op: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_enable(\n        pSession: *mut sqlite3_session,\n        bEnable: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_indirect(\n        pSession: *mut sqlite3_session,\n        bIndirect: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_attach(\n        pSession: *mut sqlite3_session,\n        zTab: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_table_filter(\n        pSession: *mut sqlite3_session,\n        xFilter: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3session_changeset(\n        pSession: *mut sqlite3_session,\n        pnChangeset: *mut ::std::os::raw::c_int,\n        ppChangeset: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_changeset_size(pSession: *mut sqlite3_session) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3session_diff(\n        pSession: *mut sqlite3_session,\n        zFromDb: *const ::std::os::raw::c_char,\n        zTbl: *const ::std::os::raw::c_char,\n        pzErrMsg: *mut *mut ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_patchset(\n        pSession: *mut sqlite3_session,\n        pnPatchset: *mut ::std::os::raw::c_int,\n        ppPatchset: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_isempty(pSession: *mut sqlite3_session) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_memory_used(pSession: *mut sqlite3_session) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start(\n        pp: *mut *mut sqlite3_changeset_iter,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start_v2(\n        pp: *mut *mut sqlite3_changeset_iter,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n        flags: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_next(pIter: *mut sqlite3_changeset_iter) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_op(\n        pIter: *mut sqlite3_changeset_iter,\n        pzTab: *mut *const ::std::os::raw::c_char,\n        pnCol: *mut ::std::os::raw::c_int,\n        pOp: *mut ::std::os::raw::c_int,\n        pbIndirect: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_pk(\n        pIter: *mut sqlite3_changeset_iter,\n        pabPK: *mut *mut ::std::os::raw::c_uchar,\n        pnCol: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_old(\n        pIter: *mut sqlite3_changeset_iter,\n        iVal: ::std::os::raw::c_int,\n        ppValue: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_new(\n        pIter: *mut sqlite3_changeset_iter,\n        iVal: ::std::os::raw::c_int,\n        ppValue: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_conflict(\n        pIter: *mut sqlite3_changeset_iter,\n        iVal: ::std::os::raw::c_int,\n        ppValue: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_fk_conflicts(\n        pIter: *mut sqlite3_changeset_iter,\n        pnOut: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_finalize(pIter: *mut sqlite3_changeset_iter) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_invert(\n        nIn: ::std::os::raw::c_int,\n        pIn: *const ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_concat(\n        nA: ::std::os::raw::c_int,\n        pA: *mut ::std::os::raw::c_void,\n        nB: ::std::os::raw::c_int,\n        pB: *mut ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_upgrade(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        nIn: ::std::os::raw::c_int,\n        pIn: *const ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_changegroup {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_new(pp: *mut *mut sqlite3_changegroup) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_schema(\n        arg1: *mut sqlite3_changegroup,\n        arg2: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_add(\n        arg1: *mut sqlite3_changegroup,\n        nData: ::std::os::raw::c_int,\n        pData: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_add_change(\n        arg1: *mut sqlite3_changegroup,\n        arg2: *mut sqlite3_changeset_iter,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_output(\n        arg1: *mut sqlite3_changegroup,\n        pnData: *mut ::std::os::raw::c_int,\n        ppData: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_delete(arg1: *mut sqlite3_changegroup);\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply(\n        db: *mut sqlite3,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        xConflict: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply_v2(\n        db: *mut sqlite3,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        xConflict: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n        ppRebase: *mut *mut ::std::os::raw::c_void,\n        pnRebase: *mut ::std::os::raw::c_int,\n        flags: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_rebaser {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_create(ppNew: *mut *mut sqlite3_rebaser) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_configure(\n        arg1: *mut sqlite3_rebaser,\n        nRebase: ::std::os::raw::c_int,\n        pRebase: *const ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_rebase(\n        arg1: *mut sqlite3_rebaser,\n        nIn: ::std::os::raw::c_int,\n        pIn: *const ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_delete(p: *mut sqlite3_rebaser);\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply_strm(\n        db: *mut sqlite3,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        xConflict: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply_v2_strm(\n        db: *mut sqlite3,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        xConflict: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n        ppRebase: *mut *mut ::std::os::raw::c_void,\n        pnRebase: *mut ::std::os::raw::c_int,\n        flags: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_concat_strm(\n        xInputA: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pInA: *mut ::std::os::raw::c_void,\n        xInputB: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pInB: *mut ::std::os::raw::c_void,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_invert_strm(\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start_strm(\n        pp: *mut *mut sqlite3_changeset_iter,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start_v2_strm(\n        pp: *mut *mut sqlite3_changeset_iter,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n        flags: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_changeset_strm(\n        pSession: *mut sqlite3_session,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_patchset_strm(\n        pSession: *mut sqlite3_session,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_add_strm(\n        arg1: *mut sqlite3_changegroup,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_output_strm(\n        arg1: *mut sqlite3_changegroup,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_rebase_strm(\n        pRebaser: *mut sqlite3_rebaser,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_config(\n        op: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5Context {\n    _unused: [u8; 0],\n}\npub type fts5_extension_function = ::std::option::Option\u003c\n    unsafe extern \"C\" fn(\n        pApi: *const Fts5ExtensionApi,\n        pFts: *mut Fts5Context,\n        pCtx: *mut sqlite3_context,\n        nVal: ::std::os::raw::c_int,\n        apVal: *mut *mut sqlite3_value,\n    ),\n\u003e;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5PhraseIter {\n    pub a: *const ::std::os::raw::c_uchar,\n    pub b: *const ::std::os::raw::c_uchar,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5ExtensionApi {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xUserData: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut Fts5Context) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xColumnCount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut Fts5Context) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRowCount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pnRow: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xColumnTotalSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iCol: ::std::os::raw::c_int,\n            pnToken: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xTokenize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pText: *const ::std::os::raw::c_char,\n            nText: ::std::os::raw::c_int,\n            pCtx: *mut ::std::os::raw::c_void,\n            xToken: ::std::option::Option\u003c\n                unsafe extern \"C\" fn(\n                    arg1: *mut ::std::os::raw::c_void,\n                    arg2: ::std::os::raw::c_int,\n                    arg3: *const ::std::os::raw::c_char,\n                    arg4: ::std::os::raw::c_int,\n                    arg5: ::std::os::raw::c_int,\n                    arg6: ::std::os::raw::c_int,\n                ) -\u003e ::std::os::raw::c_int,\n            \u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xPhraseCount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut Fts5Context) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xPhraseSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xInstCount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pnInst: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xInst: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iIdx: ::std::os::raw::c_int,\n            piPhrase: *mut ::std::os::raw::c_int,\n            piCol: *mut ::std::os::raw::c_int,\n            piOff: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRowid:\n        ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut Fts5Context) -\u003e sqlite3_int64\u003e,\n    pub xColumnText: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iCol: ::std::os::raw::c_int,\n            pz: *mut *const ::std::os::raw::c_char,\n            pn: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xColumnSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iCol: ::std::os::raw::c_int,\n            pnToken: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xQueryPhrase: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            pUserData: *mut ::std::os::raw::c_void,\n            arg2: ::std::option::Option\u003c\n                unsafe extern \"C\" fn(\n                    arg1: *const Fts5ExtensionApi,\n                    arg2: *mut Fts5Context,\n                    arg3: *mut ::std::os::raw::c_void,\n                ) -\u003e ::std::os::raw::c_int,\n            \u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSetAuxdata: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pAux: *mut ::std::os::raw::c_void,\n            xDelete: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xGetAuxdata: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            bClear: ::std::os::raw::c_int,\n        ) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xPhraseFirst: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            arg2: *mut Fts5PhraseIter,\n            arg3: *mut ::std::os::raw::c_int,\n            arg4: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xPhraseNext: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            arg2: *mut Fts5PhraseIter,\n            piCol: *mut ::std::os::raw::c_int,\n            piOff: *mut ::std::os::raw::c_int,\n        ),\n    \u003e,\n    pub xPhraseFirstColumn: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            arg2: *mut Fts5PhraseIter,\n            arg3: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xPhraseNextColumn: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            arg2: *mut Fts5PhraseIter,\n            piCol: *mut ::std::os::raw::c_int,\n        ),\n    \u003e,\n    pub xQueryToken: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            iToken: ::std::os::raw::c_int,\n            ppToken: *mut *const ::std::os::raw::c_char,\n            pnToken: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xInstToken: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iIdx: ::std::os::raw::c_int,\n            iToken: ::std::os::raw::c_int,\n            arg2: *mut *const ::std::os::raw::c_char,\n            arg3: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5Tokenizer {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct fts5_tokenizer {\n    pub xCreate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            azArg: *mut *const ::std::os::raw::c_char,\n            nArg: ::std::os::raw::c_int,\n            ppOut: *mut *mut Fts5Tokenizer,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDelete: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut Fts5Tokenizer)\u003e,\n    pub xTokenize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Tokenizer,\n            pCtx: *mut ::std::os::raw::c_void,\n            flags: ::std::os::raw::c_int,\n            pText: *const ::std::os::raw::c_char,\n            nText: ::std::os::raw::c_int,\n            xToken: ::std::option::Option\u003c\n                unsafe extern \"C\" fn(\n                    pCtx: *mut ::std::os::raw::c_void,\n                    tflags: ::std::os::raw::c_int,\n                    pToken: *const ::std::os::raw::c_char,\n                    nToken: ::std::os::raw::c_int,\n                    iStart: ::std::os::raw::c_int,\n                    iEnd: ::std::os::raw::c_int,\n                ) -\u003e ::std::os::raw::c_int,\n            \u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct fts5_api {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xCreateTokenizer: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pApi: *mut fts5_api,\n            zName: *const ::std::os::raw::c_char,\n            pUserData: *mut ::std::os::raw::c_void,\n            pTokenizer: *mut fts5_tokenizer,\n            xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFindTokenizer: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pApi: *mut fts5_api,\n            zName: *const ::std::os::raw::c_char,\n            ppUserData: *mut *mut ::std::os::raw::c_void,\n            pTokenizer: *mut fts5_tokenizer,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xCreateFunction: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pApi: *mut fts5_api,\n            zName: *const ::std::os::raw::c_char,\n            pUserData: *mut ::std::os::raw::c_void,\n            xFunction: fts5_extension_function,\n            xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","target-cov","debug","build","serde-f7d0cdb76999b6da","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private226 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private226 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","target-cov","debug","build","serde_core-b3e3c7d16bccdbb0","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private226 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","target-cov","debug","build","typenum-8bcb70e47c3b8750","out","tests.rs"],"content":"\nuse typenum::*;\nuse core::ops::*;\nuse core::cmp::Ordering;\n\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Sub_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0SubU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_0() {\n    type A = UTerm;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_PartialDiv_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU3 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU4 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU5 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU2 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU2 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U24 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU24\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU3 as Unsigned\u003e::to_u64(), \u003cU24 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU3 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U27 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU27\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU3 as Unsigned\u003e::to_u64(), \u003cU27 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U48 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU48\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU4 as Unsigned\u003e::to_u64(), \u003cU48 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU4 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U81 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU81\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU4 as Unsigned\u003e::to_u64(), \u003cU81 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U96 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU96\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU5 as Unsigned\u003e::to_u64(), \u003cU96 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU5 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU5 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U243 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU243\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU5 as Unsigned\u003e::to_u64(), \u003cU243 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU1 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU3 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU3 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU3 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU4 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U256 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU256\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU4 as Unsigned\u003e::to_u64(), \u003cU256 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U128 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU128\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU5 as Unsigned\u003e::to_u64(), \u003cU128 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU5 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU5 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1024 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU5 as Unsigned\u003e::to_u64(), \u003cU1024 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU1 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU2 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU2 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU2 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U40 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU40\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU3 as Unsigned\u003e::to_u64(), \u003cU40 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU3 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU3 as Unsigned\u003e::to_u64(), \u003cU125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U80 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU80\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU4 as Unsigned\u003e::to_u64(), \u003cU80 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU4 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU4 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U625 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU625\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU4 as Unsigned\u003e::to_u64(), \u003cU625 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U160 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU160\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU5 as Unsigned\u003e::to_u64(), \u003cU160 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU5 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU5 as Unsigned\u003e::to_u64(), \u003cU3125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Add_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Sub_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Min_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP3 as Integer\u003e::to_i64(), \u003cN125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP5 as Integer\u003e::to_i64(), \u003cN3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Add_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Sub_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Min_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N64 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN64\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP3 as Integer\u003e::to_i64(), \u003cN64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1024 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP5 as Integer\u003e::to_i64(), \u003cN1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Add_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Sub_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Min_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N27 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN27\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP3 as Integer\u003e::to_i64(), \u003cN27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N243 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN243\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP5 as Integer\u003e::to_i64(), \u003cN243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Add_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Sub_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Min_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N32 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN32\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP5 as Integer\u003e::to_i64(), \u003cN32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Add_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Sub_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Min_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Add_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Sub_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Gcd_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow__0() {\n    type A = Z0;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp__0() {\n    type A = Z0;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0Cmp_0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Add_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Sub_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Max_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Add_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Sub_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Max_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P32 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP32\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP5 as Integer\u003e::to_i64(), \u003cP32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Add_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Sub_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Max_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P27 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP27\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP3 as Integer\u003e::to_i64(), \u003cP27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P243 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP243\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP5 as Integer\u003e::to_i64(), \u003cP243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Add_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Sub_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Max_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P64 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP64\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP3 as Integer\u003e::to_i64(), \u003cP64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1024 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP5 as Integer\u003e::to_i64(), \u003cP1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Add_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Sub_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Max_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP3 as Integer\u003e::to_i64(), \u003cP125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP5 as Integer\u003e::to_i64(), \u003cP3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cNegN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cNegN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cNegN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cNegN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Neg() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cNegN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Abs() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Neg() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Neg_0 = \u003c\u003cA as Neg\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cNeg_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Abs() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Abs_0 = \u003c\u003cA as Abs\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cAbs_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Neg() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n    assert_eq!(\u003cNegP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Abs() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n    assert_eq!(\u003cNegP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n    assert_eq!(\u003cNegP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n    assert_eq!(\u003cNegP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n    assert_eq!(\u003cNegP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","tests","basic_coverage.rs"],"content":"//! Basic coverage tests for Rust engine components\n//! These tests provide basic coverage measurement without complex protobuf interactions\n\nuse workspace_qdrant_daemon::config::*;\nuse workspace_qdrant_daemon::error::*;\n\n#[test]\nfn test_daemon_config_creation() {\n    let config = DaemonConfig::default();\n    assert_eq!(config.server.host, \"127.0.0.1\");\n    assert_eq!(config.server.port, 50051);\n    assert_eq!(config.database.max_connections, 10);\n    assert_eq!(config.qdrant.url, \"http://localhost:6333\");\n}\n\n#[test]\nfn test_server_config_creation() {\n    let config = ServerConfig {\n        host: \"0.0.0.0\".to_string(),\n        port: 8080,\n        max_connections: 500,\n        connection_timeout_secs: 60,\n        request_timeout_secs: 300,\n        enable_tls: true,\n    };\n\n    assert_eq!(config.host, \"0.0.0.0\");\n    assert_eq!(config.port, 8080);\n    assert!(config.enable_tls);\n}\n\n#[test]\nfn test_database_config_creation() {\n    let config = DatabaseConfig {\n        sqlite_path: \"/tmp/test.db\".to_string(),\n        max_connections: 20,\n        connection_timeout_secs: 45,\n        enable_wal: false,\n    };\n\n    assert_eq!(config.sqlite_path, \"/tmp/test.db\");\n    assert_eq!(config.max_connections, 20);\n    assert!(!config.enable_wal);\n}\n\n#[test]\nfn test_qdrant_config_creation() {\n    let collection_config = CollectionConfig {\n        vector_size: 768,\n        distance_metric: \"Euclidean\".to_string(),\n        enable_indexing: false,\n        replication_factor: 2,\n        shard_number: 3,\n    };\n\n    let config = QdrantConfig {\n        url: \"http://remote:6333\".to_string(),\n        api_key: Some(\"test-key\".to_string()),\n        timeout_secs: 60,\n        max_retries: 5,\n        default_collection: collection_config,\n    };\n\n    assert_eq!(config.url, \"http://remote:6333\");\n    assert_eq!(config.api_key, Some(\"test-key\".to_string()));\n    assert_eq!(config.max_retries, 5);\n    assert_eq!(config.default_collection.vector_size, 768);\n}\n\n#[test]\nfn test_processing_config_creation() {\n    let config = ProcessingConfig {\n        max_concurrent_tasks: 8,\n        default_chunk_size: 2000,\n        default_chunk_overlap: 400,\n        max_file_size_bytes: 200_000_000,\n        supported_extensions: vec![\"rs\".to_string(), \"py\".to_string()],\n        enable_lsp: false,\n        lsp_timeout_secs: 20,\n    };\n\n    assert_eq!(config.max_concurrent_tasks, 8);\n    assert_eq!(config.default_chunk_size, 2000);\n    assert!(!config.enable_lsp);\n    assert!(config.supported_extensions.contains(\u0026\"rs\".to_string()));\n}\n\n#[test]\nfn test_file_watcher_config_creation() {\n    let config = FileWatcherConfig {\n        enabled: true,\n        debounce_ms: 1000,\n        max_watched_dirs: 50,\n        ignore_patterns: vec![\"*.log\".to_string(), \"target/**\".to_string()],\n        recursive: false,\n    };\n\n    assert!(config.enabled);\n    assert_eq!(config.debounce_ms, 1000);\n    assert!(!config.recursive);\n    assert!(config.ignore_patterns.contains(\u0026\"*.log\".to_string()));\n}\n\n#[test]\nfn test_metrics_config_creation() {\n    let config = MetricsConfig {\n        enabled: false,\n        collection_interval_secs: 120,\n        retention_days: 60,\n        enable_prometheus: false,\n        prometheus_port: 9091,\n    };\n\n    assert!(!config.enabled);\n    assert_eq!(config.collection_interval_secs, 120);\n    assert_eq!(config.retention_days, 60);\n    assert!(!config.enable_prometheus);\n}\n\n#[test]\nfn test_logging_config_creation() {\n    let config = LoggingConfig {\n        level: \"debug\".to_string(),\n        file_path: Some(\"/custom/log.log\".to_string()),\n        json_format: true,\n        max_file_size_mb: 200,\n        max_files: 10,\n    };\n\n    assert_eq!(config.level, \"debug\");\n    assert_eq!(config.file_path, Some(\"/custom/log.log\".to_string()));\n    assert!(config.json_format);\n    assert_eq!(config.max_file_size_mb, 200);\n}\n\n#[test]\nfn test_config_validation_valid() {\n    let config = DaemonConfig::default();\n    assert!(config.validate().is_ok());\n}\n\n#[test]\nfn test_config_validation_invalid_port() {\n    let mut config = DaemonConfig::default();\n    config.server.port = 0;\n\n    let result = config.validate();\n    assert!(result.is_err());\n\n    match result {\n        Err(DaemonError::Config(_)) =\u003e {\n            // Expected error type\n        },\n        _ =\u003e panic!(\"Expected Config error for invalid port\"),\n    }\n}\n\n#[test]\nfn test_config_validation_empty_qdrant_url() {\n    let mut config = DaemonConfig::default();\n    config.qdrant.url = String::new();\n\n    let result = config.validate();\n    assert!(result.is_err());\n\n    match result {\n        Err(DaemonError::Config(_)) =\u003e {\n            // Expected error type\n        },\n        _ =\u003e panic!(\"Expected Config error for empty Qdrant URL\"),\n    }\n}\n\n#[test]\nfn test_config_validation_empty_database_path() {\n    let mut config = DaemonConfig::default();\n    config.database.sqlite_path = String::new();\n\n    let result = config.validate();\n    assert!(result.is_err());\n\n    match result {\n        Err(DaemonError::Config(_)) =\u003e {\n            // Expected error type\n        },\n        _ =\u003e panic!(\"Expected Config error for empty database path\"),\n    }\n}\n\n#[test]\nfn test_config_validation_zero_chunk_size() {\n    let mut config = DaemonConfig::default();\n    config.processing.default_chunk_size = 0;\n\n    let result = config.validate();\n    assert!(result.is_err());\n\n    match result {\n        Err(DaemonError::Config(_)) =\u003e {\n            // Expected error type\n        },\n        _ =\u003e panic!(\"Expected Config error for zero chunk size\"),\n    }\n}\n\n#[test]\nfn test_config_clone_debug() {\n    let config = DaemonConfig::default();\n    let cloned = config.clone();\n\n    assert_eq!(config.server.host, cloned.server.host);\n    assert_eq!(config.qdrant.url, cloned.qdrant.url);\n\n    // Test debug format\n    let debug_str = format!(\"{:?}\", config);\n    assert!(debug_str.contains(\"DaemonConfig\"));\n    assert!(debug_str.contains(\"ServerConfig\"));\n}\n\n#[test]\nfn test_collection_config_standalone() {\n    let collection_config = CollectionConfig {\n        vector_size: 768,\n        distance_metric: \"Dot\".to_string(),\n        enable_indexing: false,\n        replication_factor: 3,\n        shard_number: 2,\n    };\n\n    let debug_str = format!(\"{:?}\", collection_config);\n    assert!(debug_str.contains(\"CollectionConfig\"));\n    assert!(debug_str.contains(\"768\"));\n    assert!(debug_str.contains(\"Dot\"));\n\n    let cloned = collection_config.clone();\n    assert_eq!(collection_config.vector_size, cloned.vector_size);\n    assert_eq!(collection_config.distance_metric, cloned.distance_metric);\n}\n\n#[test]\nfn test_error_types() {\n    // Test that we can create different error types\n    let config_error = DaemonError::Config(\n        config::ConfigError::Message(\"Test config error\".to_string())\n    );\n\n    let io_error = DaemonError::Io(std::io::Error::new(\n        std::io::ErrorKind::NotFound,\n        \"Test IO error\"\n    ));\n\n    // Test that they can be formatted\n    let config_msg = format!(\"{}\", config_error);\n    assert!(config_msg.contains(\"Configuration error\"));\n\n    let io_msg = format!(\"{}\", io_error);\n    assert!(io_msg.contains(\"IO error\"));\n}\n\n#[test]\nfn test_config_structs_are_send_sync() {\n    fn assert_send_sync\u003cT: Send + Sync\u003e() {}\n\n    assert_send_sync::\u003cDaemonConfig\u003e();\n    assert_send_sync::\u003cServerConfig\u003e();\n    assert_send_sync::\u003cDatabaseConfig\u003e();\n    assert_send_sync::\u003cQdrantConfig\u003e();\n    assert_send_sync::\u003cCollectionConfig\u003e();\n    assert_send_sync::\u003cProcessingConfig\u003e();\n    assert_send_sync::\u003cFileWatcherConfig\u003e();\n    assert_send_sync::\u003cMetricsConfig\u003e();\n    assert_send_sync::\u003cLoggingConfig\u003e();\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","tests","daemon_coverage.rs"],"content":"//! Additional test coverage for daemon modules\n//! Targeting daemon/core.rs, daemon/processing.rs, daemon/state.rs, daemon/watcher.rs\n\nuse workspace_qdrant_daemon::config::*;\nuse workspace_qdrant_daemon::daemon::core::*;\nuse workspace_qdrant_daemon::daemon::processing::*;\nuse workspace_qdrant_daemon::daemon::state::*;\nuse workspace_qdrant_daemon::daemon::watcher::*;\nuse std::sync::Arc;\nuse tempfile::TempDir;\nuse sqlx::Row;\n\n// ================================\n// DAEMON CORE TESTS\n// ================================\n\n#[test]\nfn test_daemon_core_initialization() {\n    let core = DaemonCore::new();\n    assert_eq!(std::mem::size_of::\u003cDaemonCore\u003e(), 0);\n\n    // Test debug representation\n    let debug_str = format!(\"{:?}\", core);\n    assert!(debug_str.contains(\"DaemonCore\"));\n}\n\n#[test]\nfn test_system_info_creation() {\n    let info = SystemInfo {\n        cpu_count: 8,\n        memory_total: 16 * 1024 * 1024 * 1024, // 16GB\n        hostname: \"test-machine\".to_string(),\n    };\n\n    assert_eq!(info.cpu_count, 8);\n    assert_eq!(info.memory_total, 16 * 1024 * 1024 * 1024);\n    assert_eq!(info.hostname, \"test-machine\");\n\n    // Test clone implementation\n    let cloned = info.clone();\n    assert_eq!(info.cpu_count, cloned.cpu_count);\n    assert_eq!(info.memory_total, cloned.memory_total);\n    assert_eq!(info.hostname, cloned.hostname);\n}\n\n#[test]\nfn test_system_info_debug_formatting() {\n    let info = SystemInfo {\n        cpu_count: 4,\n        memory_total: 8_000_000_000,\n        hostname: \"debug-host\".to_string(),\n    };\n\n    let debug_str = format!(\"{:?}\", info);\n    assert!(debug_str.contains(\"SystemInfo\"));\n    assert!(debug_str.contains(\"4\"));\n    assert!(debug_str.contains(\"8000000000\"));\n    assert!(debug_str.contains(\"debug-host\"));\n}\n\n#[test]\nfn test_get_system_info_success() {\n    let result = DaemonCore::get_system_info();\n    assert!(result.is_ok());\n\n    let info = result.unwrap();\n    assert!(info.cpu_count \u003e 0);\n    assert!(info.memory_total \u003e 0);\n    assert!(!info.hostname.is_empty());\n}\n\n// Note: get_total_memory is private, so we can't test it directly\n\n#[test]\nfn test_daemon_core_multiple_instances() {\n    let core1 = DaemonCore::new();\n    let core2 = DaemonCore::new();\n\n    // Both should be identical (unit struct)\n    assert_eq!(std::mem::size_of_val(\u0026core1), std::mem::size_of_val(\u0026core2));\n    assert_eq!(std::mem::size_of_val(\u0026core1), 0);\n}\n\n#[test]\nfn test_system_info_send_sync() {\n    fn assert_send\u003cT: Send\u003e() {}\n    fn assert_sync\u003cT: Sync\u003e() {}\n\n    assert_send::\u003cSystemInfo\u003e();\n    assert_sync::\u003cSystemInfo\u003e();\n}\n\n// ================================\n// DOCUMENT PROCESSOR TESTS\n// ================================\n\nfn create_test_configs() -\u003e (ProcessingConfig, QdrantConfig) {\n    let processing_config = ProcessingConfig {\n        max_concurrent_tasks: 3,\n        default_chunk_size: 1500,\n        default_chunk_overlap: 300,\n        max_file_size_bytes: 2 * 1024 * 1024,\n        supported_extensions: vec![\"txt\".to_string(), \"md\".to_string(), \"rs\".to_string()],\n        enable_lsp: true,\n        lsp_timeout_secs: 15,\n    };\n\n    let qdrant_config = QdrantConfig {\n        url: \"http://localhost:6333\".to_string(),\n        api_key: Some(\"test-api-key\".to_string()),\n        timeout_secs: 45,\n        max_retries: 5,\n        default_collection: CollectionConfig {\n            vector_size: 512,\n            distance_metric: \"Cosine\".to_string(),\n            enable_indexing: true,\n            replication_factor: 2,\n            shard_number: 2,\n        },\n    };\n\n    (processing_config, qdrant_config)\n}\n\nasync fn create_test_processor() -\u003e Arc\u003cDocumentProcessor\u003e {\n    let (processing_config, qdrant_config) = create_test_configs();\n    Arc::new(DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config).await.unwrap())\n}\n\n#[tokio::test]\nasync fn test_document_processor_creation() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let result = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config).await;\n\n    assert!(result.is_ok());\n    let processor = result.unwrap();\n\n    assert_eq!(processor.config().max_concurrent_tasks, 3);\n    assert_eq!(processor.config().default_chunk_size, 1500);\n    assert_eq!(processor.config().default_chunk_overlap, 300);\n    assert_eq!(processor.config().max_file_size_bytes, 2 * 1024 * 1024);\n    assert!(processor.config().enable_lsp);\n    assert_eq!(processor.config().lsp_timeout_secs, 15);\n    assert_eq!(processor.config().supported_extensions.len(), 3);\n    assert!(processor.config().supported_extensions.contains(\u0026\"rs\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_document_processor_config_values() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config).await.unwrap();\n\n    // Test that config values match what we set\n    assert_eq!(processor.config().max_concurrent_tasks, 3);\n    assert_eq!(processor.config().default_chunk_size, 1500);\n    assert_eq!(processor.config().default_chunk_overlap, 300);\n    assert_eq!(processor.config().max_file_size_bytes, 2 * 1024 * 1024);\n    assert!(processor.config().enable_lsp);\n    assert_eq!(processor.config().lsp_timeout_secs, 15);\n    assert!(processor.config().supported_extensions.contains(\u0026\"txt\".to_string()));\n    assert!(processor.config().supported_extensions.contains(\u0026\"rs\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_document_processor_debug_format() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config).await.unwrap();\n\n    let debug_str = format!(\"{:?}\", processor);\n    assert!(debug_str.contains(\"DocumentProcessor\"));\n    assert!(!debug_str.is_empty());\n}\n\n#[tokio::test]\nasync fn test_document_processing_single_file() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config).await.unwrap();\n\n    let result = processor.process_document(\"test_file.txt\").await;\n    assert!(result.is_ok());\n\n    let document_id = result.unwrap();\n    assert_eq!(document_id.len(), 36); // UUID v4 length\n    assert!(document_id.contains('-'));\n}\n\n#[tokio::test]\nasync fn test_document_processing_different_extensions() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config).await.unwrap();\n\n    let test_files = vec![\n        \"document.txt\",\n        \"readme.md\",\n        \"script.rs\",\n        \"config.yaml\",\n        \"data.json\",\n    ];\n\n    for file in test_files {\n        let result = processor.process_document(file).await;\n        assert!(result.is_ok(), \"Failed to process file: {}\", file);\n\n        let document_id = result.unwrap();\n        assert_eq!(document_id.len(), 36);\n    }\n}\n\n#[tokio::test]\nasync fn test_document_processor_config_access() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config).await.unwrap();\n\n    let config = processor.config();\n    assert_eq!(config.max_concurrent_tasks, 3);\n    assert!(config.supported_extensions.contains(\u0026\"txt\".to_string()));\n    assert!(config.enable_lsp);\n}\n\n// ================================\n// DAEMON STATE TESTS\n// ================================\n\nfn create_test_database_config() -\u003e DatabaseConfig {\n    DatabaseConfig {\n        sqlite_path: \"sqlite::memory:\".to_string(),\n        max_connections: 3,\n        connection_timeout_secs: 10,\n        enable_wal: false,\n    }\n}\n\n#[tokio::test]\nasync fn test_daemon_state_creation() {\n    let config = create_test_database_config();\n    let result = DaemonState::new(\u0026config).await;\n\n    assert!(result.is_ok());\n    let state = result.unwrap();\n\n    // Test debug formatting\n    let debug_str = format!(\"{:?}\", state);\n    assert!(debug_str.contains(\"DaemonState\"));\n}\n\n#[tokio::test]\nasync fn test_daemon_state_pool_access() {\n    let config = create_test_database_config();\n    let state = DaemonState::new(\u0026config).await.unwrap();\n\n    let pool = state.pool();\n    assert!(!pool.is_closed());\n}\n\n#[tokio::test]\nasync fn test_daemon_state_health_check() {\n    let config = create_test_database_config();\n    let state = DaemonState::new(\u0026config).await.unwrap();\n\n    let result = state.health_check().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_daemon_state_invalid_path() {\n    let config = DatabaseConfig {\n        sqlite_path: \"/invalid/nonexistent/path/test.db\".to_string(),\n        max_connections: 1,\n        connection_timeout_secs: 5,\n        enable_wal: false,\n    };\n\n    let result = DaemonState::new(\u0026config).await;\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_daemon_state_migrations() {\n    let config = create_test_database_config();\n    let state = DaemonState::new(\u0026config).await.unwrap();\n\n    // Check that tables were created\n    let tables_query = \"SELECT name FROM sqlite_master WHERE type='table'\";\n    let rows = sqlx::query(tables_query)\n        .fetch_all(state.pool())\n        .await\n        .unwrap();\n\n    let table_names: Vec\u003cString\u003e = rows.iter()\n        .map(|row| row.get::\u003cString, _\u003e(\"name\"))\n        .collect();\n\n    assert!(table_names.contains(\u0026\"projects\".to_string()));\n    assert!(table_names.contains(\u0026\"collections\".to_string()));\n    assert!(table_names.contains(\u0026\"processing_operations\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_daemon_state_multiple_instances() {\n    let config1 = create_test_database_config();\n    let config2 = create_test_database_config();\n\n    let state1 = DaemonState::new(\u0026config1).await.unwrap();\n    let state2 = DaemonState::new(\u0026config2).await.unwrap();\n\n    // Both should work independently\n    state1.health_check().await.unwrap();\n    state2.health_check().await.unwrap();\n}\n\n// ================================\n// FILE WATCHER TESTS\n// ================================\n\nfn create_test_watcher_config(enabled: bool) -\u003e FileWatcherConfig {\n    FileWatcherConfig {\n        enabled,\n        debounce_ms: 500,\n        max_watched_dirs: 20,\n        ignore_patterns: vec![\n            \"*.tmp\".to_string(),\n            \"*.log\".to_string(),\n            \"target/**\".to_string(),\n            \".git/**\".to_string(),\n        ],\n        recursive: true,\n    }\n}\n\n#[tokio::test]\nasync fn test_file_watcher_creation_enabled() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n\n    let result = FileWatcher::new(\u0026config, processor).await;\n    assert!(result.is_ok());\n\n    let _watcher = result.unwrap();\n    // Note: config fields are private, so we just test creation success\n}\n\n#[tokio::test]\nasync fn test_file_watcher_creation_disabled() {\n    let config = create_test_watcher_config(false);\n    let processor = create_test_processor().await;\n\n    let result = FileWatcher::new(\u0026config, processor).await;\n    assert!(result.is_ok());\n\n    let _watcher = result.unwrap();\n    // Note: config fields are private, so we just test creation success\n}\n\n#[tokio::test]\nasync fn test_file_watcher_start_enabled() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n    let result = watcher.start().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_file_watcher_start_disabled() {\n    let config = create_test_watcher_config(false);\n    let processor = create_test_processor().await;\n    let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n    let result = watcher.start().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_file_watcher_stop() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n    watcher.start().await.unwrap();\n    let result = watcher.stop().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_file_watcher_directory_operations() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n    let temp_dir = TempDir::new().unwrap();\n\n    // Test watching directory\n    let result = watcher.watch_directory(temp_dir.path()).await;\n    assert!(result.is_ok());\n\n    // Test unwatching directory\n    let result = watcher.unwatch_directory(temp_dir.path()).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_file_watcher_watch_string_path() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let mut watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n    let result = watcher.watch_directory(\"/tmp\").await;\n    assert!(result.is_ok());\n\n    let result = watcher.unwatch_directory(\"/tmp\").await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_file_watcher_debug_format() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n    let debug_str = format!(\"{:?}\", watcher);\n    assert!(debug_str.contains(\"FileWatcher\"));\n    assert!(debug_str.contains(\"config\"));\n    assert!(debug_str.contains(\"processor\"));\n}\n\n#[tokio::test]\nasync fn test_file_watcher_processor_sharing() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let processor_clone = Arc::clone(\u0026processor);\n\n    let _watcher = FileWatcher::new(\u0026config, processor_clone).await.unwrap();\n\n    // Verify Arc sharing\n    assert!(Arc::strong_count(\u0026processor) \u003e= 2);\n}\n\n#[tokio::test]\nasync fn test_file_watcher_ignore_patterns() {\n    let mut config = create_test_watcher_config(true);\n    config.ignore_patterns = vec![\n        \"*.log\".to_string(),\n        \"node_modules/**\".to_string(),\n        \"*.tmp\".to_string(),\n    ];\n\n    let processor = create_test_processor().await;\n    let _watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n    // Config fields are private, so we just test that creation succeeds with custom patterns\n    assert_eq!(config.ignore_patterns.len(), 3);\n    assert!(config.ignore_patterns.contains(\u0026\"*.log\".to_string()));\n    assert!(config.ignore_patterns.contains(\u0026\"node_modules/**\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_file_watcher_multiple_start_stop() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let watcher = FileWatcher::new(\u0026config, processor).await.unwrap();\n\n    // Multiple start/stop cycles should work\n    for _ in 0..3 {\n        watcher.start().await.unwrap();\n        watcher.stop().await.unwrap();\n    }\n}\n\n#[test]\nfn test_file_watcher_send_sync() {\n    fn assert_send\u003cT: Send\u003e() {}\n    fn assert_sync\u003cT: Sync\u003e() {}\n\n    assert_send::\u003cFileWatcher\u003e();\n    assert_sync::\u003cFileWatcher\u003e();\n}\n\n// ================================\n// CROSS-MODULE INTEGRATION TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_processor_and_state_integration() {\n    let (processing_config, qdrant_config) = create_test_configs();\n    let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config).await.unwrap();\n\n    let db_config = create_test_database_config();\n    let state = DaemonState::new(\u0026db_config).await.unwrap();\n\n    // Both should be functional\n    let doc_result = processor.process_document(\"integration_test.txt\").await;\n    assert!(doc_result.is_ok());\n\n    let health_result = state.health_check().await;\n    assert!(health_result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_watcher_and_processor_integration() {\n    let config = create_test_watcher_config(true);\n    let processor = create_test_processor().await;\n    let processor_clone = Arc::clone(\u0026processor);\n\n    let watcher = FileWatcher::new(\u0026config, processor_clone).await.unwrap();\n\n    // Both components should be functional\n    watcher.start().await.unwrap();\n\n    let doc_result = processor.process_document(\"watcher_test.txt\").await;\n    assert!(doc_result.is_ok());\n\n    watcher.stop().await.unwrap();\n}\n\n#[test]\nfn test_all_components_send_sync() {\n    fn assert_send\u003cT: Send\u003e() {}\n    fn assert_sync\u003cT: Sync\u003e() {}\n\n    // All main daemon components should be Send + Sync\n    assert_send::\u003cDaemonCore\u003e();\n    assert_sync::\u003cDaemonCore\u003e();\n    assert_send::\u003cSystemInfo\u003e();\n    assert_sync::\u003cSystemInfo\u003e();\n    assert_send::\u003cFileWatcher\u003e();\n    assert_sync::\u003cFileWatcher\u003e();\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","tests","functional","test_service_integration.rs"],"content":"use proptest::prelude::*;\nuse serial_test::serial;\nuse std::time::Duration;\nuse testcontainers::{clients, images, Container, Docker};\nuse tokio::time::sleep;\n\n/// Property-based test for document content validation\n#[cfg(test)]\nmod property_tests {\n    use super::*;\n\n    proptest! {\n        #[test]\n        fn test_document_content_properties(\n            content in \"\\\\PC{1,10000}\", // Any Unicode string 1-10k chars\n            metadata in prop::collection::hash_map(\"\\\\PC{1,100}\", \"\\\\PC{1,1000}\", 0..10)\n        ) {\n            // Property: processed content should never be empty if input isn't empty\n            if !content.is_empty() {\n                let processed = process_document_content(\u0026content);\n                prop_assert!(!processed.is_empty(), \"Processed content should not be empty\");\n            }\n\n            // Property: metadata keys should be preserved\n            let processed_metadata = process_metadata(metadata.clone());\n            for key in metadata.keys() {\n                prop_assert!(processed_metadata.contains_key(key), \"Metadata key should be preserved\");\n            }\n        }\n\n        #[test]\n        fn test_search_score_properties(\n            scores in prop::collection::vec(0.0f32..1.0f32, 1..100)\n        ) {\n            // Property: fusion scores should be in valid range\n            let fused_scores = reciprocal_rank_fusion(\u0026scores, \u0026scores);\n            for score in \u0026fused_scores {\n                prop_assert!(*score \u003e= 0.0, \"Fused score should be non-negative\");\n                prop_assert!(*score \u003c= 2.0, \"Fused score should not exceed reasonable bounds\");\n            }\n\n            // Property: number of results should be preserved\n            prop_assert_eq!(fused_scores.len(), scores.len(), \"Result count should be preserved\");\n        }\n    }\n\n    // Mock implementations for testing\n    fn process_document_content(content: \u0026str) -\u003e String {\n        // Simple processing that preserves non-empty content\n        content.trim().to_string()\n    }\n\n    fn process_metadata(metadata: std::collections::HashMap\u003cString, String\u003e) -\u003e std::collections::HashMap\u003cString, String\u003e {\n        // Simple passthrough processing\n        metadata\n    }\n\n    fn reciprocal_rank_fusion(dense_scores: \u0026[f32], sparse_scores: \u0026[f32]) -\u003e Vec\u003cf32\u003e {\n        dense_scores\n            .iter()\n            .zip(sparse_scores.iter())\n            .enumerate()\n            .map(|(rank, (\u0026dense, \u0026sparse))| {\n                let rrf_dense = 1.0 / (60.0 + rank as f32 + 1.0);\n                let rrf_sparse = 1.0 / (60.0 + rank as f32 + 1.0);\n                dense * rrf_dense + sparse * rrf_sparse\n            })\n            .collect()\n    }\n}\n\n/// Integration tests using testcontainers\n#[cfg(test)]\nmod integration_tests {\n    use super::*;\n\n    #[tokio::test]\n    #[serial]\n    async fn test_qdrant_container_integration() {\n        // Note: This is a template - actual testcontainers integration would require\n        // implementing a custom Qdrant image or using HTTP calls\n\n        let docker = clients::Cli::default();\n\n        // For demonstration, using a generic container\n        // In real implementation, this would be a Qdrant container\n        let container = docker.run(images::generic::GenericImage::new(\"hello-world\", \"latest\"));\n\n        // Wait for container to be ready\n        sleep(Duration::from_secs(2)).await;\n\n        // Test basic container functionality\n        assert!(container.get_host_port_ipv4(6333).is_err()); // hello-world doesn't expose ports\n\n        // In a real test, you would:\n        // 1. Start Qdrant container\n        // 2. Wait for health check\n        // 3. Create collections\n        // 4. Test document ingestion\n        // 5. Test search operations\n        // 6. Verify isolation between tests\n    }\n\n    #[tokio::test]\n    #[serial]\n    async fn test_isolated_service_operations() {\n        // Template for isolated service testing\n        // Each test gets a fresh container instance\n\n        let docker = clients::Cli::default();\n\n        // Start service container\n        let _container = docker.run(images::generic::GenericImage::new(\"hello-world\", \"latest\"));\n\n        // Test specific service operations in isolation\n        test_document_upload().await;\n        test_search_functionality().await;\n        test_collection_management().await;\n\n        // Container automatically cleaned up when dropped\n    }\n\n    async fn test_document_upload() {\n        // Mock document upload test\n        let document = \"Test document content\";\n        let result = simulate_document_upload(document).await;\n        assert!(result.is_ok(), \"Document upload should succeed\");\n    }\n\n    async fn test_search_functionality() {\n        // Mock search test\n        let query = \"test query\";\n        let results = simulate_search(query).await;\n        assert!(!results.is_empty(), \"Search should return results\");\n    }\n\n    async fn test_collection_management() {\n        // Mock collection management test\n        let collection_name = \"test_collection\";\n        let created = simulate_create_collection(collection_name).await;\n        assert!(created, \"Collection creation should succeed\");\n\n        let deleted = simulate_delete_collection(collection_name).await;\n        assert!(deleted, \"Collection deletion should succeed\");\n    }\n\n    // Mock implementations for testing\n    async fn simulate_document_upload(_content: \u0026str) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n        sleep(Duration::from_millis(10)).await;\n        Ok(())\n    }\n\n    async fn simulate_search(_query: \u0026str) -\u003e Vec\u003cString\u003e {\n        sleep(Duration::from_millis(5)).await;\n        vec![\"result1\".to_string(), \"result2\".to_string()]\n    }\n\n    async fn simulate_create_collection(_name: \u0026str) -\u003e bool {\n        sleep(Duration::from_millis(10)).await;\n        true\n    }\n\n    async fn simulate_delete_collection(_name: \u0026str) -\u003e bool {\n        sleep(Duration::from_millis(10)).await;\n        true\n    }\n}\n\n/// Performance tests using criterion-like patterns\n#[cfg(test)]\nmod performance_tests {\n    use super::*;\n    use std::time::Instant;\n\n    #[tokio::test]\n    async fn test_bulk_operations_performance() {\n        let document_count = 1000;\n        let documents: Vec\u003cString\u003e = (0..document_count)\n            .map(|i| format!(\"Document content {}\", i))\n            .collect();\n\n        let start = Instant::now();\n\n        // Simulate bulk document processing\n        for doc in \u0026documents {\n            simulate_process_document(doc).await;\n        }\n\n        let duration = start.elapsed();\n        let docs_per_second = document_count as f64 / duration.as_secs_f64();\n\n        // Performance assertion\n        assert!(\n            docs_per_second \u003e 100.0,\n            \"Processing rate should exceed 100 docs/second, got: {:.2}\",\n            docs_per_second\n        );\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_operations_performance() {\n        let concurrent_requests = 10;\n        let documents_per_request = 100;\n\n        let start = Instant::now();\n\n        let handles: Vec\u003c_\u003e = (0..concurrent_requests)\n            .map(|batch| {\n                tokio::spawn(async move {\n                    for i in 0..documents_per_request {\n                        let doc = format!(\"Batch {} Document {}\", batch, i);\n                        simulate_process_document(\u0026doc).await;\n                    }\n                })\n            })\n            .collect();\n\n        // Wait for all concurrent operations to complete\n        for handle in handles {\n            handle.await.expect(\"Task should complete successfully\");\n        }\n\n        let duration = start.elapsed();\n        let total_docs = concurrent_requests * documents_per_request;\n        let docs_per_second = total_docs as f64 / duration.as_secs_f64();\n\n        // Performance assertion for concurrent processing\n        assert!(\n            docs_per_second \u003e 500.0,\n            \"Concurrent processing rate should exceed 500 docs/second, got: {:.2}\",\n            docs_per_second\n        );\n    }\n\n    async fn simulate_process_document(_content: \u0026str) {\n        // Simulate minimal processing time\n        sleep(Duration::from_micros(100)).await;\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","tests","grpc_middleware.rs"],"content":"//! Comprehensive unit tests for grpc/middleware.rs - targeting 90%+ coverage\n//!\n//! This test suite provides comprehensive coverage for:\n//! - ConnectionManager with all edge cases and error conditions\n//! - ConnectionInterceptor request/response handling\n//! - Retry mechanisms with backoff and timeout scenarios\n//! - Rate limiting edge cases and cleanup\n//! - Connection pool configuration\n//! - Concurrent operations and thread safety\n\nuse workspace_qdrant_daemon::grpc::middleware::*;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse tonic::{Request, Response, metadata::MetadataValue};\n\n// =============================================================================\n// CONNECTION MANAGER COMPREHENSIVE TESTS\n// =============================================================================\n\n#[test]\nfn test_connection_manager_creation_variants() {\n    // Test with different parameter combinations\n    let manager1 = ConnectionManager::new(0, 0);\n    assert_eq!(manager1.get_stats().max_connections, 0);\n\n    let manager2 = ConnectionManager::new(u64::MAX, u32::MAX);\n    assert_eq!(manager2.get_stats().max_connections, u64::MAX);\n\n    let manager3 = ConnectionManager::new(1, 1);\n    assert_eq!(manager3.get_stats().max_connections, 1);\n}\n\n#[test]\nfn test_connection_manager_register_edge_cases() {\n    let manager = ConnectionManager::new(1, 10);\n\n    // Test empty client ID\n    let result = manager.register_connection(\"\".to_string());\n    assert!(result.is_ok());\n    assert_eq!(manager.get_stats().active_connections, 1);\n\n    // Test duplicate registration (should succeed creating new connection)\n    let result2 = manager.register_connection(\"\".to_string());\n    assert!(result2.is_err()); // Should fail due to max_connections = 1\n\n    manager.unregister_connection(\"\");\n\n    // Test very long client ID\n    let long_id = \"a\".repeat(1000);\n    let result3 = manager.register_connection(long_id.clone());\n    assert!(result3.is_ok());\n\n    manager.unregister_connection(\u0026long_id);\n\n    // Test special characters in client ID\n    let special_id = \"client-with/special\\\\chars:123\";\n    let result4 = manager.register_connection(special_id.to_string());\n    assert!(result4.is_ok());\n\n    manager.unregister_connection(special_id);\n}\n\n#[test]\nfn test_connection_manager_unregister_edge_cases() {\n    let manager = ConnectionManager::new(5, 10);\n\n    // Unregister non-existent connection multiple times\n    manager.unregister_connection(\"non_existent_1\");\n    manager.unregister_connection(\"non_existent_1\"); // Should not panic\n    manager.unregister_connection(\"different_non_existent\");\n\n    // Register and unregister same client multiple times\n    manager.register_connection(\"test_client\".to_string()).unwrap();\n    manager.unregister_connection(\"test_client\");\n    manager.unregister_connection(\"test_client\"); // Should not panic\n\n    assert_eq!(manager.get_stats().active_connections, 0);\n}\n\n#[test]\nfn test_connection_manager_rate_limiting_edge_cases() {\n    // Test with zero rate limit\n    let manager = ConnectionManager::new(10, 0);\n\n    let result = manager.check_rate_limit(\"client\");\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err().code(), tonic::Code::ResourceExhausted);\n\n    // Test with high rate limit\n    let manager2 = ConnectionManager::new(10, 1000);\n    for i in 0..999 {\n        let result = manager2.check_rate_limit(\"high_rate_client\");\n        assert!(result.is_ok(), \"Failed on request {}\", i);\n    }\n\n    // Should fail on 1000th request (at limit)\n    let result = manager2.check_rate_limit(\"high_rate_client\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_connection_manager_rate_limiting_cleanup() {\n    let manager = ConnectionManager::new(10, 2);\n\n    // Add some requests\n    manager.check_rate_limit(\"cleanup_client\").unwrap();\n    manager.check_rate_limit(\"cleanup_client\").unwrap();\n\n    // Next should fail\n    assert!(manager.check_rate_limit(\"cleanup_client\").is_err());\n\n    // Wait a bit and then add more requests to trigger cleanup path\n    std::thread::sleep(Duration::from_millis(10));\n\n    // Add requests for different clients to trigger the cleanup logic\n    for i in 0..10 {\n        let client_id = format!(\"temp_client_{}\", i);\n        let _ = manager.check_rate_limit(\u0026client_id);\n    }\n}\n\n#[test]\nfn test_connection_manager_rate_limiting_time_window() {\n    let manager = ConnectionManager::new(10, 2);\n\n    // Use up rate limit\n    assert!(manager.check_rate_limit(\"time_test\").is_ok());\n    assert!(manager.check_rate_limit(\"time_test\").is_ok());\n    assert!(manager.check_rate_limit(\"time_test\").is_err());\n\n    // Wait for time window to pass (slightly more than 1 second)\n    std::thread::sleep(Duration::from_millis(1100));\n\n    // Should be able to make requests again\n    assert!(manager.check_rate_limit(\"time_test\").is_ok());\n    assert!(manager.check_rate_limit(\"time_test\").is_ok());\n    assert!(manager.check_rate_limit(\"time_test\").is_err());\n}\n\n#[test]\nfn test_connection_manager_update_activity_edge_cases() {\n    let manager = ConnectionManager::new(5, 10);\n\n    // Update activity for non-existent connection\n    manager.update_activity(\"non_existent\", 100, 200);\n\n    // Register connection and update with zero values\n    manager.register_connection(\"zero_activity\".to_string()).unwrap();\n    manager.update_activity(\"zero_activity\", 0, 0);\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.total_requests, 1); // From register + update_activity call\n\n    // Update with large values\n    manager.update_activity(\"zero_activity\", u64::MAX, u64::MAX);\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.total_requests, 2);\n    assert_eq!(stats.total_bytes_sent, u64::MAX);\n    assert_eq!(stats.total_bytes_received, u64::MAX);\n}\n\n#[test]\nfn test_connection_manager_cleanup_expired_edge_cases() {\n    let manager = ConnectionManager::new(10, 10);\n\n    // Cleanup with no connections\n    manager.cleanup_expired_connections(Duration::from_secs(0));\n    manager.cleanup_expired_connections(Duration::from_secs(3600));\n\n    // Register multiple connections\n    for i in 0..5 {\n        manager.register_connection(format!(\"client_{}\", i)).unwrap();\n    }\n\n    assert_eq!(manager.get_stats().active_connections, 5);\n\n    // Update activity for some connections\n    manager.update_activity(\"client_0\", 100, 100);\n    manager.update_activity(\"client_2\", 100, 100);\n    manager.update_activity(\"client_4\", 100, 100);\n\n    // Cleanup with zero timeout (should remove all)\n    manager.cleanup_expired_connections(Duration::from_secs(0));\n    assert_eq!(manager.get_stats().active_connections, 0);\n}\n\n#[test]\nfn test_connection_manager_get_stats_accuracy() {\n    let manager = ConnectionManager::new(10, 10);\n\n    // Test with no connections\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n    assert_eq!(stats.total_bytes_sent, 0);\n    assert_eq!(stats.total_bytes_received, 0);\n    assert_eq!(stats.max_connections, 10);\n\n    // Add connections with different activity levels\n    manager.register_connection(\"stats_client_1\".to_string()).unwrap();\n    manager.register_connection(\"stats_client_2\".to_string()).unwrap();\n\n    manager.update_activity(\"stats_client_1\", 1000, 500);\n    manager.update_activity(\"stats_client_1\", 2000, 1000);\n    manager.update_activity(\"stats_client_2\", 500, 250);\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 2);\n    assert_eq!(stats.total_requests, 5); // 2 registrations + 3 activity updates\n    assert_eq!(stats.total_bytes_sent, 3500);\n    assert_eq!(stats.total_bytes_received, 1750);\n}\n\n// =============================================================================\n// CONNECTION INTERCEPTOR COMPREHENSIVE TESTS\n// =============================================================================\n\n#[test]\nfn test_connection_interceptor_intercept_metadata_parsing() {\n    let manager = Arc::new(ConnectionManager::new(10, 10));\n    let interceptor = ConnectionInterceptor::new(manager);\n\n    // Test with static metadata (simpler case)\n    let mut request: Request\u003c()\u003e = Request::new(());\n    request.metadata_mut().insert(\n        \"client-id\",\n        MetadataValue::from_static(\"test_client\")\n    );\n\n    // Should handle gracefully\n    let result = interceptor.intercept(request);\n    assert!(result.is_ok());\n\n    // Test with empty metadata value\n    let mut request2: Request\u003c()\u003e = Request::new(());\n    request2.metadata_mut().insert(\"client-id\", MetadataValue::from_static(\"\"));\n\n    let result2 = interceptor.intercept(request2);\n    assert!(result2.is_ok());\n\n    // Test with whitespace-only client ID\n    let mut request3: Request\u003c()\u003e = Request::new(());\n    request3.metadata_mut().insert(\"client-id\", MetadataValue::from_static(\"   \"));\n\n    let result3 = interceptor.intercept(request3);\n    assert!(result3.is_ok());\n}\n\n#[test]\nfn test_connection_interceptor_rate_limiting_integration() {\n    let manager = Arc::new(ConnectionManager::new(10, 1)); // Very restrictive rate limit\n    let interceptor = ConnectionInterceptor::new(manager);\n\n    // First request should succeed\n    let mut request1: Request\u003c()\u003e = Request::new(());\n    request1.metadata_mut().insert(\"client-id\", MetadataValue::from_static(\"rate_limited_client\"));\n\n    let result1 = interceptor.intercept(request1);\n    assert!(result1.is_ok());\n\n    // Second request should fail due to rate limiting\n    let mut request2: Request\u003c()\u003e = Request::new(());\n    request2.metadata_mut().insert(\"client-id\", MetadataValue::from_static(\"rate_limited_client\"));\n\n    let result2 = interceptor.intercept(request2);\n    assert!(result2.is_err());\n    assert_eq!(result2.unwrap_err().code(), tonic::Code::ResourceExhausted);\n}\n\n#[test]\nfn test_connection_interceptor_response_handling() {\n    let manager = Arc::new(ConnectionManager::new(10, 10));\n    let interceptor = ConnectionInterceptor::new(manager.clone());\n\n    // Register a client first\n    manager.register_connection(\"response_client\".to_string()).unwrap();\n\n    // Test response interception with various response types\n    let response1: Response\u003cString\u003e = Response::new(\"test_response\".to_string());\n    let result1 = interceptor.intercept_response(response1, \"response_client\");\n    assert_eq!(result1.get_ref(), \"test_response\");\n\n    // Test with unit response\n    let response2: Response\u003c()\u003e = Response::new(());\n    let result2 = interceptor.intercept_response(response2, \"response_client\");\n    assert_eq!(result2.get_ref(), \u0026());\n\n    // Test with non-existent client (should not panic)\n    let response3: Response\u003ci32\u003e = Response::new(42);\n    let result3 = interceptor.intercept_response(response3, \"non_existent_client\");\n    assert_eq!(result3.get_ref(), \u002642);\n}\n\n// =============================================================================\n// RETRY MECHANISM COMPREHENSIVE TESTS\n// =============================================================================\n\n#[tokio::test]\nasync fn test_with_retry_zero_retries() {\n    let config = RetryConfig {\n        max_retries: 0,\n        initial_delay: Duration::from_millis(1),\n        max_delay: Duration::from_secs(1),\n        backoff_multiplier: 2.0,\n    };\n\n    // Should fail immediately with zero retries\n    let result = with_retry(\n        || Box::pin(async { Err::\u003ci32, \u0026'static str\u003e(\"immediate failure\") }),\n        \u0026config,\n    ).await;\n\n    assert_eq!(result.unwrap_err(), \"immediate failure\");\n}\n\n#[tokio::test]\nasync fn test_with_retry_backoff_progression() {\n    let config = RetryConfig {\n        max_retries: 4,\n        initial_delay: Duration::from_millis(1),\n        max_delay: Duration::from_millis(10),\n        backoff_multiplier: 2.0,\n    };\n\n    let start_time = Instant::now();\n    let attempt_count = Arc::new(AtomicU64::new(0));\n    let attempt_clone = Arc::clone(\u0026attempt_count);\n\n    let result = with_retry(\n        move || {\n            attempt_clone.fetch_add(1, Ordering::SeqCst);\n            Box::pin(async { Err::\u003ci32, \u0026'static str\u003e(\"always fail\") })\n        },\n        \u0026config,\n    ).await;\n\n    let elapsed = start_time.elapsed();\n\n    // Should have made max_retries attempts\n    assert_eq!(attempt_count.load(Ordering::SeqCst), 4);\n    assert!(result.is_err());\n\n    // Should have taken some time due to backoff delays\n    // Total expected delay: 1ms + 2ms + 4ms = 7ms (capped at max_delay)\n    assert!(elapsed \u003e= Duration::from_millis(5));\n}\n\n#[tokio::test]\nasync fn test_with_retry_max_delay_capping() {\n    let config = RetryConfig {\n        max_retries: 3,\n        initial_delay: Duration::from_millis(10),\n        max_delay: Duration::from_millis(15), // Cap below expected exponential growth\n        backoff_multiplier: 10.0, // High multiplier\n    };\n\n    let start_time = Instant::now();\n\n    let result = with_retry(\n        || Box::pin(async { Err::\u003ci32, \u0026'static str\u003e(\"capped delay test\") }),\n        \u0026config,\n    ).await;\n\n    let elapsed = start_time.elapsed();\n\n    // With multiplier 10.0, delays would be: 10ms, 100ms, 1000ms\n    // But capped at 15ms each, so total should be around 30ms\n    assert!(elapsed \u003c Duration::from_millis(100)); // Much less than uncapped\n    assert!(elapsed \u003e= Duration::from_millis(25)); // But still some delay\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_with_retry_success_after_retries() {\n    let config = RetryConfig {\n        max_retries: 5,\n        initial_delay: Duration::from_millis(1),\n        max_delay: Duration::from_secs(1),\n        backoff_multiplier: 1.5,\n    };\n\n    let attempt_count = Arc::new(AtomicU64::new(0));\n    let attempt_clone = Arc::clone(\u0026attempt_count);\n\n    let result = with_retry(\n        move || {\n            let current_attempt = attempt_clone.fetch_add(1, Ordering::SeqCst) + 1;\n            Box::pin(async move {\n                if current_attempt \u003c 4 {\n                    Err(\"not yet\")\n                } else {\n                    Ok::\u003ci32, \u0026'static str\u003e(42)\n                }\n            })\n        },\n        \u0026config,\n    ).await;\n\n    assert_eq!(result.unwrap(), 42);\n    assert_eq!(attempt_count.load(Ordering::SeqCst), 4);\n}\n\n#[tokio::test]\nasync fn test_with_retry_different_error_types() {\n    let config = RetryConfig::default();\n\n    // Test with String error\n    let result1 = with_retry(\n        || Box::pin(async { Err::\u003ci32, String\u003e(\"string error\".to_string()) }),\n        \u0026config,\n    ).await;\n    assert!(result1.is_err());\n\n    // Test with custom error type\n    #[derive(Debug, PartialEq)]\n    struct CustomError(\u0026'static str);\n\n    let result2 = with_retry(\n        || Box::pin(async { Err::\u003ci32, CustomError\u003e(CustomError(\"custom error\")) }),\n        \u0026config,\n    ).await;\n    assert_eq!(result2.unwrap_err(), CustomError(\"custom error\"));\n}\n\n// =============================================================================\n// CONFIGURATION TESTS\n// =============================================================================\n\n#[test]\nfn test_pool_config_comprehensive() {\n    // Test default values\n    let default_config = PoolConfig::default();\n    assert_eq!(default_config.max_size, 10);\n    assert_eq!(default_config.min_idle, Some(2));\n    assert_eq!(default_config.max_lifetime, Some(Duration::from_secs(3600)));\n    assert_eq!(default_config.idle_timeout, Some(Duration::from_secs(600)));\n    assert_eq!(default_config.connection_timeout, Duration::from_secs(30));\n\n    // Test custom configuration with edge values\n    let custom_config = PoolConfig {\n        max_size: 0,\n        min_idle: None,\n        max_lifetime: None,\n        idle_timeout: None,\n        connection_timeout: Duration::from_millis(1),\n    };\n\n    assert_eq!(custom_config.max_size, 0);\n    assert_eq!(custom_config.min_idle, None);\n    assert_eq!(custom_config.max_lifetime, None);\n    assert_eq!(custom_config.idle_timeout, None);\n    assert_eq!(custom_config.connection_timeout, Duration::from_millis(1));\n\n    // Test extreme values\n    let extreme_config = PoolConfig {\n        max_size: usize::MAX,\n        min_idle: Some(usize::MAX),\n        max_lifetime: Some(Duration::from_secs(u64::MAX)),\n        idle_timeout: Some(Duration::from_nanos(1)),\n        connection_timeout: Duration::from_secs(0),\n    };\n\n    assert_eq!(extreme_config.max_size, usize::MAX);\n    assert_eq!(extreme_config.min_idle, Some(usize::MAX));\n}\n\n#[test]\nfn test_retry_config_comprehensive() {\n    // Test default values\n    let default_config = RetryConfig::default();\n    assert_eq!(default_config.max_retries, 3);\n    assert_eq!(default_config.initial_delay, Duration::from_millis(100));\n    assert_eq!(default_config.max_delay, Duration::from_secs(30));\n    assert_eq!(default_config.backoff_multiplier, 2.0);\n\n    // Test custom configuration with edge values\n    let custom_config = RetryConfig {\n        max_retries: 0,\n        initial_delay: Duration::from_nanos(1),\n        max_delay: Duration::from_nanos(1),\n        backoff_multiplier: 0.0,\n    };\n\n    assert_eq!(custom_config.max_retries, 0);\n    assert_eq!(custom_config.initial_delay, Duration::from_nanos(1));\n    assert_eq!(custom_config.max_delay, Duration::from_nanos(1));\n    assert_eq!(custom_config.backoff_multiplier, 0.0);\n\n    // Test extreme values\n    let extreme_config = RetryConfig {\n        max_retries: u32::MAX,\n        initial_delay: Duration::from_secs(u64::MAX),\n        max_delay: Duration::from_secs(u64::MAX),\n        backoff_multiplier: f64::MAX,\n    };\n\n    assert_eq!(extreme_config.max_retries, u32::MAX);\n    assert_eq!(extreme_config.backoff_multiplier, f64::MAX);\n}\n\n// =============================================================================\n// CONCURRENCY AND THREAD SAFETY TESTS\n// =============================================================================\n\n#[tokio::test]\nasync fn test_connection_manager_concurrent_operations() {\n    let manager = Arc::new(ConnectionManager::new(50, 100));\n    let mut handles = vec![];\n\n    // Spawn tasks for concurrent registration/unregistration\n    for i in 0..20 {\n        let manager_clone = Arc::clone(\u0026manager);\n        let handle = tokio::spawn(async move {\n            let client_id = format!(\"concurrent_client_{}\", i);\n\n            // Register\n            manager_clone.register_connection(client_id.clone()).unwrap();\n\n            // Update activity multiple times\n            for j in 0..10 {\n                manager_clone.update_activity(\u0026client_id, j * 10, j * 5);\n                tokio::time::sleep(Duration::from_micros(1)).await;\n            }\n\n            // Check rate limits\n            for _ in 0..5 {\n                let _ = manager_clone.check_rate_limit(\u0026client_id);\n            }\n\n            // Unregister\n            manager_clone.unregister_connection(\u0026client_id);\n        });\n        handles.push(handle);\n    }\n\n    // Wait for all tasks to complete\n    for handle in handles {\n        handle.await.unwrap();\n    }\n\n    // All connections should be cleaned up\n    assert_eq!(manager.get_stats().active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_connection_manager_concurrent_rate_limiting() {\n    let manager = Arc::new(ConnectionManager::new(100, 5)); // 5 requests per second\n    let mut handles = vec![];\n\n    // Spawn multiple tasks hitting rate limits simultaneously\n    for i in 0..10 {\n        let manager_clone = Arc::clone(\u0026manager);\n        let handle = tokio::spawn(async move {\n            let client_id = format!(\"rate_client_{}\", i);\n\n            // Each client should be able to make 5 requests before hitting limit\n            let mut success_count = 0;\n            let mut error_count = 0;\n\n            for _ in 0..10 {\n                match manager_clone.check_rate_limit(\u0026client_id) {\n                    Ok(()) =\u003e success_count += 1,\n                    Err(_) =\u003e error_count += 1,\n                }\n            }\n\n            (success_count, error_count)\n        });\n        handles.push(handle);\n    }\n\n    // Collect results\n    let mut total_success = 0;\n    let mut total_errors = 0;\n\n    for handle in handles {\n        let (success, errors) = handle.await.unwrap();\n        total_success += success;\n        total_errors += errors;\n    }\n\n    // Each client should have been rate limited\n    assert!(total_success \u003e 0);\n    assert!(total_errors \u003e 0);\n    assert_eq!(total_success + total_errors, 100); // 10 clients * 10 requests each\n}\n\n#[tokio::test]\nasync fn test_connection_interceptor_concurrent_requests() {\n    let manager = Arc::new(ConnectionManager::new(100, 50));\n    let interceptor = ConnectionInterceptor::new(manager.clone());\n    let mut handles = vec![];\n\n    // Register some clients\n    for i in 0..10 {\n        manager.register_connection(format!(\"interceptor_client_{}\", i)).unwrap();\n    }\n\n    // Spawn concurrent request interceptions\n    for i in 0..20 {\n        let interceptor_clone = interceptor.clone();\n        let handle = tokio::spawn(async move {\n            let mut request: Request\u003cString\u003e = Request::new(format!(\"request_{}\", i));\n            let _client_id = format!(\"interceptor_client_{}\", i % 10);\n            request.metadata_mut().insert(\n                \"client-id\",\n                MetadataValue::from_static(\"interceptor_client_0\")\n            );\n\n            let result = interceptor_clone.intercept(request);\n            result.is_ok()\n        });\n        handles.push(handle);\n    }\n\n    // Wait for all interceptions to complete\n    let mut success_count = 0;\n    for handle in handles {\n        if handle.await.unwrap() {\n            success_count += 1;\n        }\n    }\n\n    // Some should succeed (before rate limits hit)\n    assert!(success_count \u003e 0);\n}\n\n// =============================================================================\n// DEBUG AND TRAIT IMPLEMENTATION TESTS\n// =============================================================================\n\n#[test]\nfn test_debug_implementations() {\n    let manager = ConnectionManager::new(10, 5);\n    let debug_str = format!(\"{:?}\", manager);\n    assert!(debug_str.contains(\"ConnectionManager\"));\n\n    let stats = manager.get_stats();\n    let _stats_debug = format!(\"{:?}\", stats);\n    assert!(debug_str.contains(\"ConnectionStats\"));\n\n    let config = PoolConfig::default();\n    let config_debug = format!(\"{:?}\", config);\n    assert!(config_debug.contains(\"PoolConfig\"));\n\n    let retry_config = RetryConfig::default();\n    let retry_debug = format!(\"{:?}\", retry_config);\n    assert!(retry_debug.contains(\"RetryConfig\"));\n\n    let interceptor = ConnectionInterceptor::new(Arc::new(manager));\n    let interceptor_debug = format!(\"{:?}\", interceptor);\n    assert!(interceptor_debug.contains(\"ConnectionInterceptor\"));\n}\n\n#[test]\nfn test_clone_implementations() {\n    let stats = ConnectionStats {\n        active_connections: 5,\n        max_connections: 10,\n        total_requests: 100,\n        total_bytes_sent: 1000,\n        total_bytes_received: 2000,\n    };\n    let cloned_stats = stats.clone();\n    assert_eq!(stats.active_connections, cloned_stats.active_connections);\n\n    let config = PoolConfig::default();\n    let cloned_config = config.clone();\n    assert_eq!(config.max_size, cloned_config.max_size);\n\n    let retry_config = RetryConfig::default();\n    let cloned_retry = retry_config.clone();\n    assert_eq!(retry_config.max_retries, cloned_retry.max_retries);\n\n    let manager = Arc::new(ConnectionManager::new(10, 5));\n    let interceptor = ConnectionInterceptor::new(manager);\n    let cloned_interceptor = interceptor.clone();\n\n    // Should be able to use both interceptors\n    let _ = format!(\"{:?}\", interceptor);\n    let _ = format!(\"{:?}\", cloned_interceptor);\n}\n\n#[test]\nfn test_send_sync_traits() {\n    fn assert_send_sync\u003cT: Send + Sync\u003e() {}\n\n    assert_send_sync::\u003cConnectionManager\u003e();\n    assert_send_sync::\u003cConnectionStats\u003e();\n    assert_send_sync::\u003cPoolConfig\u003e();\n    assert_send_sync::\u003cRetryConfig\u003e();\n    assert_send_sync::\u003cConnectionInterceptor\u003e();\n}\n\n// =============================================================================\n// ERROR HANDLING AND EDGE CASE TESTS\n// =============================================================================\n\n#[test]\nfn test_connection_info_clone_atomics() {\n    let info = ConnectionInfo {\n        client_id: \"test_atomic_clone\".to_string(),\n        connected_at: Instant::now(),\n        last_activity: Instant::now(),\n        request_count: AtomicU64::new(42),\n        bytes_sent: AtomicU64::new(1000),\n        bytes_received: AtomicU64::new(2000),\n    };\n\n    // Modify original atomics\n    info.request_count.store(100, Ordering::SeqCst);\n    info.bytes_sent.store(5000, Ordering::SeqCst);\n    info.bytes_received.store(10000, Ordering::SeqCst);\n\n    // Clone should capture the current values\n    let cloned = info.clone();\n\n    assert_eq!(cloned.client_id, info.client_id);\n    assert_eq!(cloned.request_count.load(Ordering::SeqCst), 100);\n    assert_eq!(cloned.bytes_sent.load(Ordering::SeqCst), 5000);\n    assert_eq!(cloned.bytes_received.load(Ordering::SeqCst), 10000);\n\n    // Modifying original should not affect clone\n    info.request_count.store(999, Ordering::SeqCst);\n    assert_eq!(cloned.request_count.load(Ordering::SeqCst), 100);\n}\n\n#[test]\nfn test_connection_manager_stats_edge_cases() {\n    let manager = ConnectionManager::new(3, 10);\n\n    // Register connections with various activity levels\n    manager.register_connection(\"stats_test_1\".to_string()).unwrap();\n    manager.register_connection(\"stats_test_2\".to_string()).unwrap();\n\n    // Create overflow conditions for bytes counting\n    manager.update_activity(\"stats_test_1\", u64::MAX / 2, u64::MAX / 2);\n    manager.update_activity(\"stats_test_2\", u64::MAX / 2, u64::MAX / 2);\n\n    let stats = manager.get_stats();\n\n    // Should handle large numbers correctly\n    assert_eq!(stats.active_connections, 2);\n    assert!(stats.total_bytes_sent \u003e= u64::MAX / 2);\n    assert!(stats.total_bytes_received \u003e= u64::MAX / 2);\n}\n\n#[tokio::test]\nasync fn test_with_retry_unreachable_path() {\n    // This test ensures that the unreachable!() path in with_retry is never hit\n    // by testing the loop termination logic\n\n    let config = RetryConfig {\n        max_retries: 1,\n        initial_delay: Duration::from_millis(1),\n        max_delay: Duration::from_secs(1),\n        backoff_multiplier: 2.0,\n    };\n\n    let result = with_retry(\n        || Box::pin(async { Err::\u003ci32, \u0026'static str\u003e(\"test error\") }),\n        \u0026config,\n    ).await;\n\n    // Should return error, not hit unreachable!()\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_rate_limiter_cleanup_retention() {\n    let manager = ConnectionManager::new(10, 10);\n\n    // Add requests for multiple clients\n    for i in 0..5 {\n        let client_id = format!(\"retention_client_{}\", i);\n        let _ = manager.check_rate_limit(\u0026client_id);\n    }\n\n    // Force cleanup by waiting and making more requests to trigger the cleanup interval\n    std::thread::sleep(Duration::from_millis(10));\n\n    // Adding requests for new clients should potentially trigger cleanup\n    for i in 5..10 {\n        let client_id = format!(\"retention_client_{}\", i);\n        let _ = manager.check_rate_limit(\u0026client_id);\n    }\n\n    // The internal state should be maintained correctly\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 0); // No connections registered yet\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","tests","grpc_server.rs"],"content":"//! Comprehensive unit tests for grpc/server.rs achieving 90%+ coverage\n//! Tests cover server creation, service registration, connection management, and configuration\n\nuse workspace_qdrant_daemon::config::*;\nuse workspace_qdrant_daemon::daemon::WorkspaceDaemon;\nuse workspace_qdrant_daemon::grpc::server::GrpcServer;\nuse std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};\nuse std::sync::Arc;\nuse std::time::Duration;\n// Unused imports removed for cleaner test output\n\n// ================================\n// TEST CONFIGURATION HELPERS\n// ================================\n\nfn create_test_daemon_config() -\u003e DaemonConfig {\n    // Use in-memory SQLite database for tests\n    let db_path = \":memory:\";\n\n    DaemonConfig {\n        server: ServerConfig {\n            host: \"127.0.0.1\".to_string(),\n            port: 50052, // Use different port for testing\n            max_connections: 100,\n            connection_timeout_secs: 30,\n            request_timeout_secs: 60,\n            enable_tls: false,\n        },\n        database: DatabaseConfig {\n            sqlite_path: db_path.to_string(),\n            max_connections: 5,\n            connection_timeout_secs: 30,\n            enable_wal: true,\n        },\n        qdrant: QdrantConfig {\n            url: \"http://localhost:6333\".to_string(),\n            api_key: None,\n            timeout_secs: 30,\n            max_retries: 3,\n            default_collection: CollectionConfig {\n                vector_size: 384,\n                distance_metric: \"Cosine\".to_string(),\n                enable_indexing: true,\n                replication_factor: 1,\n                shard_number: 1,\n            },\n        },\n        processing: ProcessingConfig {\n            max_concurrent_tasks: 2,\n            default_chunk_size: 1000,\n            default_chunk_overlap: 200,\n            max_file_size_bytes: 1024 * 1024,\n            supported_extensions: vec![\"txt\".to_string(), \"md\".to_string()],\n            enable_lsp: false,\n            lsp_timeout_secs: 10,\n        },\n        file_watcher: FileWatcherConfig {\n            enabled: false,\n            debounce_ms: 500,\n            max_watched_dirs: 10,\n            ignore_patterns: vec![],\n            recursive: true,\n        },\n        metrics: MetricsConfig {\n            enabled: false,\n            collection_interval_secs: 60,\n            retention_days: 30,\n            enable_prometheus: false,\n            prometheus_port: 9090,\n        },\n        logging: LoggingConfig {\n            level: \"info\".to_string(),\n            file_path: None,\n            json_format: false,\n            max_file_size_mb: 100,\n            max_files: 5,\n        },\n    }\n}\n\nfn create_test_daemon_config_with_tls() -\u003e DaemonConfig {\n    let mut config = create_test_daemon_config();\n    config.server.enable_tls = true;\n    config.server.connection_timeout_secs = 60; // Different timeout\n    config.server.request_timeout_secs = 120;\n    config\n}\n\nfn create_test_daemon_config_large_limits() -\u003e DaemonConfig {\n    let mut config = create_test_daemon_config();\n    config.server.max_connections = 1000;\n    config.server.connection_timeout_secs = 300;\n    config.server.request_timeout_secs = 600;\n    config\n}\n\nasync fn create_test_daemon() -\u003e WorkspaceDaemon {\n    let config = create_test_daemon_config();\n    WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\")\n}\n\nasync fn create_test_daemon_with_config(config: DaemonConfig) -\u003e WorkspaceDaemon {\n    WorkspaceDaemon::new(config).await.expect(\"Failed to create daemon\")\n}\n\n// ================================\n// SERVER CREATION TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_new_basic() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that we can access connection manager (public API)\n    assert!(Arc::strong_count(server.connection_manager()) \u003e= 1);\n\n    // Test that connection stats are accessible\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_new_with_different_addresses() {\n    let daemon = create_test_daemon().await;\n\n    // Test IPv4 loopback\n    let ipv4_loopback = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 8080);\n    let server1 = GrpcServer::new(daemon.clone(), ipv4_loopback);\n    let stats1 = server1.get_connection_stats();\n    assert_eq!(stats1.active_connections, 0);\n\n    // Test IPv4 any\n    let ipv4_any = SocketAddr::new(IpAddr::V4(Ipv4Addr::UNSPECIFIED), 8081);\n    let server2 = GrpcServer::new(daemon.clone(), ipv4_any);\n    let stats2 = server2.get_connection_stats();\n    assert_eq!(stats2.active_connections, 0);\n\n    // Test IPv6 loopback\n    let ipv6_loopback = SocketAddr::new(IpAddr::V6(Ipv6Addr::LOCALHOST), 8082);\n    let server3 = GrpcServer::new(daemon.clone(), ipv6_loopback);\n    let stats3 = server3.get_connection_stats();\n    assert_eq!(stats3.active_connections, 0);\n\n    // Test different port ranges\n    let high_port = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 65535);\n    let server4 = GrpcServer::new(daemon.clone(), high_port);\n    let stats4 = server4.get_connection_stats();\n    assert_eq!(stats4.active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_new_with_config_variations() {\n    // Test with TLS enabled config\n    let tls_config = create_test_daemon_config_with_tls();\n    let daemon_tls = create_test_daemon_with_config(tls_config).await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8443);\n    let server_tls = GrpcServer::new(daemon_tls, address);\n    let stats_tls = server_tls.get_connection_stats();\n    assert_eq!(stats_tls.active_connections, 0);\n\n    // Test with large connection limits\n    let large_config = create_test_daemon_config_large_limits();\n    let daemon_large = create_test_daemon_with_config(large_config).await;\n    let server_large = GrpcServer::new(daemon_large, address);\n    let stats_large = server_large.get_connection_stats();\n    assert_eq!(stats_large.max_connections, 1000);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_connection_manager_initialization() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let connection_manager = server.connection_manager();\n\n    // Test that connection manager is properly initialized\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n    assert_eq!(stats.total_bytes_sent, 0);\n    assert_eq!(stats.total_bytes_received, 0);\n    assert_eq!(stats.max_connections, 100); // From test config\n}\n\n// ================================\n// SERVER CONFIGURATION TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_configuration_validation() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that server is properly configured\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.max_connections, 100); // From test config\n}\n\n#[tokio::test]\nasync fn test_grpc_server_with_different_configs() {\n    // Test with TLS config\n    let tls_config = create_test_daemon_config_with_tls();\n    let daemon_tls = create_test_daemon_with_config(tls_config).await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    let server_tls = GrpcServer::new(daemon_tls, address);\n    let stats_tls = server_tls.get_connection_stats();\n    assert_eq!(stats_tls.active_connections, 0);\n\n    // Test with large limits config\n    let large_config = create_test_daemon_config_large_limits();\n    let daemon_large = create_test_daemon_with_config(large_config).await;\n    let server_large = GrpcServer::new(daemon_large, address);\n    let stats_large = server_large.get_connection_stats();\n    assert_eq!(stats_large.max_connections, 1000);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_service_registration() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that server is properly initialized with services\n    // We can't call build_server directly, but we can verify the server exists\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.active_connections, 0);\n\n    // Test connection manager is properly initialized\n    let connection_manager = server.connection_manager();\n    assert!(Arc::strong_count(connection_manager) \u003e= 1);\n}\n\n// ================================\n// CONNECTION MANAGEMENT TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_get_connection_stats() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let stats = server.get_connection_stats();\n\n    // Initially should have no active connections\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n    assert_eq!(stats.max_connections, 100);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_connection_manager_access() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let connection_manager1 = server.connection_manager();\n    let connection_manager2 = server.connection_manager();\n\n    // Should return the same Arc instance\n    assert!(Arc::ptr_eq(connection_manager1, connection_manager2));\n\n    // Test that we can access connection manager methods\n    let stats = connection_manager1.get_stats();\n    assert_eq!(stats.active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_connection_manager_with_rate_limiting() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let connection_manager = server.connection_manager();\n\n    // Test rate limiting is initialized (100 requests per second from server.rs)\n    // Register a connection first\n    let register_result = connection_manager.register_connection(\"test_client\".to_string());\n    assert!(register_result.is_ok());\n\n    // Check that connection is registered\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Test rate limiting check\n    let rate_check = connection_manager.check_rate_limit(\"test_client\");\n    assert!(rate_check.is_ok());\n}\n\n// ================================\n// SERVER INITIALIZATION TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_initialization() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0); // Use port 0 for auto-assignment\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that server is properly initialized\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_ready_state() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that server is in ready state for serving\n    let connection_manager = server.connection_manager();\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n\n    // Test that connection manager is properly configured\n    assert_eq!(stats.max_connections, 100); // From test config\n}\n\n// ================================\n// CONFIGURATION EDGE CASES\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_address_types_and_parsing() {\n    let daemon = create_test_daemon().await;\n\n    // Test IPv4 address\n    let ipv4 = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1)), 8080);\n    let server_ipv4 = GrpcServer::new(daemon.clone(), ipv4);\n    let stats_ipv4 = server_ipv4.get_connection_stats();\n    assert_eq!(stats_ipv4.active_connections, 0);\n\n    // Test IPv6 address\n    let ipv6 = \"[::1]:9090\".parse::\u003cSocketAddr\u003e().unwrap();\n    let server_ipv6 = GrpcServer::new(daemon.clone(), ipv6);\n    let stats_ipv6 = server_ipv6.get_connection_stats();\n    assert_eq!(stats_ipv6.active_connections, 0);\n\n    // Test wildcard addresses\n    let ipv4_any = SocketAddr::new(IpAddr::V4(Ipv4Addr::UNSPECIFIED), 8080);\n    let server_any = GrpcServer::new(daemon.clone(), ipv4_any);\n    let stats_any = server_any.get_connection_stats();\n    assert_eq!(stats_any.active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_with_different_ports() {\n    let daemon = create_test_daemon().await;\n\n    let ports = [8080, 8081, 8082, 50051, 443, 65535];\n    for port in ports {\n        let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);\n        let server = GrpcServer::new(daemon.clone(), address);\n\n        // Test that connection manager is properly initialized for each\n        let stats = server.get_connection_stats();\n        assert_eq!(stats.active_connections, 0);\n        assert_eq!(stats.max_connections, 100);\n    }\n}\n\n// ================================\n// ARC SHARING AND MEMORY TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_arc_sharing() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let connection_manager = server.connection_manager();\n\n    // Verify connection manager is properly shared via Arc\n    assert!(Arc::strong_count(connection_manager) \u003e= 1);\n\n    // Test accessing connection manager methods\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.max_connections, 100);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_memory_efficiency() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Verify that server doesn't hold unnecessary references\n    let initial_manager_count = Arc::strong_count(server.connection_manager());\n\n    assert_eq!(initial_manager_count, 1);\n\n    // Test that accessing methods doesn't increase reference counts unexpectedly\n    let _stats = server.get_connection_stats();\n    let _manager = server.connection_manager();\n\n    assert_eq!(Arc::strong_count(server.connection_manager()), initial_manager_count);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_config_integration() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that connection manager was initialized with correct values from config\n    let connection_manager = server.connection_manager();\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.max_connections, 100);\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n}\n\n// ================================\n// CONCURRENT ACCESS TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_concurrent_access() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = Arc::new(GrpcServer::new(daemon, address));\n\n    let server1 = Arc::clone(\u0026server);\n    let server2 = Arc::clone(\u0026server);\n    let server3 = Arc::clone(\u0026server);\n\n    let handle1 = tokio::spawn(async move {\n        let _stats = server1.get_connection_stats();\n        let _manager = server1.connection_manager();\n    });\n\n    let handle2 = tokio::spawn(async move {\n        let _stats = server2.get_connection_stats();\n        let _manager = server2.connection_manager();\n    });\n\n    let handle3 = tokio::spawn(async move {\n        let _stats = server3.get_connection_stats();\n        let _manager = server3.connection_manager();\n    });\n\n    let (r1, r2, r3) = tokio::join!(handle1, handle2, handle3);\n    assert!(r1.is_ok());\n    assert!(r2.is_ok());\n    assert!(r3.is_ok());\n}\n\n// ================================\n// CONNECTION CLEANUP TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_connection_cleanup_simulation() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n    let connection_manager = server.connection_manager();\n\n    // Simulate the cleanup task that would run in serve() and serve_daemon()\n    // Register some connections\n    assert!(connection_manager.register_connection(\"client1\".to_string()).is_ok());\n    assert!(connection_manager.register_connection(\"client2\".to_string()).is_ok());\n\n    let stats = connection_manager.get_stats();\n    assert_eq!(stats.active_connections, 2);\n\n    // Test cleanup with various timeouts (simulating the 60-second interval cleanup)\n    connection_manager.cleanup_expired_connections(Duration::from_secs(300));\n    let stats_after = connection_manager.get_stats();\n    assert_eq!(stats_after.active_connections, 2); // Should still be there (not expired)\n\n    // Test cleanup with very short timeout\n    connection_manager.cleanup_expired_connections(Duration::from_millis(1));\n    let stats_short = connection_manager.get_stats();\n    assert_eq!(stats_short.active_connections, 2); // Still there (fresh connections)\n}\n\n// ================================\n// SOCKET ADDRESS VALIDATION TESTS\n// ================================\n\n#[test]\nfn test_socket_addr_parsing_comprehensive() {\n    // Test various socket address formats that the server should handle\n    let addrs = [\n        \"127.0.0.1:8080\",\n        \"0.0.0.0:8080\",\n        \"192.168.1.1:8080\",\n        \"[::1]:8080\",\n        \"[::]:8080\",\n        \"[2001:db8::1]:8080\",\n    ];\n\n    for addr_str in addrs {\n        let result = addr_str.parse::\u003cSocketAddr\u003e();\n        assert!(result.is_ok(), \"Failed to parse address: {}\", addr_str);\n\n        let addr = result.unwrap();\n        assert_eq!(addr.port(), 8080);\n    }\n\n    // Test port ranges\n    let port_tests = [\n        (\"127.0.0.1:1\", 1),\n        (\"127.0.0.1:80\", 80),\n        (\"127.0.0.1:443\", 443),\n        (\"127.0.0.1:8080\", 8080),\n        (\"127.0.0.1:50051\", 50051),\n        (\"127.0.0.1:65535\", 65535),\n    ];\n\n    for (addr_str, expected_port) in port_tests {\n        let result = addr_str.parse::\u003cSocketAddr\u003e();\n        assert!(result.is_ok(), \"Failed to parse address: {}\", addr_str);\n        assert_eq!(result.unwrap().port(), expected_port);\n    }\n}\n\n// ================================\n// TRAIT IMPLEMENTATION TESTS\n// ================================\n\n#[test]\nfn test_grpc_server_send_sync() {\n    fn assert_send\u003cT: Send\u003e() {}\n    fn assert_sync\u003cT: Sync\u003e() {}\n\n    assert_send::\u003cGrpcServer\u003e();\n    assert_sync::\u003cGrpcServer\u003e();\n}\n\n// ================================\n// ERROR HANDLING TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_with_edge_case_configs() {\n    // Test with minimal connection limits\n    let mut config = create_test_daemon_config();\n    config.server.max_connections = 1;\n    config.server.connection_timeout_secs = 1;\n\n    let daemon = create_test_daemon_with_config(config).await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    let server = GrpcServer::new(daemon, address);\n\n    // Should still work with minimal limits\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.max_connections, 1);\n    assert_eq!(stats.active_connections, 0);\n}\n\n#[tokio::test]\nasync fn test_grpc_server_service_readiness() {\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test that server is ready to serve (all services would be registered)\n    let stats = server.get_connection_stats();\n    assert_eq!(stats.active_connections, 0);\n\n    // Test connection manager is properly initialized for serving\n    let connection_manager = server.connection_manager();\n    assert!(Arc::strong_count(connection_manager) \u003e= 1);\n}\n\n// ================================\n// COMPREHENSIVE INTEGRATION TEST\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_full_lifecycle_simulation() {\n    // Test the complete server lifecycle without actually binding to ports\n    let daemon = create_test_daemon().await;\n    let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0);\n\n    let server = GrpcServer::new(daemon, address);\n\n    // Test connection manager initialization\n    let initial_stats = server.get_connection_stats();\n    assert_eq!(initial_stats.active_connections, 0);\n    assert_eq!(initial_stats.max_connections, 100);\n\n    // Test connection management operations\n    let connection_manager = server.connection_manager();\n    assert!(connection_manager.register_connection(\"test_client\".to_string()).is_ok());\n\n    let updated_stats = server.get_connection_stats();\n    assert_eq!(updated_stats.active_connections, 1);\n\n    // Test connection cleanup\n    connection_manager.cleanup_expired_connections(Duration::from_secs(300));\n    let final_stats = server.get_connection_stats();\n    assert_eq!(final_stats.active_connections, 1); // Should still be active\n\n    // Test rate limiting\n    let rate_result = connection_manager.check_rate_limit(\"test_client\");\n    assert!(rate_result.is_ok());\n\n    // Test activity updates\n    connection_manager.update_activity(\"test_client\", 100, 50);\n\n    // Test unregistration\n    connection_manager.unregister_connection(\"test_client\");\n    let end_stats = server.get_connection_stats();\n    assert_eq!(end_stats.active_connections, 0);\n}\n\n// ================================\n// CONFIGURATION COVERAGE TESTS\n// ================================\n\n#[tokio::test]\nasync fn test_grpc_server_all_config_paths() {\n    // Test different server configurations to ensure all code paths are covered\n\n    // Standard config\n    let config1 = create_test_daemon_config();\n    let daemon1 = create_test_daemon_with_config(config1).await;\n    let server1 = GrpcServer::new(daemon1, \"127.0.0.1:8080\".parse().unwrap());\n    let stats1 = server1.get_connection_stats();\n    assert_eq!(stats1.max_connections, 100);\n\n    // TLS config\n    let config2 = create_test_daemon_config_with_tls();\n    let daemon2 = create_test_daemon_with_config(config2).await;\n    let server2 = GrpcServer::new(daemon2, \"127.0.0.1:8081\".parse().unwrap());\n    let stats2 = server2.get_connection_stats();\n    assert_eq!(stats2.max_connections, 100);\n\n    // Large limits config\n    let config3 = create_test_daemon_config_large_limits();\n    let daemon3 = create_test_daemon_with_config(config3).await;\n    let server3 = GrpcServer::new(daemon3, \"127.0.0.1:8082\".parse().unwrap());\n    let stats3 = server3.get_connection_stats();\n    assert_eq!(stats3.max_connections, 1000);\n\n    // All servers should start with zero connections\n    assert_eq!(stats1.active_connections, 0);\n    assert_eq!(stats2.active_connections, 0);\n    assert_eq!(stats3.active_connections, 0);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","tests","middleware_simple.rs"],"content":"//! Simple middleware test coverage\n//! Testing the actual APIs that exist in the middleware module\n\nuse workspace_qdrant_daemon::grpc::middleware::*;\nuse std::sync::Arc;\nuse std::time::Duration;\n\n// ================================\n// CONNECTION MANAGER TESTS\n// ================================\n\n#[test]\nfn test_connection_manager_creation() {\n    let manager = ConnectionManager::new(100, 50);\n    let stats = manager.get_stats();\n\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.total_requests, 0);\n    assert_eq!(stats.max_connections, 100);\n}\n\n#[test]\nfn test_connection_manager_debug_format() {\n    let manager = ConnectionManager::new(10, 5);\n    let debug_str = format!(\"{:?}\", manager);\n    assert!(debug_str.contains(\"ConnectionManager\"));\n}\n\n#[test]\nfn test_connection_stats_fields() {\n    let manager = ConnectionManager::new(50, 20);\n    let stats = manager.get_stats();\n\n    // Test that all fields are accessible\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.max_connections, 50);\n    assert_eq!(stats.total_requests, 0);\n    assert_eq!(stats.total_bytes_sent, 0);\n    assert_eq!(stats.total_bytes_received, 0);\n}\n\n#[test]\nfn test_connection_stats_clone() {\n    let manager = ConnectionManager::new(30, 15);\n    let original = manager.get_stats();\n    let cloned = original.clone();\n\n    assert_eq!(original.active_connections, cloned.active_connections);\n    assert_eq!(original.max_connections, cloned.max_connections);\n    assert_eq!(original.total_requests, cloned.total_requests);\n    assert_eq!(original.total_bytes_sent, cloned.total_bytes_sent);\n    assert_eq!(original.total_bytes_received, cloned.total_bytes_received);\n}\n\n#[test]\nfn test_connection_stats_debug_format() {\n    let manager = ConnectionManager::new(25, 10);\n    let stats = manager.get_stats();\n\n    let debug_str = format!(\"{:?}\", stats);\n    assert!(debug_str.contains(\"ConnectionStats\"));\n    assert!(debug_str.contains(\"25\")); // max_connections\n}\n\n#[test]\nfn test_connection_manager_register_connection() {\n    let manager = ConnectionManager::new(2, 10);\n\n    // First connection should succeed\n    let result1 = manager.register_connection(\"client1\".to_string());\n    assert!(result1.is_ok());\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Second connection should succeed\n    let result2 = manager.register_connection(\"client2\".to_string());\n    assert!(result2.is_ok());\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 2);\n\n    // Third connection should fail (exceeds limit)\n    let result3 = manager.register_connection(\"client3\".to_string());\n    assert!(result3.is_err());\n}\n\n#[test]\nfn test_connection_manager_unregister_connection() {\n    let manager = ConnectionManager::new(5, 10);\n\n    // Register a connection\n    manager.register_connection(\"test_client\".to_string()).unwrap();\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Unregister the connection\n    manager.unregister_connection(\"test_client\");\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n\n    // Unregistering non-existent connection should not panic\n    manager.unregister_connection(\"non_existent\");\n}\n\n#[test]\nfn test_connection_manager_rate_limiting() {\n    let manager = ConnectionManager::new(10, 2); // 2 requests per second\n\n    // Register a client first\n    manager.register_connection(\"rate_test_client\".to_string()).unwrap();\n\n    // First request should be allowed\n    let result1 = manager.check_rate_limit(\"rate_test_client\");\n    assert!(result1.is_ok());\n\n    // Second request should be allowed\n    let result2 = manager.check_rate_limit(\"rate_test_client\");\n    assert!(result2.is_ok());\n\n    // Third request should be rate limited\n    let result3 = manager.check_rate_limit(\"rate_test_client\");\n    assert!(result3.is_err());\n}\n\n#[test]\nfn test_connection_manager_update_activity() {\n    let manager = ConnectionManager::new(5, 10);\n\n    // Register a connection\n    manager.register_connection(\"activity_client\".to_string()).unwrap();\n\n    // Update activity (should not panic)\n    manager.update_activity(\"activity_client\", 100, 50);\n\n    // Check that the connection still exists\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Update activity for non-existent client (should not panic)\n    manager.update_activity(\"non_existent\", 10, 5);\n}\n\n#[test]\nfn test_connection_manager_cleanup_expired() {\n    let manager = ConnectionManager::new(5, 10);\n\n    // Register a connection\n    manager.register_connection(\"cleanup_client\".to_string()).unwrap();\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Cleanup with very short timeout (should not remove fresh connections)\n    manager.cleanup_expired_connections(Duration::from_millis(1));\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n\n    // Cleanup with very long timeout (should not remove anything)\n    manager.cleanup_expired_connections(Duration::from_secs(3600));\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n}\n\n// ================================\n// CONNECTION INTERCEPTOR TESTS\n// ================================\n\n#[test]\nfn test_connection_interceptor_creation() {\n    let manager = Arc::new(ConnectionManager::new(10, 5));\n    let interceptor = ConnectionInterceptor::new(manager);\n\n    // Test that we can create it\n    let debug_str = format!(\"{:?}\", interceptor);\n    assert!(debug_str.contains(\"ConnectionInterceptor\"));\n}\n\n#[test]\nfn test_connection_interceptor_clone() {\n    let manager = Arc::new(ConnectionManager::new(10, 5));\n    let interceptor1 = ConnectionInterceptor::new(manager);\n    let interceptor2 = interceptor1.clone();\n\n    // Both should be valid\n    let debug1 = format!(\"{:?}\", interceptor1);\n    let debug2 = format!(\"{:?}\", interceptor2);\n\n    assert!(debug1.contains(\"ConnectionInterceptor\"));\n    assert!(debug2.contains(\"ConnectionInterceptor\"));\n}\n\n// ================================\n// POOL CONFIG TESTS\n// ================================\n\n#[test]\nfn test_pool_config_default() {\n    let config = PoolConfig::default();\n\n    assert_eq!(config.max_size, 10);\n    assert_eq!(config.min_idle, Some(2));\n    assert!(config.max_lifetime.is_some());\n    assert!(config.idle_timeout.is_some());\n    assert!(config.connection_timeout \u003e Duration::from_secs(0));\n}\n\n#[test]\nfn test_pool_config_debug() {\n    let config = PoolConfig::default();\n    let debug_str = format!(\"{:?}\", config);\n\n    assert!(debug_str.contains(\"PoolConfig\"));\n    assert!(debug_str.contains(\"10\")); // max_size\n}\n\n#[test]\nfn test_pool_config_clone() {\n    let original = PoolConfig::default();\n    let cloned = original.clone();\n\n    assert_eq!(original.max_size, cloned.max_size);\n    assert_eq!(original.min_idle, cloned.min_idle);\n    assert_eq!(original.max_lifetime, cloned.max_lifetime);\n    assert_eq!(original.idle_timeout, cloned.idle_timeout);\n    assert_eq!(original.connection_timeout, cloned.connection_timeout);\n}\n\n#[test]\nfn test_pool_config_custom() {\n    let config = PoolConfig {\n        max_size: 20,\n        min_idle: Some(5),\n        max_lifetime: Some(Duration::from_secs(7200)),\n        idle_timeout: Some(Duration::from_secs(1200)),\n        connection_timeout: Duration::from_secs(60),\n    };\n\n    assert_eq!(config.max_size, 20);\n    assert_eq!(config.min_idle, Some(5));\n    assert_eq!(config.max_lifetime, Some(Duration::from_secs(7200)));\n    assert_eq!(config.idle_timeout, Some(Duration::from_secs(1200)));\n    assert_eq!(config.connection_timeout, Duration::from_secs(60));\n}\n\n// ================================\n// INTEGRATION TESTS\n// ================================\n\n#[test]\nfn test_connection_manager_and_interceptor_integration() {\n    let manager = Arc::new(ConnectionManager::new(10, 5));\n    let manager_clone = Arc::clone(\u0026manager);\n    let _interceptor = ConnectionInterceptor::new(manager_clone);\n\n    // Manager should still be functional\n    let result = manager.register_connection(\"integration_client\".to_string());\n    assert!(result.is_ok());\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 1);\n}\n\n#[test]\nfn test_multi_client_registration() {\n    let manager = ConnectionManager::new(5, 10);\n    let client_names = vec![\"client1\", \"client2\", \"client3\"];\n\n    for client in \u0026client_names {\n        let result = manager.register_connection(client.to_string());\n        assert!(result.is_ok(), \"Failed to register client: {}\", client);\n    }\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 3);\n\n    // Unregister all clients\n    for client in \u0026client_names {\n        manager.unregister_connection(client);\n    }\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n}\n\n#[test]\nfn test_connection_manager_full_lifecycle() {\n    let manager = ConnectionManager::new(3, 5);\n\n    // Register up to limit\n    for i in 1..=3 {\n        let client_id = format!(\"client{}\", i);\n        let result = manager.register_connection(client_id);\n        assert!(result.is_ok());\n    }\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 3);\n\n    // Try to register beyond limit\n    let result = manager.register_connection(\"overflow_client\".to_string());\n    assert!(result.is_err());\n\n    // Update activity for existing clients\n    manager.update_activity(\"client1\", 100, 50);\n    manager.update_activity(\"client2\", 200, 100);\n\n    // Unregister one client\n    manager.unregister_connection(\"client1\");\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 2);\n\n    // Now we should be able to register a new client\n    let result = manager.register_connection(\"new_client\".to_string());\n    assert!(result.is_ok());\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 3);\n}\n\n// ================================\n// SEND/SYNC TRAIT TESTS\n// ================================\n\n#[test]\nfn test_middleware_components_send_sync() {\n    fn assert_send\u003cT: Send\u003e() {}\n    fn assert_sync\u003cT: Sync\u003e() {}\n\n    assert_send::\u003cConnectionManager\u003e();\n    assert_sync::\u003cConnectionManager\u003e();\n    assert_send::\u003cConnectionStats\u003e();\n    assert_sync::\u003cConnectionStats\u003e();\n    assert_send::\u003cPoolConfig\u003e();\n    assert_sync::\u003cPoolConfig\u003e();\n    assert_send::\u003cConnectionInterceptor\u003e();\n    assert_sync::\u003cConnectionInterceptor\u003e();\n}\n\n// ================================\n// ERROR CONDITION TESTS\n// ================================\n\n#[test]\nfn test_connection_manager_with_zero_max_connections() {\n    let manager = ConnectionManager::new(0, 10);\n\n    // Should immediately fail with zero max connections\n    let result = manager.register_connection(\"test_client\".to_string());\n    assert!(result.is_err());\n\n    let stats = manager.get_stats();\n    assert_eq!(stats.active_connections, 0);\n    assert_eq!(stats.max_connections, 0);\n}\n\n#[test]\nfn test_connection_manager_rate_limiting_with_zero_rate() {\n    let manager = ConnectionManager::new(5, 0); // Zero requests per second\n\n    // Register a client first\n    manager.register_connection(\"zero_rate_client\".to_string()).unwrap();\n\n    // Any request should be rate limited with zero rate\n    let result = manager.check_rate_limit(\"zero_rate_client\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_connection_manager_multiple_managers() {\n    let manager1 = ConnectionManager::new(2, 5);\n    let manager2 = ConnectionManager::new(3, 10);\n\n    // Register clients in different managers\n    assert!(manager1.register_connection(\"client1\".to_string()).is_ok());\n    assert!(manager2.register_connection(\"client2\".to_string()).is_ok());\n\n    // Each manager should track separately\n    assert_eq!(manager1.get_stats().active_connections, 1);\n    assert_eq!(manager2.get_stats().active_connections, 1);\n\n    // Fill up manager1\n    assert!(manager1.register_connection(\"client3\".to_string()).is_ok());\n    assert!(manager1.register_connection(\"client4\".to_string()).is_err()); // Should fail\n\n    // manager2 should still accept connections\n    assert!(manager2.register_connection(\"client5\".to_string()).is_ok());\n}\n\n#[test]\nfn test_connection_interceptor_with_different_managers() {\n    let manager1 = Arc::new(ConnectionManager::new(5, 10));\n    let manager2 = Arc::new(ConnectionManager::new(10, 20));\n\n    let interceptor1 = ConnectionInterceptor::new(manager1);\n    let interceptor2 = ConnectionInterceptor::new(manager2);\n\n    // Both should be valid and independent\n    let debug1 = format!(\"{:?}\", interceptor1);\n    let debug2 = format!(\"{:?}\", interceptor2);\n\n    assert!(debug1.contains(\"ConnectionInterceptor\"));\n    assert!(debug2.contains(\"ConnectionInterceptor\"));\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","tests","simple_error_coverage.rs"],"content":"//! Simple error handling coverage tests\n\nuse workspace_qdrant_daemon::error::*;\nuse std::io::{Error as IoError, ErrorKind};\n\n#[test]\nfn test_daemon_error_creation_and_display() {\n    // Test Config error\n    let config_error = DaemonError::Config(\n        config::ConfigError::Message(\"Invalid configuration\".to_string())\n    );\n    let config_msg = format!(\"{}\", config_error);\n    assert!(config_msg.contains(\"Configuration error\"));\n    assert!(config_msg.contains(\"Invalid configuration\"));\n\n    // Test IO error\n    let io_error = DaemonError::Io(IoError::new(ErrorKind::NotFound, \"File not found\"));\n    let io_msg = format!(\"{}\", io_error);\n    assert!(io_msg.contains(\"I/O error\"));\n    assert!(io_msg.contains(\"File not found\"));\n\n    // Test Database error\n    let db_error = DaemonError::Database(sqlx::Error::PoolClosed);\n    let db_msg = format!(\"{}\", db_error);\n    assert!(db_msg.contains(\"Database error\"));\n\n    // Test Document Processing error\n    let proc_error = DaemonError::DocumentProcessing {\n        message: \"Failed to process document\".to_string()\n    };\n    let proc_msg = format!(\"{}\", proc_error);\n    assert!(proc_msg.contains(\"Document processing error\"));\n    assert!(proc_msg.contains(\"Failed to process document\"));\n\n    // Test Search error\n    let search_error = DaemonError::Search {\n        message: \"Search failed\".to_string()\n    };\n    let search_msg = format!(\"{}\", search_error);\n    assert!(search_msg.contains(\"Search error\"));\n    assert!(search_msg.contains(\"Search failed\"));\n\n    // Test Memory error\n    let memory_error = DaemonError::Memory {\n        message: \"Memory operation failed\".to_string()\n    };\n    let memory_msg = format!(\"{}\", memory_error);\n    assert!(memory_msg.contains(\"Memory management error\"));\n    assert!(memory_msg.contains(\"Memory operation failed\"));\n\n    // Test System error\n    let system_error = DaemonError::System {\n        message: \"System call failed\".to_string()\n    };\n    let system_msg = format!(\"{}\", system_error);\n    assert!(system_msg.contains(\"System error\"));\n    assert!(system_msg.contains(\"System call failed\"));\n}\n\n#[test]\nfn test_daemon_error_debug() {\n    let error = DaemonError::DocumentProcessing {\n        message: \"Test error\".to_string()\n    };\n    let debug_str = format!(\"{:?}\", error);\n    assert!(debug_str.contains(\"DocumentProcessing\"));\n    assert!(debug_str.contains(\"Test error\"));\n}\n\n#[test]\nfn test_daemon_error_from_conversions() {\n    // Test From\u003cstd::io::Error\u003e\n    let io_error = IoError::new(ErrorKind::PermissionDenied, \"Permission denied\");\n    let daemon_error: DaemonError = io_error.into();\n    match daemon_error {\n        DaemonError::Io(e) =\u003e {\n            assert_eq!(e.kind(), ErrorKind::PermissionDenied);\n        },\n        _ =\u003e panic!(\"Expected IO error conversion\"),\n    }\n\n    // Test From\u003cconfig::ConfigError\u003e\n    let config_error = config::ConfigError::Message(\"Invalid config\".to_string());\n    let daemon_error: DaemonError = config_error.into();\n    match daemon_error {\n        DaemonError::Config(_) =\u003e {\n            // Expected conversion\n        },\n        _ =\u003e panic!(\"Expected Config error conversion\"),\n    }\n\n    // Test From\u003csqlx::Error\u003e\n    let sql_error = sqlx::Error::RowNotFound;\n    let daemon_error: DaemonError = sql_error.into();\n    match daemon_error {\n        DaemonError::Database(_) =\u003e {\n            // Expected conversion\n        },\n        _ =\u003e panic!(\"Expected Database error conversion\"),\n    }\n}\n\n#[test]\nfn test_daemon_error_std_error_trait() {\n    let error = DaemonError::DocumentProcessing {\n        message: \"Test processing error\".to_string()\n    };\n\n    // Test that it implements std::error::Error\n    let std_error: \u0026dyn std::error::Error = \u0026error;\n    assert!(std_error.to_string().contains(\"Document processing error\"));\n}\n\n#[test]\nfn test_daemon_error_chain() {\n    // Create a chain of errors to test error handling\n    let io_error = IoError::new(ErrorKind::NotFound, \"Config file not found\");\n    let daemon_error = DaemonError::Io(io_error);\n\n    let error_string = format!(\"{}\", daemon_error);\n    assert!(error_string.contains(\"I/O error\"));\n    assert!(error_string.contains(\"Config file not found\"));\n}\n\n#[test]\nfn test_daemon_result_type() {\n    // Test successful result\n    let success: DaemonResult\u003ci32\u003e = Ok(42);\n    assert_eq!(success.unwrap(), 42);\n\n    // Test error result\n    let error: DaemonResult\u003ci32\u003e = Err(DaemonError::DocumentProcessing {\n        message: \"Test error\".to_string()\n    });\n    assert!(error.is_err());\n\n    match error {\n        Err(DaemonError::DocumentProcessing { message }) =\u003e {\n            assert_eq!(message, \"Test error\");\n        },\n        _ =\u003e panic!(\"Expected document processing error\"),\n    }\n}\n\n#[test]\nfn test_daemon_error_send_sync() {\n    fn assert_send\u003cT: Send\u003e() {}\n    fn assert_sync\u003cT: Sync\u003e() {}\n\n    assert_send::\u003cDaemonError\u003e();\n    assert_sync::\u003cDaemonError\u003e();\n}\n\n#[test]\nfn test_all_structured_error_variants() {\n    // Test all the structured error variants\n    let errors = vec![\n        DaemonError::DocumentProcessing { message: \"test\".to_string() },\n        DaemonError::Search { message: \"test\".to_string() },\n        DaemonError::Memory { message: \"test\".to_string() },\n        DaemonError::System { message: \"test\".to_string() },\n        DaemonError::ProjectDetection { message: \"test\".to_string() },\n        DaemonError::ConnectionPool { message: \"test\".to_string() },\n        DaemonError::Timeout { seconds: 30 },\n        DaemonError::NotFound { resource: \"document\".to_string() },\n        DaemonError::InvalidInput { message: \"invalid data\".to_string() },\n        DaemonError::Internal { message: \"internal error\".to_string() },\n    ];\n\n    for error in errors {\n        // Each error should be debuggable\n        let debug_str = format!(\"{:?}\", error);\n        assert!(!debug_str.is_empty());\n\n        // Each error should be displayable\n        let display_str = format!(\"{}\", error);\n        assert!(!display_str.is_empty());\n\n        // Each error should convert to Status\n        let _status: tonic::Status = error.into();\n    }\n}\n\n#[test]\nfn test_timeout_error() {\n    let timeout_error = DaemonError::Timeout { seconds: 60 };\n    let msg = format!(\"{}\", timeout_error);\n    assert!(msg.contains(\"Timeout error\"));\n    assert!(msg.contains(\"60s\"));\n}\n\n#[test]\nfn test_not_found_error() {\n    let not_found_error = DaemonError::NotFound {\n        resource: \"collection\".to_string()\n    };\n    let msg = format!(\"{}\", not_found_error);\n    assert!(msg.contains(\"Resource not found\"));\n    assert!(msg.contains(\"collection\"));\n}\n\n#[test]\nfn test_error_to_status_conversion() {\n    // Test InvalidInput -\u003e InvalidArgument\n    let invalid_input = DaemonError::InvalidInput {\n        message: \"Bad input\".to_string()\n    };\n    let status: tonic::Status = invalid_input.into();\n    assert_eq!(status.code(), tonic::Code::InvalidArgument);\n\n    // Test NotFound -\u003e NotFound\n    let not_found = DaemonError::NotFound {\n        resource: \"user\".to_string()\n    };\n    let status: tonic::Status = not_found.into();\n    assert_eq!(status.code(), tonic::Code::NotFound);\n\n    // Test Timeout -\u003e DeadlineExceeded\n    let timeout = DaemonError::Timeout { seconds: 30 };\n    let status: tonic::Status = timeout.into();\n    assert_eq!(status.code(), tonic::Code::DeadlineExceeded);\n\n    // Test IO -\u003e Internal\n    let io_error = DaemonError::Io(IoError::new(ErrorKind::NotFound, \"File not found\"));\n    let status: tonic::Status = io_error.into();\n    assert_eq!(status.code(), tonic::Code::Internal);\n}\n\n#[test]\nfn test_error_equality_and_comparison() {\n    // Test that we can compare error messages\n    let error1 = DaemonError::DocumentProcessing {\n        message: \"Same message\".to_string()\n    };\n    let error2 = DaemonError::DocumentProcessing {\n        message: \"Same message\".to_string()\n    };\n    let error3 = DaemonError::DocumentProcessing {\n        message: \"Different message\".to_string()\n    };\n\n    // Test string representation equality\n    assert_eq!(format!(\"{}\", error1), format!(\"{}\", error2));\n    assert_ne!(format!(\"{}\", error1), format!(\"{}\", error3));\n\n    // Test that different error types produce different strings\n    let search_error = DaemonError::Search {\n        message: \"Same message\".to_string()\n    };\n    assert_ne!(format!(\"{}\", error1), format!(\"{}\", search_error));\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","tests","test_daemon_processing.rs"],"content":"//! Comprehensive unit tests for daemon/processing.rs module\n//! Tests DocumentProcessor and related functions with proven file-by-file methodology\n\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse workspace_qdrant_daemon::config::{ProcessingConfig, QdrantConfig, CollectionConfig};\nuse workspace_qdrant_daemon::daemon::processing::DocumentProcessor;\nuse workspace_qdrant_daemon::error::DaemonResult;\n\n/// Configuration module for test setup\n#[cfg(test)]\nmod test_config {\n    use super::*;\n\n    /// Create a standard test processing configuration\n    pub fn create_test_processing_config() -\u003e ProcessingConfig {\n        ProcessingConfig {\n            max_concurrent_tasks: 2,\n            default_chunk_size: 1000,\n            default_chunk_overlap: 200,\n            max_file_size_bytes: 1024 * 1024, // 1MB\n            supported_extensions: vec![\n                \"rs\".to_string(),\n                \"py\".to_string(),\n                \"md\".to_string(),\n                \"txt\".to_string(),\n            ],\n            enable_lsp: true,\n            lsp_timeout_secs: 10,\n        }\n    }\n\n    /// Create a variant processing configuration for testing different values\n    pub fn create_variant_processing_config() -\u003e ProcessingConfig {\n        ProcessingConfig {\n            max_concurrent_tasks: 4,\n            default_chunk_size: 2000,\n            default_chunk_overlap: 400,\n            max_file_size_bytes: 10 * 1024 * 1024, // 10MB\n            supported_extensions: vec![\n                \"js\".to_string(),\n                \"ts\".to_string(),\n                \"json\".to_string(),\n            ],\n            enable_lsp: false,\n            lsp_timeout_secs: 20,\n        }\n    }\n\n    /// Create a minimal processing configuration for edge testing\n    pub fn create_minimal_processing_config() -\u003e ProcessingConfig {\n        ProcessingConfig {\n            max_concurrent_tasks: 1,\n            default_chunk_size: 100,\n            default_chunk_overlap: 20,\n            max_file_size_bytes: 1024, // 1KB\n            supported_extensions: vec![\"txt\".to_string()],\n            enable_lsp: false,\n            lsp_timeout_secs: 5,\n        }\n    }\n\n    /// Create a standard test qdrant configuration\n    pub fn create_test_qdrant_config() -\u003e QdrantConfig {\n        QdrantConfig {\n            url: \"http://localhost:6333\".to_string(),\n            api_key: None,\n            timeout_secs: 30,\n            max_retries: 3,\n            default_collection: CollectionConfig {\n                vector_size: 384,\n                distance_metric: \"Cosine\".to_string(),\n                enable_indexing: true,\n                replication_factor: 1,\n                shard_number: 1,\n            },\n        }\n    }\n\n    /// Create a qdrant configuration with API key for testing\n    pub fn create_qdrant_config_with_key() -\u003e QdrantConfig {\n        QdrantConfig {\n            url: \"https://remote-qdrant.example.com:6333\".to_string(),\n            api_key: Some(\"test-api-key-12345\".to_string()),\n            timeout_secs: 60,\n            max_retries: 5,\n            default_collection: CollectionConfig {\n                vector_size: 768,\n                distance_metric: \"Euclidean\".to_string(),\n                enable_indexing: false,\n                replication_factor: 2,\n                shard_number: 3,\n            },\n        }\n    }\n\n    /// Create an alternative qdrant configuration\n    pub fn create_alternative_qdrant_config() -\u003e QdrantConfig {\n        QdrantConfig {\n            url: \"http://test-qdrant:6334\".to_string(),\n            api_key: Some(\"alternative-key\".to_string()),\n            timeout_secs: 45,\n            max_retries: 2,\n            default_collection: CollectionConfig {\n                vector_size: 512,\n                distance_metric: \"Dot\".to_string(),\n                enable_indexing: true,\n                replication_factor: 3,\n                shard_number: 2,\n            },\n        }\n    }\n}\n\n/// Basic DocumentProcessor creation and configuration tests\n#[cfg(test)]\nmod basic_creation_tests {\n    use super::*;\n    use super::test_config::*;\n\n    #[tokio::test]\n    async fn test_document_processor_creation_standard_config() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        // Verify configuration is properly stored\n        assert_eq!(processor.config().max_concurrent_tasks, 2);\n        assert_eq!(processor.config().default_chunk_size, 1000);\n        assert_eq!(processor.config().default_chunk_overlap, 200);\n        assert_eq!(processor.config().max_file_size_bytes, 1024 * 1024);\n        assert_eq!(processor.config().supported_extensions.len(), 4);\n        assert!(processor.config().supported_extensions.contains(\u0026\"rs\".to_string()));\n        assert!(processor.config().supported_extensions.contains(\u0026\"py\".to_string()));\n        assert!(processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 10);\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_creation_variant_config() {\n        let processing_config = create_variant_processing_config();\n        let qdrant_config = create_qdrant_config_with_key();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor with variant config\");\n\n        // Verify variant configuration values\n        assert_eq!(processor.config().max_concurrent_tasks, 4);\n        assert_eq!(processor.config().default_chunk_size, 2000);\n        assert_eq!(processor.config().default_chunk_overlap, 400);\n        assert_eq!(processor.config().max_file_size_bytes, 10 * 1024 * 1024);\n        assert_eq!(processor.config().supported_extensions.len(), 3);\n        assert!(processor.config().supported_extensions.contains(\u0026\"js\".to_string()));\n        assert!(processor.config().supported_extensions.contains(\u0026\"ts\".to_string()));\n        assert!(processor.config().supported_extensions.contains(\u0026\"json\".to_string()));\n        assert!(!processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 20);\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_creation_minimal_config() {\n        let processing_config = create_minimal_processing_config();\n        let qdrant_config = create_alternative_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor with minimal config\");\n\n        // Verify minimal configuration values\n        assert_eq!(processor.config().max_concurrent_tasks, 1);\n        assert_eq!(processor.config().default_chunk_size, 100);\n        assert_eq!(processor.config().default_chunk_overlap, 20);\n        assert_eq!(processor.config().max_file_size_bytes, 1024);\n        assert_eq!(processor.config().supported_extensions.len(), 1);\n        assert!(processor.config().supported_extensions.contains(\u0026\"txt\".to_string()));\n        assert!(!processor.config().enable_lsp);\n        assert_eq!(processor.config().lsp_timeout_secs, 5);\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_debug_format() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor for debug test\");\n\n        // Test debug formatting\n        let debug_str = format!(\"{:?}\", processor);\n        assert!(debug_str.contains(\"DocumentProcessor\"));\n        assert!(!debug_str.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_config_access() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor for config access test\");\n\n        // Test config access returns correct reference\n        let config = processor.config();\n        assert_eq!(config.max_concurrent_tasks, processing_config.max_concurrent_tasks);\n        assert_eq!(config.default_chunk_size, processing_config.default_chunk_size);\n        assert_eq!(config.default_chunk_overlap, processing_config.default_chunk_overlap);\n        assert_eq!(config.max_file_size_bytes, processing_config.max_file_size_bytes);\n        assert_eq!(config.supported_extensions, processing_config.supported_extensions);\n        assert_eq!(config.enable_lsp, processing_config.enable_lsp);\n        assert_eq!(config.lsp_timeout_secs, processing_config.lsp_timeout_secs);\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_multiple_configs() {\n        let config1 = create_test_processing_config();\n        let config2 = create_variant_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor1 = DocumentProcessor::new(\u0026config1, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create first DocumentProcessor\");\n\n        let processor2 = DocumentProcessor::new(\u0026config2, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create second DocumentProcessor\");\n\n        // Verify processors have different configurations\n        assert_ne!(processor1.config().max_concurrent_tasks, processor2.config().max_concurrent_tasks);\n        assert_ne!(processor1.config().default_chunk_size, processor2.config().default_chunk_size);\n        assert_ne!(processor1.config().supported_extensions, processor2.config().supported_extensions);\n    }\n}\n\n/// Document processing workflow tests\n#[cfg(test)]\nmod document_processing_tests {\n    use super::*;\n    use super::test_config::*;\n\n    #[tokio::test]\n    async fn test_process_single_document_success() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        let result = processor.process_document(\"test_file.rs\").await;\n        assert!(result.is_ok(), \"Document processing should succeed\");\n\n        let document_id = result.unwrap();\n        // UUID v4 is 36 characters with 4 hyphens\n        assert_eq!(document_id.len(), 36);\n        assert_eq!(document_id.matches('-').count(), 4);\n        \n        // Verify it's a valid UUID format\n        assert!(uuid::Uuid::parse_str(\u0026document_id).is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_process_multiple_different_files() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        let test_files = vec![\n            \"main.rs\",\n            \"script.py\", \n            \"README.md\",\n            \"config.txt\",\n            \"data.json\",\n            \"index.html\",\n            \"style.css\",\n        ];\n\n        let mut results = Vec::new();\n        for file in \u0026test_files {\n            let result = processor.process_document(file).await;\n            assert!(result.is_ok(), \"Failed to process file: {}\", file);\n            results.push(result.unwrap());\n        }\n\n        // All results should be valid UUIDs\n        for (i, result) in results.iter().enumerate() {\n            assert_eq!(result.len(), 36, \"Invalid UUID length for file: {}\", test_files[i]);\n            assert!(uuid::Uuid::parse_str(result).is_ok(), \"Invalid UUID format for file: {}\", test_files[i]);\n        }\n\n        // All UUIDs should be unique\n        for i in 0..results.len() {\n            for j in (i + 1)..results.len() {\n                assert_ne!(results[i], results[j], \"UUIDs should be unique\");\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_process_document_with_special_characters() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        let special_files = vec![\n            \"file with spaces.txt\",\n            \"file-with-dashes.md\",\n            \"file_with_underscores.py\",\n            \"file.with.dots.rs\",\n            \"file@with@symbols.txt\",\n            \"--unicode.txt\", // Cyrillic characters\n            \".txt\", // Chinese characters\n        ];\n\n        for file in \u0026special_files {\n            let result = processor.process_document(file).await;\n            assert!(result.is_ok(), \"Failed to process file with special characters: {}\", file);\n            \n            let document_id = result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(\u0026document_id).is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_process_document_with_long_path() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        // Create a very long file path\n        let long_path = format!(\n            \"{}/test_file.rs\",\n            \"very/deep/nested/directory/structure/with/many/levels/of/subdirectories/that/goes/on/and/on/and/on/for/a/very/long/time/to/test/edge/cases\"\n        );\n\n        let result = processor.process_document(\u0026long_path).await;\n        assert!(result.is_ok(), \"Should handle long file paths\");\n        \n        let document_id = result.unwrap();\n        assert_eq!(document_id.len(), 36);\n        assert!(uuid::Uuid::parse_str(\u0026document_id).is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_process_document_empty_filename() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        let result = processor.process_document(\"\").await;\n        assert!(result.is_ok(), \"Should handle empty filename\");\n        \n        let document_id = result.unwrap();\n        assert_eq!(document_id.len(), 36);\n        assert!(uuid::Uuid::parse_str(\u0026document_id).is_ok());\n    }\n}\n\n/// Concurrent processing and semaphore tests\n#[cfg(test)]\nmod concurrency_tests {\n    use super::*;\n    use super::test_config::*;\n    use tokio::time::Duration;\n\n    #[tokio::test]\n    async fn test_concurrent_processing_within_limits() {\n        let processing_config = create_test_processing_config(); // max_concurrent_tasks = 2\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let mut handles = vec![];\n        let start_time = Instant::now();\n\n        // Spawn 4 tasks (more than the limit of 2)\n        for i in 0..4 {\n            let processor_clone = Arc::clone(\u0026processor);\n            let handle = tokio::spawn(async move {\n                processor_clone\n                    .process_document(\u0026format!(\"concurrent_test_{}.rs\", i))\n                    .await\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all tasks to complete\n        let results = futures_util::future::join_all(handles).await;\n        let elapsed = start_time.elapsed();\n\n        // All tasks should complete successfully\n        for (i, result) in results.iter().enumerate() {\n            let task_result = result.as_ref().expect(\u0026format!(\"Task {} panicked\", i));\n            assert!(task_result.is_ok(), \"Task {} failed: {:?}\", i, task_result);\n            \n            let document_id = task_result.as_ref().unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(document_id).is_ok());\n        }\n\n        // With max_concurrent_tasks = 2 and 4 tasks taking ~100ms each,\n        // total time should be at least 200ms (two batches)\n        assert!(elapsed \u003e= Duration::from_millis(180), \"Tasks should be limited by semaphore, elapsed: {:?}\", elapsed);\n    }\n\n    #[tokio::test]\n    async fn test_sequential_processing_with_single_limit() {\n        let mut processing_config = create_minimal_processing_config();\n        processing_config.max_concurrent_tasks = 1; // Force sequential processing\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let start_time = Instant::now();\n        let task_count = 3;\n        let mut handles = vec![];\n\n        // Spawn multiple tasks that should run sequentially\n        for i in 0..task_count {\n            let processor_clone = Arc::clone(\u0026processor);\n            let handle = tokio::spawn(async move {\n                processor_clone\n                    .process_document(\u0026format!(\"sequential_test_{}.rs\", i))\n                    .await\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n        let elapsed = start_time.elapsed();\n\n        // All tasks should succeed\n        for (i, result) in results.iter().enumerate() {\n            let task_result = result.as_ref().expect(\u0026format!(\"Task {} panicked\", i));\n            assert!(task_result.is_ok(), \"Task {} failed\", i);\n        }\n\n        // With 3 tasks running sequentially, each taking ~100ms, total should be ~300ms\n        assert!(elapsed \u003e= Duration::from_millis(250), \"Sequential tasks should take longer, elapsed: {:?}\", elapsed);\n    }\n\n    #[tokio::test]\n    async fn test_high_concurrency_processing() {\n        let mut processing_config = create_variant_processing_config();\n        processing_config.max_concurrent_tasks = 8; // High concurrency\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let task_count = 16;\n        let mut handles = vec![];\n        let start_time = Instant::now();\n\n        // Spawn many concurrent tasks\n        for i in 0..task_count {\n            let processor_clone = Arc::clone(\u0026processor);\n            let handle = tokio::spawn(async move {\n                processor_clone\n                    .process_document(\u0026format!(\"high_concurrency_test_{}.rs\", i))\n                    .await\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n        let elapsed = start_time.elapsed();\n\n        // All tasks should succeed\n        for (i, result) in results.iter().enumerate() {\n            let task_result = result.as_ref().expect(\u0026format!(\"Task {} panicked\", i));\n            assert!(task_result.is_ok(), \"Task {} failed\", i);\n        }\n\n        // With high concurrency (8), 16 tasks should complete faster than sequential\n        // Should complete in roughly 2 batches: ~200ms\n        assert!(elapsed \u003c= Duration::from_millis(400), \"High concurrency should be faster, elapsed: {:?}\", elapsed);\n    }\n\n    #[tokio::test]\n    async fn test_semaphore_limits_concurrent_execution() {\n        let processing_config = create_test_processing_config(); // max_concurrent_tasks = 2\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let start_time = Instant::now();\n        let task_count = 4;\n        let mut handles = vec![];\n\n        // Spawn multiple tasks that should be limited by the semaphore\n        for i in 0..task_count {\n            let processor_clone = Arc::clone(\u0026processor);\n            let handle = tokio::spawn(async move {\n                let start = Instant::now();\n                let result = processor_clone\n                    .process_document(\u0026format!(\"semaphore_limit_test_{}.rs\", i))\n                    .await;\n                let elapsed = start.elapsed();\n                (i, result, elapsed)\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n        let total_elapsed = start_time.elapsed();\n\n        // All tasks should succeed\n        for result in \u0026results {\n            let (task_id, process_result, _) = result.as_ref().expect(\"Task should not panic\");\n            assert!(process_result.is_ok(), \"Task {} failed\", task_id);\n        }\n\n        // With max_concurrent_tasks = 2 and 4 tasks, execution should take longer\n        // than if all tasks ran concurrently (which would be ~100ms)\n        // It should take at least 200ms (two batches of concurrent execution)\n        assert!(total_elapsed \u003e= Duration::from_millis(180),\n            \"Semaphore should limit concurrency, total time: {:?}\", total_elapsed);\n\n        // Verify all UUIDs are valid and unique\n        let mut document_ids = vec![];\n        for result in results {\n            let (_, process_result, _) = result.expect(\"Task should not panic\");\n            let document_id = process_result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(\u0026document_id).is_ok());\n            document_ids.push(document_id);\n        }\n\n        // All UUIDs should be unique\n        for i in 0..document_ids.len() {\n            for j in (i + 1)..document_ids.len() {\n                assert_ne!(document_ids[i], document_ids[j], \"All UUIDs should be unique\");\n            }\n        }\n    }\n}\n\n/// Error handling and edge case tests\n#[cfg(test)]\nmod error_handling_tests {\n    use super::*;\n    use super::test_config::*;\n\n    #[tokio::test]\n    async fn test_process_document_timing_consistency() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor\");\n\n        let mut durations = vec![];\n        \n        // Process the same document multiple times to check timing consistency\n        for i in 0..5 {\n            let start = Instant::now();\n            let result = processor.process_document(\u0026format!(\"timing_test_{}.rs\", i)).await;\n            let duration = start.elapsed();\n            \n            assert!(result.is_ok(), \"Document processing should succeed\");\n            durations.push(duration);\n        }\n\n        // All processing times should be reasonably consistent (within a range)\n        // Current implementation sleeps for 100ms, so durations should be around that\n        for (i, duration) in durations.iter().enumerate() {\n            assert!(\n                duration \u003e= \u0026Duration::from_millis(95) \u0026\u0026 duration \u003c= \u0026Duration::from_millis(150),\n                \"Duration {} ({:?}) is outside expected range\", i, duration\n            );\n        }\n    }\n\n    #[tokio::test]\n    async fn test_document_processor_stress_test() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let stress_test_count = 20;\n        let mut handles = vec![];\n\n        // Create many concurrent tasks to stress test the processor\n        for i in 0..stress_test_count {\n            let processor_clone = Arc::clone(\u0026processor);\n            let handle = tokio::spawn(async move {\n                // Process multiple documents per task\n                let mut results = vec![];\n                for j in 0..3 {\n                    let file_path = format!(\"stress_test_{}_{}.rs\", i, j);\n                    let result = processor_clone.process_document(\u0026file_path).await;\n                    results.push((file_path, result));\n                }\n                results\n            });\n            handles.push(handle);\n        }\n\n        let task_results = futures_util::future::join_all(handles).await;\n\n        // Verify all stress test tasks completed successfully\n        let mut total_processed = 0;\n        for (task_id, task_result) in task_results.iter().enumerate() {\n            let document_results = task_result.as_ref().expect(\u0026format!(\"Stress test task {} panicked\", task_id));\n            \n            for (file_path, result) in document_results {\n                assert!(result.is_ok(), \"Failed to process {} in stress test\", file_path);\n                total_processed += 1;\n                \n                let document_id = result.as_ref().unwrap();\n                assert_eq!(document_id.len(), 36);\n                assert!(uuid::Uuid::parse_str(document_id).is_ok());\n            }\n        }\n\n        assert_eq!(total_processed, stress_test_count * 3, \"Not all documents were processed\");\n    }\n\n    #[tokio::test]\n    async fn test_processor_with_extreme_configurations() {\n        // Test with extremely small configuration\n        let mut tiny_config = create_minimal_processing_config();\n        tiny_config.max_concurrent_tasks = 1;\n        tiny_config.default_chunk_size = 1;\n        tiny_config.default_chunk_overlap = 0;\n        tiny_config.max_file_size_bytes = 1;\n        tiny_config.lsp_timeout_secs = 1;\n        \n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026tiny_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor with tiny config\");\n\n        assert_eq!(processor.config().max_concurrent_tasks, 1);\n        assert_eq!(processor.config().default_chunk_size, 1);\n        assert_eq!(processor.config().default_chunk_overlap, 0);\n        assert_eq!(processor.config().max_file_size_bytes, 1);\n        assert_eq!(processor.config().lsp_timeout_secs, 1);\n\n        // Should still be able to process documents\n        let result = processor.process_document(\"tiny_test.txt\").await;\n        assert!(result.is_ok());\n\n        // Test with extremely large configuration\n        let mut huge_config = create_variant_processing_config();\n        huge_config.max_concurrent_tasks = 1000;\n        huge_config.default_chunk_size = 1_000_000;\n        huge_config.default_chunk_overlap = 100_000;\n        huge_config.max_file_size_bytes = 1_000_000_000;\n        huge_config.lsp_timeout_secs = 3600;\n\n        let processor = DocumentProcessor::new(\u0026huge_config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor with huge config\");\n\n        assert_eq!(processor.config().max_concurrent_tasks, 1000);\n        assert_eq!(processor.config().default_chunk_size, 1_000_000);\n        assert_eq!(processor.config().default_chunk_overlap, 100_000);\n        assert_eq!(processor.config().max_file_size_bytes, 1_000_000_000);\n        assert_eq!(processor.config().lsp_timeout_secs, 3600);\n\n        // Should still be able to process documents\n        let result = processor.process_document(\"huge_test.txt\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_processor_with_empty_extensions_list() {\n        let mut config = create_test_processing_config();\n        config.supported_extensions = vec![]; // Empty extensions list\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = DocumentProcessor::new(\u0026config, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create DocumentProcessor with empty extensions\");\n\n        assert!(processor.config().supported_extensions.is_empty());\n\n        // Should still process documents even with empty extensions list\n        let result = processor.process_document(\"file_without_extension\").await;\n        assert!(result.is_ok());\n\n        let result = processor.process_document(\"file.unknown_extension\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_processor_config_independence() {\n        let config1 = create_test_processing_config();\n        let config2 = create_variant_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor1 = DocumentProcessor::new(\u0026config1, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create first DocumentProcessor\");\n        \n        let processor2 = DocumentProcessor::new(\u0026config2, \u0026qdrant_config)\n            .await\n            .expect(\"Failed to create second DocumentProcessor\");\n\n        // Processors should have independent configurations\n        assert_ne!(processor1.config().max_concurrent_tasks, processor2.config().max_concurrent_tasks);\n        assert_ne!(processor1.config().default_chunk_size, processor2.config().default_chunk_size);\n        assert_ne!(processor1.config().supported_extensions, processor2.config().supported_extensions);\n        assert_ne!(processor1.config().enable_lsp, processor2.config().enable_lsp);\n\n        // Both should process documents independently\n        let result1 = processor1.process_document(\"independent_test_1.rs\").await;\n        let result2 = processor2.process_document(\"independent_test_2.js\").await;\n        \n        assert!(result1.is_ok());\n        assert!(result2.is_ok());\n        assert_ne!(result1.unwrap(), result2.unwrap()); // Different UUIDs\n    }\n}\n\n/// Configuration cloning and thread safety tests\n#[cfg(test)]\nmod thread_safety_tests {\n    use super::*;\n    use super::test_config::*;\n\n    #[test]\n    fn test_config_structs_are_send_sync() {\n        fn assert_send_sync\u003cT: Send + Sync\u003e() {}\n\n        // Verify all config types are Send + Sync\n        assert_send_sync::\u003cProcessingConfig\u003e();\n        assert_send_sync::\u003cQdrantConfig\u003e();\n        assert_send_sync::\u003cCollectionConfig\u003e();\n    }\n\n    #[test]\n    fn test_processing_config_clone_equality() {\n        let config = create_test_processing_config();\n        let cloned = config.clone();\n\n        assert_eq!(config.max_concurrent_tasks, cloned.max_concurrent_tasks);\n        assert_eq!(config.default_chunk_size, cloned.default_chunk_size);\n        assert_eq!(config.default_chunk_overlap, cloned.default_chunk_overlap);\n        assert_eq!(config.max_file_size_bytes, cloned.max_file_size_bytes);\n        assert_eq!(config.supported_extensions, cloned.supported_extensions);\n        assert_eq!(config.enable_lsp, cloned.enable_lsp);\n        assert_eq!(config.lsp_timeout_secs, cloned.lsp_timeout_secs);\n    }\n\n    #[test]\n    fn test_qdrant_config_clone_equality() {\n        let config = create_test_qdrant_config();\n        let cloned = config.clone();\n\n        assert_eq!(config.url, cloned.url);\n        assert_eq!(config.api_key, cloned.api_key);\n        assert_eq!(config.timeout_secs, cloned.timeout_secs);\n        assert_eq!(config.max_retries, cloned.max_retries);\n        assert_eq!(config.default_collection.vector_size, cloned.default_collection.vector_size);\n        assert_eq!(config.default_collection.distance_metric, cloned.default_collection.distance_metric);\n        assert_eq!(config.default_collection.enable_indexing, cloned.default_collection.enable_indexing);\n        assert_eq!(config.default_collection.replication_factor, cloned.default_collection.replication_factor);\n        assert_eq!(config.default_collection.shard_number, cloned.default_collection.shard_number);\n    }\n\n    #[test]\n    fn test_config_debug_formatting() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processing_debug = format!(\"{:?}\", processing_config);\n        assert!(processing_debug.contains(\"ProcessingConfig\"));\n        assert!(processing_debug.contains(\u0026processing_config.max_concurrent_tasks.to_string()));\n        assert!(processing_debug.contains(\u0026processing_config.default_chunk_size.to_string()));\n\n        let qdrant_debug = format!(\"{:?}\", qdrant_config);\n        assert!(qdrant_debug.contains(\"QdrantConfig\"));\n        assert!(qdrant_debug.contains(\u0026qdrant_config.url));\n        assert!(qdrant_debug.contains(\u0026qdrant_config.timeout_secs.to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_processor_across_tokio_tasks() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        // Spawn multiple tokio tasks that use the same processor\n        let mut handles = vec![];\n        for i in 0..5 {\n            let processor_clone = Arc::clone(\u0026processor);\n            let handle = tokio::spawn(async move {\n                let file_path = format!(\"tokio_task_test_{}.rs\", i);\n                let result = processor_clone.process_document(\u0026file_path).await;\n                (i, result)\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n\n        // All tasks should complete successfully\n        for result in results {\n            let (task_id, process_result) = result.expect(\"Task should not panic\");\n            assert!(process_result.is_ok(), \"Task {} should succeed\", task_id);\n            \n            let document_id = process_result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(\u0026document_id).is_ok());\n        }\n    }\n\n    #[test]\n    fn test_config_modification_independence() {\n        let mut config1 = create_test_processing_config();\n        let config2 = config1.clone();\n\n        // Modify config1\n        config1.max_concurrent_tasks = 999;\n        config1.default_chunk_size = 999;\n        config1.enable_lsp = !config1.enable_lsp;\n        config1.supported_extensions.push(\"modified\".to_string());\n\n        // config2 should remain unchanged\n        assert_ne!(config1.max_concurrent_tasks, config2.max_concurrent_tasks);\n        assert_ne!(config1.default_chunk_size, config2.default_chunk_size);\n        assert_ne!(config1.enable_lsp, config2.enable_lsp);\n        assert!(!config2.supported_extensions.contains(\u0026\"modified\".to_string()));\n    }\n}\n\n/// Batch processing and performance tests\n#[cfg(test)]\nmod batch_processing_tests {\n    use super::*;\n    use super::test_config::*;\n\n    #[tokio::test]\n    async fn test_batch_processing_different_file_types() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        // Create a batch of different file types\n        let file_batch = vec![\n            (\"src/main.rs\", \"rust\"),\n            (\"scripts/deploy.py\", \"python\"),\n            (\"docs/README.md\", \"markdown\"),\n            (\"config/settings.txt\", \"text\"),\n            (\"frontend/index.html\", \"html\"),\n            (\"styles/main.css\", \"css\"),\n            (\"data/config.json\", \"json\"),\n            (\"scripts/build.sh\", \"shell\"),\n        ];\n\n        let mut handles = vec![];\n        for (file_path, file_type) in \u0026file_batch {\n            let processor_clone = Arc::clone(\u0026processor);\n            let file_path = file_path.to_string();\n            let file_type = file_type.to_string();\n            \n            let handle = tokio::spawn(async move {\n                let result = processor_clone.process_document(\u0026file_path).await;\n                (file_path, file_type, result)\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n\n        // Verify all files were processed successfully\n        for result in results {\n            let (file_path, file_type, process_result) = result.expect(\"Task should not panic\");\n            assert!(process_result.is_ok(), \"Failed to process {} file: {}\", file_type, file_path);\n            \n            let document_id = process_result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(\u0026document_id).is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_large_batch_processing_performance() {\n        let mut processing_config = create_variant_processing_config();\n        processing_config.max_concurrent_tasks = 6; // Reasonable concurrency for performance test\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        let batch_size = 30;\n        let start_time = Instant::now();\n        let mut handles = vec![];\n\n        // Process a large batch of documents\n        for i in 0..batch_size {\n            let processor_clone = Arc::clone(\u0026processor);\n            let handle = tokio::spawn(async move {\n                let file_path = format!(\"large_batch_test_{:03}.rs\", i);\n                processor_clone.process_document(\u0026file_path).await\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n        let elapsed = start_time.elapsed();\n\n        // Verify all documents were processed\n        let mut successful_count = 0;\n        for (i, result) in results.iter().enumerate() {\n            let process_result = result.as_ref().expect(\u0026format!(\"Task {} panicked\", i));\n            if process_result.is_ok() {\n                successful_count += 1;\n                let document_id = process_result.as_ref().unwrap();\n                assert_eq!(document_id.len(), 36);\n                assert!(uuid::Uuid::parse_str(document_id).is_ok());\n            }\n        }\n\n        assert_eq!(successful_count, batch_size, \"Not all documents were processed successfully\");\n        \n        // Performance check: with 6 concurrent tasks and 30 documents (~100ms each),\n        // should complete in roughly 500ms (5 batches)\n        assert!(elapsed \u003c= Duration::from_millis(800), \"Batch processing took too long: {:?}\", elapsed);\n        println!(\"Processed {} documents in {:?} (avg: {:?} per document)\", \n                batch_size, elapsed, elapsed / batch_size);\n    }\n\n    #[tokio::test]\n    async fn test_mixed_batch_with_repeated_files() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        // Create a batch where some files are repeated\n        let file_list = vec![\n            \"common.rs\",\n            \"unique1.py\",\n            \"common.rs\", // Repeated\n            \"unique2.md\",\n            \"common.rs\", // Repeated again\n            \"unique3.txt\",\n        ];\n\n        let mut handles = vec![];\n        for (i, file_path) in file_list.iter().enumerate() {\n            let processor_clone = Arc::clone(\u0026processor);\n            let file_path = file_path.to_string();\n            \n            let handle = tokio::spawn(async move {\n                let result = processor_clone.process_document(\u0026file_path).await;\n                (i, file_path, result)\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n\n        // All should succeed and have unique UUIDs (even repeated files get new UUIDs)\n        let mut document_ids = vec![];\n        for result in results {\n            let (index, file_path, process_result) = result.expect(\"Task should not panic\");\n            assert!(process_result.is_ok(), \"Failed to process {} at index {}\", file_path, index);\n            \n            let document_id = process_result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(\u0026document_id).is_ok());\n            document_ids.push(document_id);\n        }\n\n        // All UUIDs should be unique, even for repeated file names\n        for i in 0..document_ids.len() {\n            for j in (i + 1)..document_ids.len() {\n                assert_ne!(document_ids[i], document_ids[j], \n                    \"UUIDs should be unique even for repeated files\");\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_batch_processing_error_isolation() {\n        let processing_config = create_test_processing_config();\n        let qdrant_config = create_test_qdrant_config();\n\n        let processor = Arc::new(\n            DocumentProcessor::new(\u0026processing_config, \u0026qdrant_config)\n                .await\n                .expect(\"Failed to create DocumentProcessor\")\n        );\n\n        // Create a batch of both normal and edge-case files\n        let file_batch = vec![\n            \"normal1.rs\",\n            \"\", // Empty filename\n            \"normal2.py\",\n            \"file with spaces.txt\",\n            \"normal3.md\",\n            \"very/deep/nested/path/file.json\",\n            \"normal4.html\",\n        ];\n\n        let mut handles = vec![];\n        for (i, file_path) in file_batch.iter().enumerate() {\n            let processor_clone = Arc::clone(\u0026processor);\n            let file_path = file_path.to_string();\n            \n            let handle = tokio::spawn(async move {\n                let result = processor_clone.process_document(\u0026file_path).await;\n                (i, file_path, result)\n            });\n            handles.push(handle);\n        }\n\n        let results = futures_util::future::join_all(handles).await;\n\n        // All should succeed (current implementation should handle all edge cases)\n        for result in results {\n            let (index, file_path, process_result) = result.expect(\"Task should not panic\");\n            assert!(process_result.is_ok(), \n                \"Failed to process file '{}' at index {}: {:?}\", \n                file_path, index, process_result.err());\n            \n            let document_id = process_result.unwrap();\n            assert_eq!(document_id.len(), 36);\n            assert!(uuid::Uuid::parse_str(\u0026document_id).is_ok());\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chris","dev","ai","claude-code-cfg","mcp","workspace-qdrant-mcp","rust-engine-legacy","tests","test_daemon_state.rs"],"content":"//! Comprehensive unit tests for daemon/state.rs\n//! Tests state persistence, recovery mechanisms, concurrent access, and error handling\n\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tempfile::{tempdir, NamedTempFile};\nuse tokio::time::timeout;\nuse tokio::task::JoinSet;\nuse sqlx::Row;\nuse workspace_qdrant_daemon::config::DatabaseConfig;\nuse workspace_qdrant_daemon::daemon::state::DaemonState;\nuse workspace_qdrant_daemon::error::DaemonError;\n\n/// Helper function to create test database configuration\nfn create_test_db_config() -\u003e DatabaseConfig {\n    DatabaseConfig {\n        sqlite_path: \"sqlite::memory:\".to_string(),\n        max_connections: 1,\n        connection_timeout_secs: 5,\n        enable_wal: false,\n    }\n}\n\n/// Helper function to create test database configuration with custom path\nfn create_test_db_config_with_path(path: String) -\u003e DatabaseConfig {\n    DatabaseConfig {\n        sqlite_path: path,\n        max_connections: 5,\n        connection_timeout_secs: 10,\n        enable_wal: true,\n    }\n}\n\n/// Helper function to create test database configuration for concurrent access\nfn create_concurrent_db_config() -\u003e DatabaseConfig {\n    DatabaseConfig {\n        sqlite_path: \"sqlite::memory:\".to_string(),\n        max_connections: 10,\n        connection_timeout_secs: 30,\n        enable_wal: true,\n    }\n}\n\n#[cfg(test)]\nmod basic_functionality {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_daemon_state_creation_success() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Verify state was created successfully\n        assert!(!state.pool().is_closed());\n\n        // Test debug formatting\n        let debug_str = format!(\"{:?}\", state);\n        assert!(debug_str.contains(\"DaemonState\"));\n    }\n\n    #[tokio::test]\n    async fn test_daemon_state_creation_with_wal() {\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 5,\n            connection_timeout_secs: 15,\n            enable_wal: true,\n        };\n\n        let state = DaemonState::new(\u0026config).await.unwrap();\n        assert!(!state.pool().is_closed());\n    }\n\n    #[tokio::test]\n    async fn test_health_check_success() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Health check should pass\n        let result = state.health_check().await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_health_check_multiple_calls() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Multiple health checks should all succeed\n        for _ in 0..5 {\n            state.health_check().await.unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_pool_access() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Pool should be accessible and functional\n        let pool = state.pool();\n        assert!(!pool.is_closed());\n\n        // Can execute queries through the pool\n        let result = sqlx::query(\"SELECT 1\")\n            .fetch_one(pool)\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_database_config_validation() {\n        // Test with different connection limits\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 20,\n            connection_timeout_secs: 60,\n            enable_wal: false,\n        };\n\n        let state = DaemonState::new(\u0026config).await.unwrap();\n        state.health_check().await.unwrap();\n    }\n}\n\n#[cfg(test)]\nmod state_persistence {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_migrations_create_required_tables() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Verify all required tables were created\n        let tables = vec![\"projects\", \"collections\", \"processing_operations\"];\n\n        for table_name in tables {\n            let result = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\")\n                .bind(table_name)\n                .fetch_optional(state.pool())\n                .await\n                .unwrap();\n            assert!(result.is_some(), \"Table {} should exist\", table_name);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_projects_table_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Test projects table can accept proper data\n        let result = sqlx::query(r#\"\n            INSERT INTO projects (id, name, root_path, git_repository, git_branch, metadata)\n            VALUES ('test-id', 'test-project', '/test/path', 'https://github.com/test/repo', 'main', '{}')\n        \"#)\n        .execute(state.pool())\n        .await;\n        assert!(result.is_ok());\n\n        // Verify data can be retrieved\n        let row = sqlx::query(\"SELECT * FROM projects WHERE id = 'test-id'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n\n        assert_eq!(row.get::\u003cString, _\u003e(\"name\"), \"test-project\");\n        assert_eq!(row.get::\u003cString, _\u003e(\"root_path\"), \"/test/path\");\n    }\n\n    #[tokio::test]\n    async fn test_collections_table_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // First insert a project (foreign key dependency)\n        sqlx::query(r#\"\n            INSERT INTO projects (id, name, root_path)\n            VALUES ('proj-1', 'test-project', '/test/path')\n        \"#)\n        .execute(state.pool())\n        .await\n        .unwrap();\n\n        // Test collections table can accept proper data\n        let result = sqlx::query(r#\"\n            INSERT INTO collections (id, name, project_id, config)\n            VALUES ('coll-1', 'test-collection', 'proj-1', '{\"vector_size\": 384}')\n        \"#)\n        .execute(state.pool())\n        .await;\n        assert!(result.is_ok());\n\n        // Verify data can be retrieved\n        let row = sqlx::query(\"SELECT * FROM collections WHERE id = 'coll-1'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n\n        assert_eq!(row.get::\u003cString, _\u003e(\"name\"), \"test-collection\");\n        assert_eq!(row.get::\u003cString, _\u003e(\"project_id\"), \"proj-1\");\n    }\n\n    #[tokio::test]\n    async fn test_processing_operations_table_schema() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // First insert a project (foreign key dependency)\n        sqlx::query(r#\"\n            INSERT INTO projects (id, name, root_path)\n            VALUES ('proj-1', 'test-project', '/test/path')\n        \"#)\n        .execute(state.pool())\n        .await\n        .unwrap();\n\n        // Test processing_operations table can accept proper data\n        let result = sqlx::query(r#\"\n            INSERT INTO processing_operations (id, project_id, status, total_documents, processed_documents, failed_documents, error_messages)\n            VALUES ('op-1', 'proj-1', 'in_progress', 100, 50, 2, '[\"error1\", \"error2\"]')\n        \"#)\n        .execute(state.pool())\n        .await;\n        assert!(result.is_ok());\n\n        // Verify data can be retrieved\n        let row = sqlx::query(\"SELECT * FROM processing_operations WHERE id = 'op-1'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n\n        assert_eq!(row.get::\u003cString, _\u003e(\"status\"), \"in_progress\");\n        assert_eq!(row.get::\u003ci64, _\u003e(\"total_documents\"), 100);\n        assert_eq!(row.get::\u003ci64, _\u003e(\"processed_documents\"), 50);\n    }\n\n    #[tokio::test]\n    async fn test_foreign_key_constraints() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Enable foreign key constraints\n        sqlx::query(\"PRAGMA foreign_keys = ON\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        // Try to insert a collection without a valid project (should fail)\n        let result = sqlx::query(r#\"\n            INSERT INTO collections (id, name, project_id, config)\n            VALUES ('coll-1', 'test-collection', 'nonexistent-project', '{}')\n        \"#)\n        .execute(state.pool())\n        .await;\n\n        assert!(result.is_err(), \"Foreign key constraint should prevent this insert\");\n    }\n\n    #[tokio::test]\n    async fn test_migration_idempotency() {\n        let config = create_test_db_config();\n\n        // Run migrations multiple times\n        let state1 = DaemonState::new(\u0026config).await.unwrap();\n        drop(state1);\n\n        let state2 = DaemonState::new(\u0026config).await.unwrap();\n        drop(state2);\n\n        let state3 = DaemonState::new(\u0026config).await.unwrap();\n\n        // Final state should be functional\n        state3.health_check().await.unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_state_persistence_with_file_database() {\n        let temp_dir = tempdir().unwrap();\n        let db_path = temp_dir.path().join(\"test_state.db\");\n        let db_url = format!(\"sqlite://{}?mode=rwc\", db_path.display());\n        let config = create_test_db_config_with_path(db_url);\n\n        // Create state and insert data\n        {\n            let state = DaemonState::new(\u0026config).await.unwrap();\n\n            sqlx::query(r#\"\n                INSERT INTO projects (id, name, root_path)\n                VALUES ('persistent-proj', 'test-project', '/test/path')\n            \"#)\n            .execute(state.pool())\n            .await\n            .unwrap();\n        }\n\n        // Recreate state with same database file\n        {\n            let state = DaemonState::new(\u0026config).await.unwrap();\n\n            // Data should persist\n            let row = sqlx::query(\"SELECT * FROM projects WHERE id = 'persistent-proj'\")\n                .fetch_one(state.pool())\n                .await\n                .unwrap();\n\n            assert_eq!(row.get::\u003cString, _\u003e(\"name\"), \"test-project\");\n        }\n    }\n}\n\n#[cfg(test)]\nmod concurrent_access {\n    use super::*;\n    use std::sync::atomic::{AtomicU32, Ordering};\n    use tokio::task::JoinSet;\n\n    #[tokio::test]\n    async fn test_multiple_state_instances() {\n        let config1 = create_test_db_config();\n        let config2 = create_test_db_config();\n\n        let state1 = DaemonState::new(\u0026config1).await.unwrap();\n        let state2 = DaemonState::new(\u0026config2).await.unwrap();\n\n        // Both should be functional independently\n        state1.health_check().await.unwrap();\n        state2.health_check().await.unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_health_checks() {\n        let config = create_concurrent_db_config();\n        let state = Arc::new(DaemonState::new(\u0026config).await.unwrap());\n\n        let mut tasks = JoinSet::new();\n\n        // Spawn multiple concurrent health checks\n        for _ in 0..10 {\n            let state_clone = Arc::clone(\u0026state);\n            tasks.spawn(async move {\n                state_clone.health_check().await\n            });\n        }\n\n        // All health checks should succeed\n        while let Some(result) = tasks.join_next().await {\n            assert!(result.unwrap().is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_database_operations() {\n        let temp_dir = tempdir().unwrap();\n        let db_path = temp_dir.path().join(\"concurrent_test.db\");\n        let db_url = format!(\"sqlite://{}?mode=rwc\", db_path.display());\n        let config = create_test_db_config_with_path(db_url);\n\n        let state = Arc::new(DaemonState::new(\u0026config).await.unwrap());\n        let counter = Arc::new(AtomicU32::new(0));\n        let mut tasks = JoinSet::new();\n\n        // Spawn multiple concurrent insert operations\n        for i in 0..5 {\n            let state_clone = Arc::clone(\u0026state);\n            let counter_clone = Arc::clone(\u0026counter);\n\n            tasks.spawn(async move {\n                let id = format!(\"concurrent-proj-{}\", i);\n                let name = format!(\"concurrent-project-{}\", i);\n                let path = format!(\"/concurrent/test/path/{}\", i);\n\n                let result = sqlx::query(r#\"\n                    INSERT INTO projects (id, name, root_path)\n                    VALUES (?, ?, ?)\n                \"#)\n                .bind(\u0026id)\n                .bind(\u0026name)\n                .bind(\u0026path)\n                .execute(state_clone.pool())\n                .await;\n\n                if result.is_ok() {\n                    counter_clone.fetch_add(1, Ordering::SeqCst);\n                }\n                result\n            });\n        }\n\n        // Wait for all operations to complete\n        while let Some(result) = tasks.join_next().await {\n            assert!(result.unwrap().is_ok());\n        }\n\n        // Verify all inserts succeeded\n        assert_eq!(counter.load(Ordering::SeqCst), 5);\n\n        // Verify data integrity\n        let count: i64 = sqlx::query_scalar(\"SELECT COUNT(*) FROM projects WHERE name LIKE 'concurrent-project-%'\")\n            .fetch_one(state.pool())\n            .await\n            .unwrap();\n        assert_eq!(count, 5);\n    }\n\n    #[tokio::test]\n    async fn test_connection_pool_management() {\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 3, // Limited pool size\n            connection_timeout_secs: 5,\n            enable_wal: true,\n        };\n\n        let state = Arc::new(DaemonState::new(\u0026config).await.unwrap());\n        let mut tasks = JoinSet::new();\n\n        // Spawn more tasks than the pool size\n        for i in 0..6 {\n            let state_clone = Arc::clone(\u0026state);\n\n            tasks.spawn(async move {\n                // Hold connection briefly\n                let result = sqlx::query(\"SELECT ?\")\n                    .bind(i)\n                    .fetch_one(state_clone.pool())\n                    .await;\n\n                tokio::time::sleep(Duration::from_millis(100)).await;\n                result\n            });\n        }\n\n        // All operations should eventually succeed despite pool limits\n        while let Some(result) = tasks.join_next().await {\n            assert!(result.unwrap().is_ok());\n        }\n    }\n\n    #[tokio::test]\n    async fn test_connection_timeout_handling() {\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 1, // Very limited\n            connection_timeout_secs: 1, // Short timeout\n            enable_wal: false,\n        };\n\n        let state = Arc::new(DaemonState::new(\u0026config).await.unwrap());\n\n        // Start a long-running operation\n        let state_clone = Arc::clone(\u0026state);\n        let _long_task = tokio::spawn(async move {\n            tokio::time::sleep(Duration::from_secs(2)).await;\n            state_clone.health_check().await\n        });\n\n        // Try to use the same connection pool immediately\n        // This should either succeed quickly or timeout appropriately\n        let quick_result = timeout(\n            Duration::from_secs(3),\n            state.health_check()\n        ).await;\n\n        assert!(quick_result.is_ok(), \"Operation should complete within timeout\");\n    }\n}\n\n#[cfg(test)]\nmod error_handling {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_invalid_database_path() {\n        let config = DatabaseConfig {\n            sqlite_path: \"/invalid/nonexistent/path/db.sqlite\".to_string(),\n            max_connections: 1,\n            connection_timeout_secs: 5,\n            enable_wal: false,\n        };\n\n        let result = DaemonState::new(\u0026config).await;\n        assert!(result.is_err());\n\n        match result.unwrap_err() {\n            DaemonError::Database(_) =\u003e {\n                // Expected error type\n            },\n            other =\u003e panic!(\"Expected Database error, got: {:?}\", other),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_invalid_connection_string() {\n        let config = DatabaseConfig {\n            sqlite_path: \"invalid://connection/string\".to_string(),\n            max_connections: 1,\n            connection_timeout_secs: 5,\n            enable_wal: false,\n        };\n\n        let result = DaemonState::new(\u0026config).await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_database_permission_error() {\n        // Create a read-only file to simulate permission error\n        let temp_file = NamedTempFile::new().unwrap();\n        let db_path = temp_file.path();\n\n        // Try to set read-only permissions (may not work on all systems)\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::PermissionsExt;\n            let mut perms = std::fs::metadata(db_path).unwrap().permissions();\n            perms.set_mode(0o444); // Read-only\n            std::fs::set_permissions(db_path, perms).unwrap();\n        }\n\n        let db_url = format!(\"sqlite://{}?mode=rwc\", db_path.display());\n        let config = create_test_db_config_with_path(db_url);\n\n        // This may or may not fail depending on the system\n        // But if it fails, it should be a Database error\n        if let Err(error) = DaemonState::new(\u0026config).await {\n            match error {\n                DaemonError::Database(_) =\u003e {\n                    // Expected error type\n                },\n                other =\u003e panic!(\"Expected Database error, got: {:?}\", other),\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_health_check_on_closed_pool() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Close the pool\n        state.pool().close().await;\n\n        // Health check should fail\n        let result = state.health_check().await;\n        assert!(result.is_err());\n\n        match result.unwrap_err() {\n            DaemonError::Database(_) =\u003e {\n                // Expected error type for closed pool\n            },\n            other =\u003e panic!(\"Expected Database error, got: {:?}\", other),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_migration_failure_recovery() {\n        let config = create_test_db_config();\n\n        // First, create a state successfully\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Manually corrupt the schema by dropping a table\n        sqlx::query(\"DROP TABLE IF EXISTS projects\")\n            .execute(state.pool())\n            .await\n            .unwrap();\n\n        drop(state);\n\n        // Creating a new state should re-run migrations and fix the issue\n        let new_state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Verify tables exist again\n        let result = sqlx::query(\"SELECT name FROM sqlite_master WHERE type='table' AND name='projects'\")\n            .fetch_optional(new_state.pool())\n            .await\n            .unwrap();\n        assert!(result.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_connection_limit_exceeded() {\n        let config = DatabaseConfig {\n            sqlite_path: \"sqlite::memory:\".to_string(),\n            max_connections: 1, // Very limited\n            connection_timeout_secs: 1, // Short timeout\n            enable_wal: false,\n        };\n\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Try to saturate the connection pool\n        let pool = state.pool();\n        let _conn1 = pool.acquire().await.unwrap();\n\n        // Second connection should timeout quickly\n        let conn2_result = timeout(\n            Duration::from_millis(1500),\n            pool.acquire()\n        ).await;\n\n        // Should either timeout or succeed depending on timing\n        // The important thing is it doesn't hang indefinitely\n        assert!(conn2_result.is_ok() || conn2_result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_database_corruption_simulation() {\n        // Create a temporary file that we can corrupt\n        let temp_file = NamedTempFile::new().unwrap();\n        let db_path = temp_file.path();\n\n        // Write some invalid data to simulate corruption\n        std::fs::write(db_path, b\"this is not a valid sqlite database\").unwrap();\n\n        let db_url = format!(\"sqlite://{}?mode=rwc\", db_path.display());\n        let config = create_test_db_config_with_path(db_url);\n\n        // Attempt to open corrupted database should fail\n        let result = DaemonState::new(\u0026config).await;\n        assert!(result.is_err());\n\n        match result.unwrap_err() {\n            DaemonError::Database(_) =\u003e {\n                // Expected error type for corrupted database\n            },\n            other =\u003e panic!(\"Expected Database error for corruption, got: {:?}\", other),\n        }\n    }\n}\n\n#[cfg(test)]\nmod performance_tests {\n    use super::*;\n    use std::time::Instant;\n\n    #[tokio::test]\n    async fn test_state_creation_performance() {\n        let config = create_test_db_config();\n\n        let start = Instant::now();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n        let creation_time = start.elapsed();\n\n        // State creation should be reasonably fast (under 1 second)\n        assert!(creation_time \u003c Duration::from_secs(1),\n                \"State creation took too long: {:?}\", creation_time);\n\n        state.health_check().await.unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_health_check_performance() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Measure health check performance\n        let start = Instant::now();\n        for _ in 0..10 {\n            state.health_check().await.unwrap();\n        }\n        let total_time = start.elapsed();\n\n        // 10 health checks should complete quickly\n        assert!(total_time \u003c Duration::from_millis(500),\n                \"Health checks took too long: {:?}\", total_time);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_operation_performance() {\n        let config = create_concurrent_db_config();\n        let state = Arc::new(DaemonState::new(\u0026config).await.unwrap());\n\n        let start = Instant::now();\n        let mut tasks = JoinSet::new();\n\n        // Launch many concurrent operations\n        for i in 0..20 {\n            let state_clone = Arc::clone(\u0026state);\n            tasks.spawn(async move {\n                let id = format!(\"perf-proj-{}\", i);\n                sqlx::query(r#\"\n                    INSERT INTO projects (id, name, root_path)\n                    VALUES (?, ?, ?)\n                \"#)\n                .bind(\u0026id)\n                .bind(format!(\"project-{}\", i))\n                .bind(format!(\"/path/{}\", i))\n                .execute(state_clone.pool())\n                .await\n            });\n        }\n\n        // Wait for all to complete\n        while let Some(result) = tasks.join_next().await {\n            assert!(result.unwrap().is_ok());\n        }\n\n        let total_time = start.elapsed();\n\n        // 20 concurrent operations should complete in reasonable time\n        assert!(total_time \u003c Duration::from_secs(5),\n                \"Concurrent operations took too long: {:?}\", total_time);\n    }\n\n    #[tokio::test]\n    async fn test_large_dataset_handling() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Insert a moderate amount of data\n        let start = Instant::now();\n        for i in 0..100 {\n            sqlx::query(r#\"\n                INSERT INTO projects (id, name, root_path, metadata)\n                VALUES (?, ?, ?, ?)\n            \"#)\n            .bind(format!(\"large-proj-{}\", i))\n            .bind(format!(\"Large Project {}\", i))\n            .bind(format!(\"/large/path/{}\", i))\n            .bind(format!(r#\"{{\"index\": {}, \"size\": \"large\"}}\"#, i))\n            .execute(state.pool())\n            .await\n            .unwrap();\n        }\n        let insert_time = start.elapsed();\n\n        // Query all data back\n        let start = Instant::now();\n        let rows = sqlx::query(\"SELECT * FROM projects WHERE name LIKE 'Large Project%'\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n        let query_time = start.elapsed();\n\n        assert_eq!(rows.len(), 100);\n\n        // Operations should complete in reasonable time\n        assert!(insert_time \u003c Duration::from_secs(2),\n                \"Large insert took too long: {:?}\", insert_time);\n        assert!(query_time \u003c Duration::from_millis(500),\n                \"Large query took too long: {:?}\", query_time);\n    }\n\n    #[tokio::test]\n    async fn test_memory_usage_stability() {\n        // Create and destroy many state instances with in-memory databases\n        for iteration in 0..10 {\n            let config = create_test_db_config();\n            let state = DaemonState::new(\u0026config).await.unwrap();\n\n            // Do some operations\n            for i in 0..10 {\n                sqlx::query(r#\"\n                    INSERT INTO projects (id, name, root_path)\n                    VALUES (?, ?, ?)\n                \"#)\n                .bind(format!(\"mem-test-{}-{}\", iteration, i))\n                .bind(format!(\"Memory Test {} {}\", iteration, i))\n                .bind(format!(\"/memory/test/{}/{}\", iteration, i))\n                .execute(state.pool())\n                .await\n                .unwrap();\n            }\n\n            state.health_check().await.unwrap();\n\n            // State should be dropped here\n        }\n\n        // If we get here without OOM, memory management is working\n        assert!(true, \"Memory usage remained stable\");\n    }\n}\n\n#[cfg(test)]\nmod integration_tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_config_to_state_integration() {\n        // Test various configuration options\n        let configs = vec![\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 1,\n                connection_timeout_secs: 5,\n                enable_wal: false,\n            },\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 5,\n                connection_timeout_secs: 30,\n                enable_wal: true,\n            },\n            DatabaseConfig {\n                sqlite_path: \"sqlite::memory:\".to_string(),\n                max_connections: 10,\n                connection_timeout_secs: 60,\n                enable_wal: true,\n            },\n        ];\n\n        for config in configs {\n            let state = DaemonState::new(\u0026config).await.unwrap();\n            state.health_check().await.unwrap();\n\n            // Verify basic functionality works with each config\n            sqlx::query(r#\"\n                INSERT INTO projects (id, name, root_path)\n                VALUES ('integration-test', 'Integration Project', '/integration/path')\n            \"#)\n            .execute(state.pool())\n            .await\n            .unwrap();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_state_schema_completeness() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Test that all required tables have expected columns\n        let projects_columns = sqlx::query(\"PRAGMA table_info(projects)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n\n        let expected_project_columns = vec![\n            \"id\", \"name\", \"root_path\", \"git_repository\",\n            \"git_branch\", \"metadata\", \"created_at\", \"updated_at\"\n        ];\n\n        for expected_col in expected_project_columns {\n            assert!(\n                projects_columns.iter().any(|row| {\n                    row.get::\u003cString, _\u003e(\"name\") == expected_col\n                }),\n                \"Projects table missing column: {}\",\n                expected_col\n            );\n        }\n\n        let collections_columns = sqlx::query(\"PRAGMA table_info(collections)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n\n        let expected_collection_columns = vec![\n            \"id\", \"name\", \"project_id\", \"config\", \"created_at\"\n        ];\n\n        for expected_col in expected_collection_columns {\n            assert!(\n                collections_columns.iter().any(|row| {\n                    row.get::\u003cString, _\u003e(\"name\") == expected_col\n                }),\n                \"Collections table missing column: {}\",\n                expected_col\n            );\n        }\n\n        let processing_columns = sqlx::query(\"PRAGMA table_info(processing_operations)\")\n            .fetch_all(state.pool())\n            .await\n            .unwrap();\n\n        let expected_processing_columns = vec![\n            \"id\", \"project_id\", \"status\", \"total_documents\",\n            \"processed_documents\", \"failed_documents\", \"error_messages\",\n            \"started_at\", \"updated_at\"\n        ];\n\n        for expected_col in expected_processing_columns {\n            assert!(\n                processing_columns.iter().any(|row| {\n                    row.get::\u003cString, _\u003e(\"name\") == expected_col\n                }),\n                \"Processing operations table missing column: {}\",\n                expected_col\n            );\n        }\n    }\n\n    #[tokio::test]\n    async fn test_cross_table_relationships() {\n        let config = create_test_db_config();\n        let state = DaemonState::new(\u0026config).await.unwrap();\n\n        // Create a complete data hierarchy\n        let project_id = \"rel-test-project\";\n        let collection_id = \"rel-test-collection\";\n        let operation_id = \"rel-test-operation\";\n\n        // Insert project\n        sqlx::query(r#\"\n            INSERT INTO projects (id, name, root_path, git_repository, git_branch, metadata)\n            VALUES (?, ?, ?, ?, ?, ?)\n        \"#)\n        .bind(project_id)\n        .bind(\"Relationship Test Project\")\n        .bind(\"/rel/test/path\")\n        .bind(\"https://github.com/test/repo\")\n        .bind(\"main\")\n        .bind(r#\"{\"test\": true}\"#)\n        .execute(state.pool())\n        .await\n        .unwrap();\n\n        // Insert collection linked to project\n        sqlx::query(r#\"\n            INSERT INTO collections (id, name, project_id, config)\n            VALUES (?, ?, ?, ?)\n        \"#)\n        .bind(collection_id)\n        .bind(\"Relationship Test Collection\")\n        .bind(project_id)\n        .bind(r#\"{\"vector_size\": 384, \"metric\": \"cosine\"}\"#)\n        .execute(state.pool())\n        .await\n        .unwrap();\n\n        // Insert processing operation linked to project\n        sqlx::query(r#\"\n            INSERT INTO processing_operations (id, project_id, status, total_documents, processed_documents, failed_documents, error_messages)\n            VALUES (?, ?, ?, ?, ?, ?, ?)\n        \"#)\n        .bind(operation_id)\n        .bind(project_id)\n        .bind(\"completed\")\n        .bind(50)\n        .bind(48)\n        .bind(2)\n        .bind(r#\"[\"timeout on large file\", \"parsing error\"]\"#)\n        .execute(state.pool())\n        .await\n        .unwrap();\n\n        // Query relationships\n        let project_data = sqlx::query(r#\"\n            SELECT\n                p.*,\n                COUNT(DISTINCT c.id) as collection_count,\n                COUNT(DISTINCT po.id) as operation_count\n            FROM projects p\n            LEFT JOIN collections c ON p.id = c.project_id\n            LEFT JOIN processing_operations po ON p.id = po.project_id\n            WHERE p.id = ?\n            GROUP BY p.id\n        \"#)\n        .bind(project_id)\n        .fetch_one(state.pool())\n        .await\n        .unwrap();\n\n        assert_eq!(project_data.get::\u003cString, _\u003e(\"name\"), \"Relationship Test Project\");\n        assert_eq!(project_data.get::\u003ci64, _\u003e(\"collection_count\"), 1);\n        assert_eq!(project_data.get::\u003ci64, _\u003e(\"operation_count\"), 1);\n    }\n}","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>