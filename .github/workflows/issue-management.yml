name: Issue Management

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created]
  pull_request:
    types: [closed]
  push:
    branches: [main]

jobs:
  auto-label-issues:
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'edited')
    runs-on: ubuntu-latest
    
    steps:
      - name: Auto-label based on content
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = issue.body ? issue.body.toLowerCase() : '';
            const content = title + ' ' + body;
            
            const labels = [];
            
            // Component labels based on keywords
            if (content.includes('daemon') || content.includes('memexd') || content.includes('rust')) {
              labels.push('daemon');
            }
            if (content.includes('mcp') || content.includes('mcp server') || content.includes('python')) {
              labels.push('mcp-server');
            }
            if (content.includes('cli') || content.includes('wqm') || content.includes('command line')) {
              labels.push('cli');
            }
            if (content.includes('web') || content.includes('ui') || content.includes('interface') || content.includes('frontend')) {
              labels.push('web-ui');
            }
            if (content.includes('auto-ingestion') || content.includes('file watching') || content.includes('ingestion')) {
              labels.push('auto-ingestion');
            }
            if (content.includes('service') || content.includes('installation') || content.includes('install')) {
              labels.push('service-management');
            }
            if (content.includes('config') || content.includes('configuration') || content.includes('yaml')) {
              labels.push('configuration');
            }
            if (content.includes('documentation') || content.includes('docs') || content.includes('readme')) {
              labels.push('documentation');
            }
            if (content.includes('test') || content.includes('testing') || content.includes('pytest')) {
              labels.push('tests');
            }
            
            // Priority labels based on keywords
            if (content.includes('critical') || content.includes('urgent') || content.includes('blocking') || content.includes('crash')) {
              labels.push('critical');
            } else if (content.includes('high priority') || content.includes('important') || content.includes('major')) {
              labels.push('high-priority');
            } else if (content.includes('low priority') || content.includes('minor') || content.includes('nice to have')) {
              labels.push('low-priority');
            } else {
              labels.push('medium-priority');
            }
            
            // Type labels based on content
            if (content.includes('bug') || content.includes('error') || content.includes('fail') || content.includes('crash') || content.includes('broken')) {
              labels.push('bug');
            } else if (content.includes('feature') || content.includes('enhancement') || content.includes('improve') || content.includes('add')) {
              labels.push('enhancement');
            } else if (content.includes('question') || content.includes('how to') || content.includes('help')) {
              labels.push('question');
            }
            
            // Platform labels
            if (content.includes('macos') || content.includes('mac os') || content.includes('darwin')) {
              labels.push('macos');
            }
            if (content.includes('linux') || content.includes('ubuntu') || content.includes('debian')) {
              labels.push('linux');
            }
            if (content.includes('windows') || content.includes('win32')) {
              labels.push('windows');
            }
            
            // Performance labels
            if (content.includes('performance') || content.includes('slow') || content.includes('optimization') || content.includes('memory')) {
              labels.push('performance');
            }
            
            // Add triage label for new issues
            if (github.event.action === 'opened') {
              labels.push('triage');
            }
            
            // Apply labels if any were identified
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: [...new Set(labels)] // Remove duplicates
              });
            }

  auto-close-issues:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    
    steps:
      - name: Auto-close issues from commits
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commits = context.payload.commits || [];
            
            for (const commit of commits) {
              const message = commit.message;
              
              // Look for issue references in commit messages
              const issuePatterns = [
                /(?:fix|fixes|fixed|close|closes|closed|resolve|resolves|resolved)[\s:]+(#\d+)/gi,
                /(?:fix|fixes|fixed|close|closes|closed|resolve|resolves|resolved)[\s:]+(?:https:\/\/github\.com\/[^\/]+\/[^\/]+\/issues\/)(\d+)/gi
              ];
              
              for (const pattern of issuePatterns) {
                let match;
                while ((match = pattern.exec(message)) !== null) {
                  const issueNumber = match[1].startsWith('#') ? match[1].slice(1) : match[1];
                  
                  try {
                    // Check if issue exists and is open
                    const issue = await github.rest.issues.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: parseInt(issueNumber)
                    });
                    
                    if (issue.data.state === 'open') {
                      // Add comment before closing
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: parseInt(issueNumber),
                        body: `This issue was automatically closed by commit ${commit.id.substring(0, 7)}: ${commit.message.split('\n')[0]}\n\nCommit: ${commit.url}`
                      });
                      
                      // Close the issue
                      await github.rest.issues.update({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: parseInt(issueNumber),
                        state: 'closed'
                      });
                      
                      console.log(`Closed issue #${issueNumber} via commit ${commit.id.substring(0, 7)}`);
                    }
                  } catch (error) {
                    console.log(`Issue #${issueNumber} not found or error occurred:`, error.message);
                  }
                }
              }
            }

  link-pr-to-issues:
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    
    steps:
      - name: Link merged PR to issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || '';
            const prTitle = pr.title || '';
            const content = prTitle + ' ' + prBody;
            
            // Look for issue references in PR title and body
            const issuePattern = /#(\d+)/g;
            let match;
            
            while ((match = issuePattern.exec(content)) !== null) {
              const issueNumber = match[1];
              
              try {
                // Add comment to issue about the merged PR
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  body: `Related PR #${pr.number} has been merged: ${pr.title}\n\nPR: ${pr.html_url}`
                });
                
                console.log(`Added PR reference to issue #${issueNumber}`);
              } catch (error) {
                console.log(`Could not reference issue #${issueNumber}:`, error.message);
              }
            }