# Product Requirements Document (PRD) - Consolidated Architecture

**Project:** workspace-qdrant-mcp
**Version:** v3.0
**target code version**: v0.3.0dev0
**Date:** 2025-09-20 15:00
**Document Type:** Consolidated Architecture PRD - Complete System Specification

## 1. Executive Summary and Strategic Vision

### 1.1 Core Philosophy

The workspace-qdrant-mcp transforms from a vector database tool into a comprehensive **memory-driven semantic workspace platform** designed around how LLM agents naturally interact with project knowledge. The system embodies eight core architectural principles:

**Memory-Driven**: LLM behavior controlled by persistent user preferences and behavioral rules that survive across sessions and automatically inject into system context.

**Semantic-First**: Every piece of content becomes searchable knowledge with semantic relationships - code, documents, books, web pages unified through vector embeddings while respecting content-specific processing needs.

**Project-Aware**: Automatic project detection and context management with four-tier search hierarchy (project → collection → global → all) that matches LLM reasoning patterns.

**Intelligent Processing**: LSP-enhanced code understanding, document conversion, and real-time semantic extraction that transforms file watching into knowledge discovery.

**Secure Resumable Operations**: All operations are atomic, recoverable, and resume seamlessly from any interruption point with transactional safety and automatic recovery.

**Leverage Existing Solutions**: Build on proven, established tools (LSP servers, gRPC, SQLite) rather than reinventing solutions, following standard protocols over custom implementations.

**Graceful Degradation**: System functionality degrades gracefully when components fail, maintaining core value with reduced features rather than complete failure.

**Component Separation**: Four-component architecture enables distinct concerns: heavy processing, intelligent interface, user control, and real-time integration with clear responsibility boundaries.

### 1.2 The Fundamental Challenge

**How do LLM agents naturally want to interact with project-scoped semantic knowledge while maintaining persistent behavioral memory?**

This question drives every architectural decision. Instead of forcing LLM agents to learn database query patterns, we design around their natural conversational patterns, project-aware reasoning, and need for behavioral consistency.

### 1.3 Strategic Outcomes

- **Memory Persistence**: "For future reference, always use uv for Python" → automatically active in every session
- **Unified Discovery**: "Find async patterns" → returns code examples + documentation + book chapters + notes
- **Project Intelligence**: Working in project directory automatically activates project collections and watches
- **Conversational Control**: System behavior updates through natural conversation, not configuration files
- **Semantic Relationships**: Content discovery through meaning, not format-specific searches

## 2. Four-Component Architecture Overview

### 2.1 Architectural Foundation

The system implements a **four-component architecture** with clear separation of concerns, optimized for different aspects of semantic workspace management:

**Component 1: Ingestion and Watching Daemon (Rust Engine)**
- **Role**: Heavy Processing Powerhouse
- **Responsibilities**: File ingestion, LSP integration, document conversion, embedding generation, file watching
- **Performance**: 1000+ documents/minute processing, <500MB memory usage
- **Communication**: gRPC server for MCP interface, SQLite for state management

**Component 2: MCP Server (Python MCP)**
- **Role**: Intelligent Interface Layer
- **Responsibilities**: Search interface, memory management, conversational updates, Claude Code integration
- **Performance**: Sub-100ms query responses, session initialization with rule injection
- **Communication**: gRPC client to daemon, MCP protocol to Claude Code

**Component 3: CLI Utility (wqm)**
- **Role**: User Control and Administration
- **Responsibilities**: System administration, library management, configuration, daemon lifecycle
- **Interface**: Single unified CLI with domain-specific subcommands
- **Scope**: Complete system control without requiring MCP server

**Component 4: Context Injector (LSP Integration/Hook)**
- **Role**: Inject LLM rules into the context
- **Responsibilities**: Fetch rules and push them into the LLM context before the first user prompt
- **Integration**: Rules are provided by the daemon from a dedicated collection
- **Capabilities**: Simple streaming of data/text into the LLM context, triggered by hooks

### 2.2 Component Communication Protocol

**Primary Flow**: MCP Server ↔ gRPC ↔ Daemon (with embedded Injector)
**Control Flow**: wqm ↔ SQLite State Database ↔ Daemon Signal Handling
**Data Flow**: File System Events → LSP Injector → Daemon Processing → Vector Storage
**Session Flow**: Claude Code → MCP Server → Memory Rule Injection → System Context (tbc, might not require the MCP Server)

**Graceful Lifecycle Management with Transactional Safety**:
1. MCP Server startup triggers daemon initialization (for new projects) and activation with state recovery check
2. All operations are atomic with SQLite transaction boundaries and rollback capability
3. Daemon launched at startup and work on its queue with low process priority, priority shifted once the MCP Server is up
4. MCP Server signals daemon on quit, daemon revert to low priority mode, while continuing on its queue
5. Unfinished operations are detected on restart and resumed
6. Data loss prevention: No work is lost due to crashes, interruptions, or component failures

## 2.3 Complete System Configuration Reference

**IMPORTANT**: This section provides the COMPLETE and EXHAUSTIVE configuration reference for the workspace-qdrant-mcp system. Every configuration option mentioned throughout this PRD is documented here with full details, defaults, constraints, and examples. This is the single source of truth for all system configuration.

```yaml
# =============================================================================
# WORKSPACE-QDRANT-MCP - COMPLETE SYSTEM CONFIGURATION
# =============================================================================
# Version: v2.0
# Date: 2025-09-20
#
# This configuration file contains EVERY configuration option for the complete
# workspace-qdrant-mcp system. Each option is fully documented with:
# - Purpose and behavior
# - Default values and valid ranges
# - Examples and constraints
# - Dependencies and cross-references
# - Platform-specific considerations
# =============================================================================

# =============================================================================
# 1. SYSTEM ARCHITECTURE & CORE SETTINGS
# =============================================================================
system:
  # System identification and versioning
  project_name: "workspace-qdrant-mcp"
  # Valid values: any string identifier for the system
  # Default: "workspace-qdrant-mcp"
  # Purpose: Used for logging, state management, and system identification

  version: "v2.0"
  # Valid values: semantic version string (vX.Y.Z)
  # Default: current system version
  # Purpose: Determines configuration compatibility and migration needs

  # Four-component architecture enablement
  components:
    rust_daemon:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Enable/disable the heavy processing Rust engine
      # Dependencies: Required for file processing, LSP integration, and watching

    python_mcp_server:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Enable/disable the intelligent interface layer
      # Dependencies: Required for Claude Code integration and memory management

    cli_utility:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Enable/disable the wqm CLI utility
      # Dependencies: Can operate independently of other components

    context_injector:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Enable/disable LLM context injection
      # Dependencies: Requires memory collection for rule injection

# =============================================================================
# 2. MEMORY COLLECTION CONFIGURATION
# =============================================================================
memory:
  # Core memory collection settings
  collection_name: "llm_rules"
  # Valid values: any valid collection name string
  # Default: "llm_rules"
  # Purpose: Global behavioral rules and user preferences storage
  # Note: Configurable collection name for LLM behavioral rules and user preferences

  # Authority levels for memory rules
  authority_levels:
    absolute:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Non-negotiable rules that always apply
      # Examples: "Always make atomic commits", "Never commit secrets"

    default:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Rules that apply unless explicitly overridden
      # Examples: "Use pytest for new projects, unittest for existing"

  # Conversational memory update settings
  conversational_updates:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Allow memory rules to be updated through natural conversation

    auto_conflict_detection: true
    # Valid values: true, false
    # Default: true
    # Purpose: Automatically detect conflicts between new and existing rules
    # Dependencies: Requires Claude/Sonnet API access for semantic analysis

    immediate_activation: true
    # Valid values: true, false
    # Default: true
    # Purpose: Apply memory changes to current session without restart

  # Rule conflict resolution strategies
  conflict_resolution:
    strategy: "merge_conditional"
    # Valid values: "merge_conditional", "replace_existing", "reject_new", "user_prompt"
    # Default: "merge_conditional"
    # Purpose: How to handle conflicts between memory rules
    # Examples:
    #   merge_conditional: Create conditional rules (recommended)
    #   replace_existing: New rule overwrites old rule
    #   reject_new: Keep existing rule, reject new rule
    #   user_prompt: Present options to user for decision

    user_prompt_timeout_seconds: 30
    # Valid values: 10-300 seconds
    # Default: 30
    # Purpose: How long to wait for user input during conflict resolution

  # Token management and optimization
  token_management:
    max_tokens: 2000
    # Valid values: 500-8000 tokens
    # Default: 2000
    # Purpose: Maximum tokens for memory rules injection
    # Considerations: Higher values provide more context but consume more tokens

    optimization_enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable automatic token usage optimization

    trim_interactive: true
    # Valid values: true, false
    # Default: true
    # Purpose: Provide interactive trimming when approaching token limits

  # Memory rule scoping
  rule_scope:
    all_sessions: true
    # Valid values: true, false
    # Default: true
    # Purpose: Apply rules across all Claude Code sessions

    project_specific: true
    # Valid values: true, false
    # Default: true
    # Purpose: Allow project-specific memory rules

    temporary_rules: true
    # Valid values: true, false
    # Default: true
    # Purpose: Support temporary rules that expire after session/time

    temporary_rule_duration_hours: 24
    # Valid values: 1-168 hours (1 hour to 1 week)
    # Default: 24
    # Purpose: Default expiration time for temporary rules

  # Session initialization settings
  session_initialization:
    rule_injection_enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Inject memory rules into Claude Code system context on startup

    conflict_detection_on_startup: true
    # Valid values: true, false
    # Default: true
    # Purpose: Check for rule conflicts during session initialization

    startup_timeout_seconds: 10
    # Valid values: 5-60 seconds
    # Default: 10
    # Purpose: Maximum time to spend on memory initialization

# =============================================================================
# 3. COLLECTION MANAGEMENT & MULTI-TENANCY
# =============================================================================
collections:
  # Project collection naming and creation
  root_name: "project"
  # Valid values: any valid collection name string
  # Default: "project"
  # Purpose: Root name used for multi-tenant project collections
  # Usage: Combined with types to create {root_name}-{type} collections

  types: []
  # Valid values: string or array of strings, empty means no collections created
  # Default: [] (no project collections created by default)
  # Purpose: Collection types to create for projects
  # Examples: ["scratchbook", "docs", "notes"] creates project-scratchbook, project-docs, project-notes
  # Note: If empty or not present, no project collections are automatically created

  # Library collection behavior (NOT CONFIGURABLE - hardcoded)
  # Note: Library collections are created via 'wqm library' commands, not configuration
  # System automatically prefixes library names with "_" to mark them as read-only from MCP
  # Examples: 'wqm library create technical-books' creates "_technical-books" collection
  # UI Display: Users interact with "technical-books" but system stores as "_technical-books"
  # Collision Prevention: Cannot have both "_library" and "library" collections simultaneously

  # Project content collection (for file artifacts)
  project_content:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable multi-tenant project content collection for file artifacts

    name: "project_content"
    # Valid values: any valid collection name string
    # Default: "project_content"
    # Purpose: Base name for the shared, multi-tenant collection containing project artifacts
    # Storage: System automatically creates "_project_content" (read-only from MCP perspective)
    # Content: Non-excluded project files (code, documentation, configuration files)
    # Multi-tenancy: Projects isolated via metadata filtering, not separate collections

  # Reserved naming patterns and validation
  naming:
    reserved_patterns:
      - "${memory.collection_name}"  # Global memory collection (configurable)
      - "_*"                         # Library collection prefix (hardcoded)
      - "__*"                        # System-internal collections (hardcoded)
      # Valid values: array of glob patterns
      # Default: ["${memory.collection_name}", "_*", "__*"]
      # Purpose: Prevent conflicts with system-reserved collection names
      # Note: Memory collection name is configurable, prefixes are hardcoded

    collision_detection: true
    # Valid values: true, false
    # Default: true
    # Purpose: Prevent duplicate collection names at server level
    # Collision Rule: If "_collection_name" exists, "collection_name" cannot be created

    validation_strict: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enforce strict naming rules vs. permissive validation

    prefix_rules:
      underscore_prefix:
        read_only_from_mcp: true
        # Valid values: true (hardcoded, not configurable)
        # Purpose: Collections with "_" prefix are read-only from MCP server perspective
        hidden_prefix_in_ui: true
        # Valid values: true (hardcoded, not configurable)
        # Purpose: UI shows "library" but stores as "_library"
        prevents_collision: true
        # Valid values: true (hardcoded, not configurable)
        # Purpose: Cannot create "library" if "_library" exists

      double_underscore_prefix:
        system_internal: true
        # Valid values: true (hardcoded, not configurable)
        # Purpose: "__" prefix reserved for system-internal collections

  # Multi-tenancy isolation settings
  multi_tenancy:
    isolation_strategy: "metadata_filtering"
    # Valid values: "metadata_filtering", "separate_collections"
    # Default: "metadata_filtering"
    # Purpose: How to isolate projects within collections
    # metadata_filtering: Use metadata to filter within shared collections
    # separate_collections: Create separate collections per project

    cross_project_search: true
    # Valid values: true, false
    # Default: true
    # Purpose: Allow searches across project boundaries when explicitly requested

    tenant_metadata_fields:
      - "project_id"
      - "project_path"
      - "git_repository"
      # Valid values: array of metadata field names
      # Default: ["project_id", "project_path", "git_repository"]
      # Purpose: Metadata fields used for multi-tenant isolation

  # Note: Collection access control is determined by naming conventions (not configurable):
  # - Collections with "_" prefix: Read-only from MCP server, read-write from CLI/daemon
  # - Collections with "__" prefix: System-internal, no MCP access
  # - ${memory.collection_name}: Special exception - read-write from both MCP and CLI
  # - Project collections (${collections.root_name}-{type}): Read-write from MCP server

# =============================================================================
# 4. PROJECT DETECTION & MANAGEMENT
# =============================================================================
project_detection:
  # Git-based project detection (primary method)
  git_detection:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Use Git repositories as primary project detection method

    priority: 1
    # Valid values: 1-10 (1 = highest priority)
    # Default: 1
    # Purpose: Priority order for project detection methods

    require_initialized: true
    # Valid values: true, false
    # Default: true
    # Purpose: Require initialized Git repository, not just .git folder

    scan_parent_directories: true
    # Valid values: true, false
    # Default: true
    # Purpose: Scan parent directories to find project root

    max_parent_scan_depth: 10
    # Valid values: 1-50 directory levels
    # Default: 10
    # Purpose: Maximum levels to scan upward for project root

  # GitHub user configuration for submodule handling
  github_integration:
    user: ""
    # Valid values: GitHub username string or empty
    # Default: ""
    # Purpose: GitHub username for submodule ownership detection
    # Usage: Determines which submodules are treated as user-owned projects

    submodule_handling:
      treat_as_independent_projects: true
      # Valid values: true, false
      # Default: true
      # Purpose: Treat user-owned submodules as independent project tenants

      ignore_external_submodules: true
      # Valid values: true, false
      # Default: true
      # Purpose: Ignore submodules not owned by configured GitHub user

      track_ownership_changes: true
      # Valid values: true, false
      # Default: true
      # Purpose: Monitor submodule ownership changes (e.g., forks)

  # Custom project indicators (fallback method)
  custom_indicators:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Use custom file patterns to detect projects

    priority: 2
    # Valid values: 1-10 (1 = highest priority)
    # Default: 2
    # Purpose: Priority order for project detection methods

    # Hardcoded patterns embedded at compile-time
    patterns:
      version_control:
        - ".git"
        - ".hg"
        - ".svn"
      language_ecosystems:
        - "package.json"       # Node.js
        - "pyproject.toml"     # Python
        - "Cargo.toml"         # Rust
        - "pom.xml"            # Java Maven
        - "build.gradle"       # Java Gradle
        - "go.mod"             # Go
        - "composer.json"      # PHP
        - "Gemfile"            # Ruby
        - "mix.exs"            # Elixir
        - "dune-project"       # OCaml
      build_systems:
        - "Makefile"
        - "CMakeLists.txt"
        - "meson.build"
        - "BUILD.bazel"
      ci_cd:
        - ".github/"
        - ".gitlab-ci.yml"
        - ".travis.yml"
        - "azure-pipelines.yml"
        - "Jenkinsfile"
      # Valid values: arrays of file/directory patterns
      # Default: comprehensive list of common project indicators
      # Purpose: Detect projects when Git repositories not available
      # Note: These patterns are embedded at compile-time for performance

  # Project naming and collection creation
  naming:
    root_name_strategy: "directory_name"
    # Valid values: "directory_name", "git_remote_name", "explicit_config"
    # Default: "directory_name"
    # Purpose: How to determine project root name for collection naming

    collection_auto_creation: true
    # Valid values: true, false
    # Default: true
    # Purpose: Automatically create project collections when MCP server starts

    prevent_project_explosion: true
    # Valid values: true, false
    # Default: true
    # Purpose: Prevent uncontrolled creation of project collections
    # Implementation: Check if current folder is part of existing project

# =============================================================================
# 5. LSP INTEGRATION & CODE INTELLIGENCE
# =============================================================================
lsp_integration:
  # Core LSP settings
  enabled: true
  # Valid values: true, false
  # Default: true
  # Purpose: Enable Language Server Protocol integration for code intelligence

  auto_detection: true
  # Valid values: true, false
  # Default: true
  # Purpose: Automatically detect available LSP servers in PATH

  auto_installation: false
  # Valid values: true, false
  # Default: false
  # Purpose: User maintains control over LSP server versions (never auto-install)
  # Philosophy: Respect user autonomy over development environment

  # LSP server configuration
  servers:
    python:
      primary: "ruff-lsp"
      # Valid values: LSP server executable name
      # Default: "ruff-lsp"
      # Rationale: Fastest Python LSP, project-wide analysis, actively developed
      # Features: symbols, definitions, references, hover, diagnostics

    rust:
      primary: "rust-analyzer"
      # Valid values: LSP server executable name
      # Default: "rust-analyzer"
      # Rationale: Official Rust LSP, comprehensive analysis, excellent performance
      # Features: symbols, definitions, references, hover, inlay_hints, call_hierarchy

    javascript:
      primary: "typescript-language-server"
      # Valid values: LSP server executable name
      # Default: "typescript-language-server"
      # Rationale: Official TypeScript LSP, works for JS/TS, project-wide intelligence
      # Features: symbols, definitions, references, hover, refactoring

    typescript:
      primary: "typescript-language-server"
      # Valid values: LSP server executable name
      # Default: "typescript-language-server"
      # Rationale: Official TypeScript LSP, works for JS/TS, project-wide intelligence

    java:
      primary: "eclipse.jdt.ls"
      # Valid values: LSP server executable name
      # Default: "eclipse.jdt.ls"
      # Rationale: Most mature Java LSP, excellent project analysis
      # Features: symbols, definitions, references, hover, workspace_symbols

    c_cpp:
      primary: "clangd"
      # Valid values: LSP server executable name
      # Default: "clangd"
      # Rationale: LLVM-based, fast, comprehensive C/C++ support
      # Features: symbols, definitions, references, hover, completion

    go:
      primary: "gopls"
      # Valid values: LSP server executable name
      # Default: "gopls"
      # Rationale: Official Go LSP, excellent performance and features
      # Features: symbols, definitions, references, hover, workspace_symbols

  # Health monitoring and graceful degradation
  health_monitoring:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Monitor LSP server health and performance

    check_interval_seconds: 30
    # Valid values: 10-300 seconds
    # Default: 30
    # Purpose: How often to check LSP server health

    automatic_recovery: true
    # Valid values: true, false
    # Default: true
    # Purpose: Automatically restart failed LSP servers

    max_restart_attempts: 3
    # Valid values: 1-10 attempts
    # Default: 3
    # Purpose: Maximum automatic restart attempts before giving up

  # Graceful degradation levels
  degradation:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable graceful degradation when LSP servers fail

    level_1_lsp_crash:
      action: "continue_text_only"
      # Valid values: "continue_text_only", "disable_processing", "retry_immediately"
      # Default: "continue_text_only"
      # Purpose: Continue with text-only processing when LSP crashes
      notify_user: true

    level_2_protocol_errors:
      action: "fallback_basic_symbols"
      # Valid values: "fallback_basic_symbols", "disable_analysis", "queue_for_recovery"
      # Default: "fallback_basic_symbols"
      # Purpose: Fall back to basic symbol extraction on protocol errors
      queue_advanced_analysis: true

    level_3_resource_constraints:
      action: "disable_background_analysis"
      # Valid values: "disable_background_analysis", "reduce_priority", "temporary_shutdown"
      # Default: "disable_background_analysis"
      # Purpose: Disable background analysis under resource pressure
      prioritize_user_queries: true

    level_4_complete_failure:
      action: "maintain_other_functionality"
      # Valid values: "maintain_other_functionality", "shutdown_component", "fallback_mode"
      # Default: "maintain_other_functionality"
      # Purpose: Continue non-LSP functionality when LSP completely fails
      clear_user_communication: true

  # Data collection strategy
  data_collection:
    strategy: "interface_plus_minimal_context"
    # Valid values: "interface_plus_minimal_context", "full_content", "symbols_only"
    # Default: "interface_plus_minimal_context"
    # Purpose: Balance between information richness and storage efficiency

    include_in_vectors:
      - "complete_function_signatures"
      - "class_definitions_with_inheritance"
      - "import_statements_and_dependencies"
      - "documentation_strings_and_comments"
      - "type_annotations_and_signatures"
      - "small_context_snippets"  # 1-3 lines around definitions
      # Valid values: array of content types to include in vector embeddings
      # Purpose: Define what LSP-extracted content gets vectorized

    exclude_from_vectors:
      - "full_method_implementations"  # prevents storage duplication
      - "detailed_implementation_logic"  # available in file content
      - "large_code_blocks"  # rely on file content for details
      # Valid values: array of content types to exclude from vector embeddings
      # Purpose: Prevent duplication and reduce storage requirements

    metadata_extraction:
      symbols:
        - "function_names_and_signatures"
        - "class_definitions_and_inheritance"
        - "variable_declarations_with_types"
        - "module_and_import_structure"
      relationships:
        - "import_dependencies_and_usage"
        - "inheritance_hierarchies"
        - "function_call_graphs"
        - "cross_file_references"
      semantic_information:
        - "type_information_and_annotations"
        - "documentation_and_docstrings"
        - "semantic_token_classification"
        - "syntax_highlighting_metadata"
      # Valid values: arrays of metadata types to extract
      # Purpose: Define structured metadata extraction from LSP analysis

  # Performance settings
  performance:
    symbol_extraction_timeout_seconds: 5
    # Valid values: 1-30 seconds
    # Default: 5
    # Purpose: Timeout for symbol extraction per 1000 files

    symbol_lookup_timeout_ms: 100
    # Valid values: 50-1000 milliseconds
    # Default: 100
    # Purpose: Timeout for individual symbol definition queries

    incremental_update_timeout_seconds: 1
    # Valid values: 0.5-10 seconds
    # Default: 1
    # Purpose: Timeout for processing single file changes

    relationship_analysis_timeout_ms: 200
    # Valid values: 100-2000 milliseconds
    # Default: 200
    # Purpose: Timeout for dependency graph queries

# =============================================================================
# 6. DOCUMENT PROCESSING & INGESTION
# =============================================================================
document_processing:
  # Supported document types and processing
  supported_types:
    text:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Process plain text files with metadata extraction

      extensions: [".txt", ".md", ".rst", ".asciidoc"]
      # Valid values: array of file extensions
      # Default: [".txt", ".md", ".rst", ".asciidoc"]
      # Purpose: File extensions to treat as text documents

    pdf:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Process PDF files with text extraction

      text_extraction: true
      # Valid values: true, false
      # Default: true
      # Purpose: Extract text from PDF files

      ocr_required_detection: true
      # Valid values: true, false
      # Default: true
      # Purpose: Detect PDFs without text that require OCR

      store_ocr_required_in_state: true
      # Valid values: true, false
      # Default: true
      # Purpose: Store PDFs requiring OCR in state database for user action

    epub_mobi:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Process e-book files with metadata preservation

      metadata_preservation: true
      # Valid values: true, false
      # Default: true
      # Purpose: Preserve e-book metadata during processing

      extract_toc: true
      # Valid values: true, false
      # Default: true
      # Purpose: Extract table of contents from e-books

    code:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Process code files with LSP enhancement or fallback

      lsp_enhanced: true
      # Valid values: true, false
      # Default: true
      # Purpose: Use LSP for enhanced code processing when available

      fallback_to_treesitter: true
      # Valid values: true, false
      # Default: true
      # Purpose: Use tree-sitter for symbol extraction when LSP unavailable

      fallback_to_storage_only: true
      # Valid values: true, false
      # Default: true
      # Purpose: Store code without analysis when neither LSP nor tree-sitter available

    web:
      single_page:
        enabled: true
        # Valid values: true, false
        # Default: true
        # Purpose: Support single webpage scraping

      recursive_crawling:
        enabled: true
        # Valid values: true, false
        # Default: true
        # Purpose: Support recursive web crawling from starting URLs

        max_depth: 3
        # Valid values: 1-10 levels
        # Default: 3
        # Purpose: Maximum recursion depth for web crawling

        rate_limiting:
          requests_per_second: 2
          # Valid values: 0.1-10 requests per second
          # Default: 2
          # Purpose: Rate limit for respectful web crawling

          concurrent_connections: 3
          # Valid values: 1-10 connections
          # Default: 3
          # Purpose: Maximum concurrent connections during crawling

        respect_robots_txt: true
        # Valid values: true, false
        # Default: true
        # Purpose: Respect robots.txt files during crawling

  # Metadata workflow for library collections
  metadata_workflow:
    incomplete_detection: true
    # Valid values: true, false
    # Default: true
    # Purpose: Detect files with incomplete metadata

    yaml_generation: true
    # Valid values: true, false
    # Default: true
    # Purpose: Generate YAML files for metadata completion

    user_completion_cycle: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable user metadata completion workflow

    yaml_update_on_rerun: true
    # Valid values: true, false
    # Default: true
    # Purpose: Update YAML with remaining incomplete files on subsequent runs

    required_metadata_by_type:
      book:
        required: ["title", "author", "edition"]
        optional: ["isbn", "publisher", "draft_status"]
      scientific_article:
        required: ["title", "authors", "journal", "publication_date"]
        optional: ["doi", "volume", "issue", "arxiv_id"]
      webpage:
        required: ["title", "url", "ingestion_date", "content_hash"]
        optional: ["author", "publication_date", "tags"]
      # Valid values: objects defining required and optional metadata fields
      # Purpose: Define metadata requirements for different document types

  # File watching and auto-ingestion
  file_watching:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable automatic file system monitoring

    project_folders:
      auto_monitor: true
      # Valid values: true, false
      # Default: true
      # Purpose: Automatically monitor project folders when MCP server active

      zero_configuration: true
      # Valid values: true, false
      # Default: true
      # Purpose: Require zero user configuration for project monitoring

    library_folders:
      user_configured: true
      # Valid values: true, false
      # Default: true
      # Purpose: Require user configuration for library folder monitoring

      command: "wqm library watch"
      # Valid values: CLI command string
      # Default: "wqm library watch"
      # Purpose: Command used to configure library folder watching

    incremental_updates:
      content_hash_tracking: true
      # Valid values: true, false
      # Default: true
      # Purpose: Track content hashes to detect actual changes

      modification_time_tracking: true
      # Valid values: true, false
      # Default: true
      # Purpose: Track file modification times

      process_only_changes: true
      # Valid values: true, false
      # Default: true
      # Purpose: Process only files that have actually changed

    debouncing:
      lsp_projects: true
      # Valid values: true, false
      # Default: true
      # Purpose: Debounce file changes for projects with LSP integration

      treesitter_only: false
      # Valid values: true, false
      # Default: false
      # Purpose: No debouncing for tree-sitter only projects

      no_analysis: false
      # Valid values: true, false
      # Default: false
      # Purpose: No debouncing when no analysis tools available

      delay_ms: 500
      # Valid values: 100-5000 milliseconds
      # Default: 500
      # Purpose: Debounce delay for file change events

    priority_processing:
      order:
        - "mcp_active"
        - "current_project"
        - "background_libraries"
        - "background_projects"
      # Valid values: array of processing priority levels
      # Default: ["mcp_active", "current_project", "background_libraries", "background_projects"]
      # Purpose: Define processing order when multiple sources need attention

# =============================================================================
# 7. SEARCH & INDEXING CONFIGURATION
# =============================================================================
search:
  # Search modes and contexts
  modes:
    project:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Search within current project's collections only
      default_mode: true
      # Valid values: true, false
      # Default: true
      # Purpose: Use as default search mode for active development

    collection:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Search within specific target collection

    global:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Search user-configured global collections

    all:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Comprehensive search across entire workspace
      # Note: Replaces qdrant-retrieve functionality

  # Search performance settings
  performance:
    response_timeout_ms: 100
    # Valid values: 50-1000 milliseconds
    # Default: 100
    # Purpose: Maximum time for search responses across all modes

    max_results_per_mode: 50
    # Valid values: 10-500 results
    # Default: 50
    # Purpose: Maximum results returned per search mode

    semantic_similarity_threshold: 0.7
    # Valid values: 0.1-1.0 (similarity score)
    # Default: 0.7
    # Purpose: Minimum similarity score for semantic search results

  # Search features and options
  features:
    include_relationships: true
    # Valid values: true, false
    # Default: true
    # Purpose: Include related content based on semantic relationships

    relationship_max_distance: 0.8
    # Valid values: 0.1-1.0 (similarity score)
    # Default: 0.8
    # Purpose: Maximum semantic distance for relationship inclusion

    version_preference: "latest"
    # Valid values: "latest", "all", "specific"
    # Default: "latest"
    # Purpose: Which document versions to prefer in search results

    include_archived: false
    # Valid values: true, false
    # Default: false
    # Purpose: Include archived collections in search by default

    content_type_filtering:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Allow filtering search results by content type

      available_types:
        - "all"
        - "code"
        - "docs"
        - "books"
        - "web"
        - "notes"
      # Valid values: array of content type identifiers
      # Default: ["all", "code", "docs", "books", "web", "notes"]
      # Purpose: Available content types for search filtering

  # Code-aware search settings
  code_search:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable specialized code search functionality

    symbol_search:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Enable LSP-enhanced symbol definition and usage search

      include_usage: true
      # Valid values: true, false
      # Default: true
      # Purpose: Include symbol usage locations in search results

      project_scope_default: true
      # Valid values: true, false
      # Default: true
      # Purpose: Default to project scope for symbol searches

    type_signature_search:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Enable search by function/method type signatures

      return_examples: true
      # Valid values: true, false
      # Default: true
      # Purpose: Return code examples with type signature matches

    related_documentation:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Find documentation related to code elements

      include_external: false
      # Valid values: true, false
      # Default: false
      # Purpose: Include external documentation sources

      max_distance: 0.8
      # Valid values: 0.1-1.0 (similarity score)
      # Default: 0.8
      # Purpose: Maximum semantic distance for related documentation

  # Global collections configuration
  global_collections:
    user_configurable: true
    # Valid values: true, false
    # Default: true
    # Purpose: Allow users to configure global collection list

    default_collections: []
    # Valid values: array of collection names
    # Default: []
    # Purpose: Default global collections (user can override)

    environment_variable: "WQM_GLOBAL_COLLECTIONS"
    # Valid values: environment variable name
    # Default: "WQM_GLOBAL_COLLECTIONS"
    # Purpose: Environment variable for global collection configuration

# =============================================================================
# 8. PERFORMANCE & RESOURCE MANAGEMENT
# =============================================================================
performance:
  # Resource constraints and limits
  memory:
    max_rss_mb: 500
    # Valid values: 100-2000 MB
    # Default: 500
    # Purpose: Maximum RSS memory usage for large workspaces (100k+ documents)

    warning_threshold_mb: 400
    # Valid values: 80-1600 MB (80% of max_rss_mb)
    # Default: 400
    # Purpose: Memory usage level that triggers warnings

    gc_threshold_mb: 350
    # Valid values: 70-1400 MB (70% of max_rss_mb)
    # Default: 350
    # Purpose: Memory usage level that triggers garbage collection

  # Processing performance targets
  processing:
    document_ingestion_rate: 1000
    # Valid values: 100-10000 documents per minute
    # Default: 1000
    # Purpose: Target sustained throughput for document processing (Rust daemon)

    batch_size: 100
    # Valid values: 10-1000 documents
    # Default: 100
    # Purpose: Number of documents to process in each batch

    max_concurrent_operations: 4
    # Valid values: 1-16 operations
    # Default: 4
    # Purpose: Maximum concurrent processing operations

  # Startup and initialization
  startup:
    daemon_init_timeout_seconds: 2
    # Valid values: 1-10 seconds
    # Default: 2
    # Purpose: Maximum time for Rust daemon initialization and gRPC connection

    mcp_server_init_timeout_seconds: 5
    # Valid values: 2-30 seconds
    # Default: 5
    # Purpose: Maximum time for MCP server initialization

    health_check_timeout_seconds: 1
    # Valid values: 0.5-5 seconds
    # Default: 1
    # Purpose: Timeout for component health checks during startup

  # CPU and priority management
  cpu:
    background_priority: "low"
    # Valid values: "low", "normal", "high"
    # Default: "low"
    # Purpose: CPU priority for background processing operations

    interactive_priority: "high"
    # Valid values: "low", "normal", "high"
    # Default: "high"
    # Purpose: CPU priority when MCP server is active

    priority_boost_on_mcp_active: true
    # Valid values: true, false
    # Default: true
    # Purpose: Boost daemon priority when MCP server becomes active

    revert_priority_on_mcp_quit: true
    # Valid values: true, false
    # Default: true
    # Purpose: Revert to background priority when MCP server quits

  # Recovery and resumption performance
  recovery:
    state_recovery_timeout_seconds: 5
    # Valid values: 1-30 seconds
    # Default: 5
    # Purpose: Maximum time to detect and present resumption options

    transaction_rollback_timeout_seconds: 1
    # Valid values: 0.5-10 seconds
    # Default: 1
    # Purpose: Maximum time for atomic operation rollback on failure

    queue_persistence: true
    # Valid values: true, false
    # Default: true
    # Purpose: 100% preservation of unfinished work across system restarts

    graceful_degradation_response_ms: 500
    # Valid values: 100-2000 milliseconds
    # Default: 500
    # Purpose: Maximum time to switch to degraded mode when components fail

    automatic_recovery_timeout_seconds: 10
    # Valid values: 5-60 seconds
    # Default: 10
    # Purpose: Maximum time to resume full functionality after component restart

  # Scalability targets
  scalability:
    max_collections: 100
    # Valid values: 10-1000 collections
    # Default: 100
    # Purpose: Maximum number of collections supported per workspace

    max_documents_total: 100000
    # Valid values: 1000-1000000 documents
    # Default: 100000
    # Purpose: Maximum total documents across all collections

    max_documents_per_collection: 10000
    # Valid values: 100-100000 documents
    # Default: 10000
    # Purpose: Maximum documents per individual collection

    concurrent_mcp_servers: 3
    # Valid values: 1-10 servers
    # Default: 3
    # Purpose: Maximum concurrent MCP servers supported on same daemon

# =============================================================================
# 9. PLATFORM & DIRECTORY CONFIGURATION
# =============================================================================
platform:
  # OS-standard directory compliance
  xdg_compliance:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Follow XDG Base Directory Specification on Linux/Unix

    fallback_on_windows_mac: true
    # Valid values: true, false
    # Default: true
    # Purpose: Use platform-specific directories on Windows/macOS

  # Platform-specific directory mapping
  directories:
    linux:
      cache: "$XDG_CACHE_HOME/workspace-qdrant-mcp"
      # Default fallback: "~/.cache/workspace-qdrant-mcp"
      state: "$XDG_STATE_HOME/workspace-qdrant-mcp"
      # Default fallback: "~/.local/state/workspace-qdrant-mcp"
      config: "$XDG_CONFIG_HOME/workspace-qdrant-mcp"
      # Default fallback: "~/.config/workspace-qdrant-mcp"
      logs: "$XDG_STATE_HOME/workspace-qdrant-mcp/logs"
      # Default fallback: "~/.local/state/workspace-qdrant-mcp/logs"

    macos:
      cache: "~/Library/Caches/workspace-qdrant-mcp"
      logs: "~/Library/Logs/workspace-qdrant-mcp"
      config: "~/Library/Application Support/workspace-qdrant-mcp"
      state: "~/Library/Application Support/workspace-qdrant-mcp/state"

    windows:
      cache: "%LOCALAPPDATA%\\workspace-qdrant-mcp\\cache"
      logs: "%LOCALAPPDATA%\\workspace-qdrant-mcp\\logs"
      config: "%APPDATA%\\workspace-qdrant-mcp"
      state: "%LOCALAPPDATA%\\workspace-qdrant-mcp\\state"
    # Valid values: platform-specific directory path templates
    # Purpose: Ensure proper directory usage according to OS conventions
    # Note: User-configurable directories removed in favor of OS standards

  # File pattern system (embedded at compile-time)
  file_patterns:
    language_extensions:
      python:
        extensions: [".py", ".pyi", ".pyx"]
        config_files: ["pyproject.toml", "setup.py", "requirements*.txt", "Pipfile"]
      rust:
        extensions: [".rs"]
        config_files: ["Cargo.toml", "Cargo.lock"]
      javascript:
        extensions: [".js", ".mjs", ".cjs"]
        config_files: ["package.json", "package-lock.json"]
      typescript:
        extensions: [".ts", ".tsx", ".d.ts"]
        config_files: ["tsconfig.json", "package.json"]
      # Valid values: objects mapping languages to extensions and config files
      # Purpose: Automatically generated from available LSP servers
      # Note: Embedded at compile-time for performance

    exclusion_patterns:
      global:
        version_control:
          - ".git/"
          - ".hg/"
          - ".svn/"
        build_artifacts:
          - "build/"
          - "dist/"
          - "target/"        # Rust
          - "__pycache__/"   # Python
          - "node_modules/"  # Node.js
          - ".next/"         # Next.js
          - ".nuxt/"         # Nuxt.js
        ide_files:
          - ".vscode/"
          - ".idea/"
          - "*.swp"
          - "*.swo"
          - ".DS_Store"
          - "thumbs.db"
        dependencies:
          - "venv/"
          - ".venv/"
          - "env/"
          - ".tox/"
          - "vendor/"        # Go, Ruby
          - "deps/"          # Elixir
      # Valid values: hierarchical object of exclusion patterns
      # Purpose: Comprehensive exclusion patterns embedded at compile-time
      # Note: Research-backed patterns for optimal performance

    include_patterns:
      # Custom include patterns can be added by user
      custom: []
      # Valid values: array of glob patterns
      # Default: []
      # Purpose: User-defined include patterns to supplement defaults

    exclude_patterns:
      # Custom exclude patterns can be added by user
      custom: []
      # Valid values: array of glob patterns
      # Default: []
      # Purpose: User-defined exclude patterns to supplement defaults

# =============================================================================
# 10. CLI BEHAVIOR CONFIGURATION
# =============================================================================
cli:
  # CLI behavior and user experience settings
  behavior:
    interactive_mode: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable interactive features like token optimization, conflict resolution

    default_output_format: "table"
    # Valid values: "table", "json", "yaml", "structured", "plain"
    # Default: "table"
    # Purpose: Default output format for CLI commands

    color_output: true
    # Valid values: true, false
    # Default: true
    # Purpose: Use colored output for better readability

    progress_indicators: true
    # Valid values: true, false
    # Default: true
    # Purpose: Show progress bars and indicators for long operations

    confirmation_prompts: true
    # Valid values: true, false
    # Default: true
    # Purpose: Show confirmation prompts for destructive operations

  # Subcommand availability (enable/disable major command groups)
  subcommands:
    memory_commands: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable/disable memory management command group

    admin_commands: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable/disable system administration command group

    ingest_commands: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable/disable document ingestion command group

    search_commands: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable/disable search interface command group

    library_commands: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable/disable library management command group

    collection_commands: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable/disable collection management command group

  # CLI integration settings
  integration:
    shell_completion: true
    # Valid values: true, false
    # Default: true
    # Purpose: Generate shell completion scripts for bash/zsh/fish

    man_pages: true
    # Valid values: true, false
    # Default: true
    # Purpose: Generate man pages for CLI commands

    help_system: "comprehensive"
    # Valid values: "minimal", "standard", "comprehensive"
    # Default: "comprehensive"
    # Purpose: Level of detail in CLI help system

  # Note: CLI command structure and subcommands are authoritatively defined in Section 7.1
  # This section only contains user-configurable behavior, output preferences, and integration options

# =============================================================================
# 11. gRPC & COMMUNICATION SETTINGS
# =============================================================================
grpc:
  # Core gRPC server settings
  server:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable gRPC server in Rust daemon for MCP communication

    host: "127.0.0.1"
    # Valid values: IP address string
    # Default: "127.0.0.1"
    # Purpose: Host address for gRPC server binding

    port: 50051
    # Valid values: 1024-65535 (port number)
    # Default: 50051
    # Purpose: Port number for gRPC server

    max_concurrent_streams: 100
    # Valid values: 1-1000 streams
    # Default: 100
    # Purpose: Maximum concurrent gRPC streams

    max_message_size_mb: 16
    # Valid values: 1-100 MB
    # Default: 16
    # Purpose: Maximum message size for gRPC communication

  # Client settings (for Python MCP server)
  client:
    connection_timeout_seconds: 5
    # Valid values: 1-30 seconds
    # Default: 5
    # Purpose: Timeout for initial gRPC connection

    request_timeout_seconds: 30
    # Valid values: 5-300 seconds
    # Default: 30
    # Purpose: Default timeout for gRPC requests

    keepalive_interval_seconds: 30
    # Valid values: 10-300 seconds
    # Default: 30
    # Purpose: Keep-alive ping interval

    keepalive_timeout_seconds: 5
    # Valid values: 1-30 seconds
    # Default: 5
    # Purpose: Keep-alive ping timeout

    max_retry_attempts: 3
    # Valid values: 1-10 attempts
    # Default: 3
    # Purpose: Maximum retry attempts for failed requests

    retry_backoff_ms: 1000
    # Valid values: 100-10000 milliseconds
    # Default: 1000
    # Purpose: Base backoff time for retry attempts

  # Health checking and monitoring
  health:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable gRPC health checking service

    check_interval_seconds: 10
    # Valid values: 5-60 seconds
    # Default: 10
    # Purpose: Health check interval

    timeout_seconds: 2
    # Valid values: 1-10 seconds
    # Default: 2
    # Purpose: Health check timeout

  # TLS and security (for future use)
  security:
    tls_enabled: false
    # Valid values: true, false
    # Default: false
    # Purpose: Enable TLS encryption for gRPC communication
    # Note: Currently disabled for local communication

    cert_file: ""
    # Valid values: file path string
    # Default: ""
    # Purpose: Path to TLS certificate file

    key_file: ""
    # Valid values: file path string
    # Default: ""
    # Purpose: Path to TLS private key file

# =============================================================================
# 12. VERSION MANAGEMENT & CONFLICT RESOLUTION
# =============================================================================
version_management:
  # Document type-based versioning strategies
  document_types:
    book:
      primary_version: "edition"
      # Valid values: "edition", "publication_date", "modification_date"
      # Default: "edition"
      # Purpose: Primary version identifier for books

      secondary_version: "publication_date"
      # Valid values: "publication_date", "modification_date", "ingestion_date"
      # Default: "publication_date"
      # Purpose: Secondary version identifier for books

      required_metadata: ["title", "author", "edition"]
      # Valid values: array of required metadata field names
      # Default: ["title", "author", "edition"]
      # Purpose: Metadata fields required for proper versioning

      optional_metadata: ["isbn", "publisher", "draft_status"]
      # Valid values: array of optional metadata field names
      # Default: ["isbn", "publisher", "draft_status"]
      # Purpose: Optional metadata fields that enhance versioning

      retention_policy: "latest_only"
      # Valid values: "latest_only", "all_versions", "archive_older"
      # Default: "latest_only"
      # Purpose: How many versions to retain

    scientific_article:
      primary_version: "publication_date"
      secondary_version: "arxiv_version"
      required_metadata: ["title", "authors", "journal", "publication_date"]
      optional_metadata: ["doi", "volume", "issue", "arxiv_id"]
      retention_policy: "latest_only"

    code_file:
      primary_version: "git_tag"
      secondary_version: "modification_date"
      auto_metadata: true
      # Valid values: true, false
      # Default: true
      # Purpose: Automatically extract metadata from git/filesystem
      retention_policy: "current_state_only"
      # Note: Git handles history, only store current working tree

    webpage:
      primary_version: "ingestion_date"
      secondary_version: "content_hash"
      required_metadata: ["title", "url", "ingestion_date", "content_hash"]
      optional_metadata: ["author", "publication_date", "tags"]
      retention_policy: "latest_with_archive_option"
      # Note: Can optionally archive previous versions

    # Add more document types as needed
    generic:
      primary_version: "modification_date"
      secondary_version: "content_hash"
      required_metadata: ["title", "format"]
      optional_metadata: ["author", "tags", "description"]
      retention_policy: "latest_only"

  # Version conflict resolution strategies
  conflict_resolution:
    same_content_different_editions:
      strategy: "latest_wins_auto"
      # Valid values: "latest_wins_auto", "user_decision", "keep_both"
      # Default: "latest_wins_auto"
      # Purpose: How to handle same content in different editions

      deprioritize_older: true
      # Valid values: true, false
      # Default: true
      # Purpose: Lower search ranking for older versions

    code_files:
      git_tag_precedence: true
      # Valid values: true, false
      # Default: true
      # Purpose: Git tags take precedence over modification dates

      working_tree_only: true
      # Valid values: true, false
      # Default: true
      # Purpose: Only store current working tree state

    format_precedence:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Enable format-based precedence rules

      create_research_task: true
      # Valid values: true, false
      # Default: true
      # Purpose: Create research tasks for PDF vs EPUB vs MOBI quality analysis

    metadata_conflicts:
      user_responsibility: true
      # Valid values: true, false
      # Default: true
      # Purpose: User validates and resolves metadata conflicts

      engine_override: false
      # Valid values: true, false
      # Default: false
      # Purpose: Engine never overrides user decisions

  # Archive collection settings
  archive_collections:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable optional archive collections for version history

    naming_pattern: "_{collection}_archive"
    # Valid values: string pattern with {collection} placeholder
    # Default: "_{collection}_archive"
    # Purpose: Naming pattern for archive collections

    auto_creation: false
    # Valid values: true, false
    # Default: false
    # Purpose: Automatically create archive collections vs user-initiated

    retention_policy: "user_defined"
    # Valid values: "user_defined", "time_based", "count_based"
    # Default: "user_defined"
    # Purpose: How long to retain archived versions

# =============================================================================
# 13. WEB CRAWLING & EXTERNAL CONTENT
# =============================================================================
web_crawling:
  # Core web crawling settings
  enabled: true
  # Valid values: true, false
  # Default: true
  # Purpose: Enable web crawling and external content ingestion

  # Single page scraping
  single_page:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Support single webpage scraping

    timeout_seconds: 30
    # Valid values: 5-120 seconds
    # Default: 30
    # Purpose: Timeout for single page requests

    max_page_size_mb: 10
    # Valid values: 1-100 MB
    # Default: 10
    # Purpose: Maximum page size to process

    follow_redirects: true
    # Valid values: true, false
    # Default: true
    # Purpose: Follow HTTP redirects during scraping

    max_redirects: 5
    # Valid values: 1-20 redirects
    # Default: 5
    # Purpose: Maximum number of redirects to follow

  # Recursive crawling settings
  recursive:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Support recursive web crawling from starting URLs

    max_depth: 3
    # Valid values: 1-10 levels
    # Default: 3
    # Purpose: Maximum recursion depth for web crawling

    same_domain_only: true
    # Valid values: true, false
    # Default: true
    # Purpose: Restrict crawling to same domain as starting URL

    max_pages_per_domain: 100
    # Valid values: 10-10000 pages
    # Default: 100
    # Purpose: Maximum pages to crawl per domain

  # Rate limiting and politeness
  rate_limiting:
    requests_per_second: 2
    # Valid values: 0.1-10 requests per second
    # Default: 2
    # Purpose: Rate limit for respectful web crawling

    concurrent_connections: 3
    # Valid values: 1-10 connections
    # Default: 3
    # Purpose: Maximum concurrent connections during crawling

    delay_between_requests_ms: 1000
    # Valid values: 100-10000 milliseconds
    # Default: 1000
    # Purpose: Minimum delay between requests to same domain

    respect_robots_txt: true
    # Valid values: true, false
    # Default: true
    # Purpose: Respect robots.txt files during crawling

    user_agent: "workspace-qdrant-mcp/2.0 (+https://github.com/user/workspace-qdrant-mcp)"
    # Valid values: user agent string
    # Default: "workspace-qdrant-mcp/2.0 (+https://github.com/user/workspace-qdrant-mcp)"
    # Purpose: User agent string for web requests

  # Content extraction and processing
  content_extraction:
    extract_text_only: false
    # Valid values: true, false
    # Default: false
    # Purpose: Extract only text content vs. full page structure

    include_metadata: true
    # Valid values: true, false
    # Default: true
    # Purpose: Extract and store page metadata (title, description, etc.)

    extract_links: true
    # Valid values: true, false
    # Default: true
    # Purpose: Extract and process links for recursive crawling

    filter_content: true
    # Valid values: true, false
    # Default: true
    # Purpose: Filter out navigation, ads, and non-content elements

    min_content_length: 100
    # Valid values: 10-10000 characters
    # Default: 100
    # Purpose: Minimum content length to consider page worthwhile

  # Error handling and retries
  error_handling:
    max_retry_attempts: 3
    # Valid values: 1-10 attempts
    # Default: 3
    # Purpose: Maximum retry attempts for failed requests

    retry_backoff_seconds: 5
    # Valid values: 1-60 seconds
    # Default: 5
    # Purpose: Base backoff time for retry attempts

    skip_on_error: true
    # Valid values: true, false
    # Default: true
    # Purpose: Skip problematic pages vs. failing entire crawl

    log_errors: true
    # Valid values: true, false
    # Default: true
    # Purpose: Log crawling errors for user review

# =============================================================================
# 14. GRACEFUL DEGRADATION & RECOVERY
# =============================================================================
graceful_degradation:
  # Core graceful degradation settings
  enabled: true
  # Valid values: true, false
  # Default: true
  # Purpose: Enable graceful degradation when components fail

  # Component failure handling
  component_failures:
    rust_daemon:
      fallback_mode: "mcp_server_only"
      # Valid values: "mcp_server_only", "cli_only", "shutdown_system"
      # Default: "mcp_server_only"
      # Purpose: How to handle Rust daemon failures

      preserve_functionality:
        - "memory_collection_access"
        - "basic_search"
        - "configuration_management"
      # Valid values: array of functionality to preserve
      # Purpose: Core functionality to maintain during daemon failure

      user_notification: true
      # Valid values: true, false
      # Default: true
      # Purpose: Notify user of degraded functionality

    mcp_server:
      fallback_mode: "cli_only"
      # Valid values: "cli_only", "daemon_only", "shutdown_system"
      # Default: "cli_only"
      # Purpose: How to handle MCP server failures

      preserve_functionality:
        - "file_processing"
        - "collection_management"
        - "administrative_tasks"
      # Valid values: array of functionality to preserve
      # Purpose: Core functionality to maintain during MCP server failure

    lsp_servers:
      fallback_mode: "text_only_processing"
      # Valid values: "text_only_processing", "treesitter_fallback", "skip_code_files"
      # Default: "text_only_processing"
      # Purpose: How to handle LSP server failures

      degradation_levels: 4
      # Valid values: 1-10 levels
      # Default: 4
      # Purpose: Number of graceful degradation levels for LSP failures
      # See LSP section for detailed level definitions

  # Automatic recovery settings
  automatic_recovery:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable automatic recovery when failed components restart

    detection_interval_seconds: 5
    # Valid values: 1-60 seconds
    # Default: 5
    # Purpose: How often to check for component recovery

    recovery_timeout_seconds: 10
    # Valid values: 5-60 seconds
    # Default: 10
    # Purpose: Maximum time to attempt recovery

    max_recovery_attempts: 3
    # Valid values: 1-10 attempts
    # Default: 3
    # Purpose: Maximum automatic recovery attempts

  # State preservation during failures
  state_preservation:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Ensure no data loss during component failures

    transaction_boundaries: true
    # Valid values: true, false
    # Default: true
    # Purpose: Use SQLite transaction boundaries for atomic operations

    rollback_capability: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable rollback of failed operations

    queue_persistence: true
    # Valid values: true, false
    # Default: true
    # Purpose: Persist operation queues across failures

    checkpoint_interval_seconds: 30
    # Valid values: 10-300 seconds
    # Default: 30
    # Purpose: How often to checkpoint system state

  # User communication during degradation
  user_communication:
    clear_messaging: true
    # Valid values: true, false
    # Default: true
    # Purpose: Provide clear communication about degraded functionality

    recovery_progress: true
    # Valid values: true, false
    # Default: true
    # Purpose: Show recovery progress to user

    functionality_status: true
    # Valid values: true, false
    # Default: true
    # Purpose: Clearly indicate which features are available/unavailable

    recovery_instructions: true
    # Valid values: true, false
    # Default: true
    # Purpose: Provide instructions for manual recovery when needed

# =============================================================================
# 15. SECURITY & ACCESS CONTROL
# =============================================================================
security:
  # Access control and permissions
  access_control:
    collection_permissions:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Enforce collection-level access permissions

      default_policy: "restrictive"
      # Valid values: "restrictive", "permissive"
      # Default: "restrictive"
      # Purpose: Default access policy for new collections

    api_authentication:
      enabled: false
      # Valid values: true, false
      # Default: false
      # Purpose: Enable API authentication (future feature)
      # Note: Currently disabled for local development

    file_system_access:
      restricted_paths:
        - "/etc"
        - "/sys"
        - "/proc"
        - "C:\\Windows\\System32"
      # Valid values: array of file system paths
      # Default: system-critical directories
      # Purpose: Prevent access to sensitive system directories

      home_directory_only: false
      # Valid values: true, false
      # Default: false
      # Purpose: Restrict file access to user's home directory only

  # Data protection and privacy
  data_protection:
    encrypt_at_rest: false
    # Valid values: true, false
    # Default: false
    # Purpose: Encrypt stored data (future feature)

    sanitize_logs: true
    # Valid values: true, false
    # Default: true
    # Purpose: Remove sensitive information from logs

    secure_temp_files: true
    # Valid values: true, false
    # Default: true
    # Purpose: Use secure temporary file creation

  # Network security
  network_security:
    localhost_only: true
    # Valid values: true, false
    # Default: true
    # Purpose: Bind servers to localhost only

    firewall_friendly: true
    # Valid values: true, false
    # Default: true
    # Purpose: Use standard ports and protocols

  # Content filtering and validation
  content_filtering:
    validate_file_types: true
    # Valid values: true, false
    # Default: true
    # Purpose: Validate file types before processing

    max_file_size_mb: 100
    # Valid values: 1-1000 MB
    # Default: 100
    # Purpose: Maximum file size to process

    scan_for_malware: false
    # Valid values: true, false
    # Default: false
    # Purpose: Scan files for malware (requires external tool)

# =============================================================================
# 16. MONITORING & DIAGNOSTICS
# =============================================================================
monitoring:
  # System health monitoring
  health_monitoring:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable comprehensive system health monitoring

    check_interval_seconds: 30
    # Valid values: 10-300 seconds
    # Default: 30
    # Purpose: How often to perform health checks

    component_checks:
      - "rust_daemon"
      - "mcp_server"
      - "grpc_communication"
      - "sqlite_database"
      - "lsp_servers"
      - "file_system_access"
      # Valid values: array of component names to monitor
      # Purpose: Components to include in health monitoring

  # Performance metrics
  performance_metrics:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Collect and report performance metrics

    metrics_retention_days: 7
    # Valid values: 1-30 days
    # Default: 7
    # Purpose: How long to retain performance metrics

    collected_metrics:
      - "memory_usage"
      - "cpu_usage"
      - "disk_io"
      - "network_io"
      - "processing_throughput"
      - "search_response_times"
      - "error_rates"
      # Valid values: array of metric names
      # Purpose: Performance metrics to collect

  # Logging configuration
  logging:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable system logging

    level: "info"
    # Valid values: "trace", "debug", "info", "warn", "error"
    # Default: "info"
    # Purpose: Minimum log level to record

    file_rotation: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable log file rotation

    max_file_size_mb: 10
    # Valid values: 1-100 MB
    # Default: 10
    # Purpose: Maximum size for individual log files

    max_files: 5
    # Valid values: 1-20 files
    # Default: 5
    # Purpose: Maximum number of rotated log files to keep

    structured_logging: true
    # Valid values: true, false
    # Default: true
    # Purpose: Use structured (JSON) log format

  # Error tracking and reporting
  error_tracking:
    enabled: true
    # Valid values: true, false
    # Default: true
    # Purpose: Track and categorize errors

    error_categorization: true
    # Valid values: true, false
    # Default: true
    # Purpose: Automatically categorize errors by type and severity

    error_reporting: "local_only"
    # Valid values: "local_only", "opt_in_telemetry", "disabled"
    # Default: "local_only"
    # Purpose: How to handle error reporting

    crash_dumps: true
    # Valid values: true, false
    # Default: true
    # Purpose: Generate crash dumps for debugging

  # Diagnostics and troubleshooting
  diagnostics:
    self_test_on_startup: true
    # Valid values: true, false
    # Default: true
    # Purpose: Run self-tests during system startup

    diagnostic_commands:
      enabled: true
      # Valid values: true, false
      # Default: true
      # Purpose: Enable diagnostic CLI commands

      include_system_info: true
      # Valid values: true, false
      # Default: true
      # Purpose: Include system information in diagnostics

      include_config_validation: true
      # Valid values: true, false
      # Default: true
      # Purpose: Include configuration validation in diagnostics

    troubleshooting_guides: true
    # Valid values: true, false
    # Default: true
    # Purpose: Include built-in troubleshooting guides

    support_bundle_generation: true
    # Valid values: true, false
    # Default: true
    # Purpose: Enable generation of support bundles for debugging

# =============================================================================
# END OF CONFIGURATION
# =============================================================================
```

This configuration file serves as the **complete and authoritative reference** for all system settings. Every option throughout the PRD is documented here with full details, constraints, and examples. Use this as the single source of truth for understanding and configuring the workspace-qdrant-mcp system.

## 3. Memory-Driven System Design

### 3.1 Memory Collection as Behavioral Control

**Core Concept**: The `${memory.collection_name}` collection serves as a knowledge graph storing user preferences and LLM behavioral rules that automatically shape every session.

**Authority Levels**:
- **Absolute**: Non-negotiable rules that always apply ("Always make atomic commits")
- **Default**: Follow unless explicitly overridden ("Use pytest for new projects, unittest otherwise")

**Conversational Updates**:
```
Human: "For future reference, always use TypeScript strict mode"
System: Automatically stored in ${memory.collection_name} collection with semantic conflict detection
Next Session: [Rule automatically injected into system context]
```
(This requires a pre-existing rule to ensure that the LLM access its MCP Server and store the new memory, respectively change, or remove it)

**Memory Schema Structure**:
```yaml
memory_entries:
  preferences:
    user_name: "Chris"
    tooling: "Use uv exclusively for Python package management"
    standards: "Follow XDG standards for config directories"

  behaviors:
    supervisor_role: |
      "Act as supervisor. Deploy subagents and ensure delivery.
      Take control only when agents fail, then resume supervision.
      Make decisions per PRD context."
    commit_discipline: |
      "Always make atomic commits following conventional format.
      Read minimum 2000 lines of context before changes."

  agent_library:
    python-pro:
      description: "Expert Python developer with modern practices"
      capabilities: ["fastapi", "async", "testing", "type-hints"]
      deploy_cost: "medium"

  conditional_rules:
    - trigger: "new_projects"
      action: "use pytest for testing"
      default: "use unittest for existing projects"
```

### 3.2 Session Initialization with Memory Integration

**Claude Code Integration Workflow**:
1. MCP server starts in Claude Code environment
2. Load all memory rules from ${memory.collection_name} collection (user preferences + LLM behaviors + agent library)
3. Detect rule conflicts using Claude/Sonnet semantic analysis
4. If conflicts exist: present user with resolution options, update ${memory.collection_name} collection
5. Inject clean, resolved rules into Claude Code system context via SDK
6. Session begins with personalized LLM behavior automatically active

**Memory Authority and Conflict Resolution**:
```yaml
conflict_example:
  existing_rule:
    rule: "Use unittest for all Python testing"
    authority: "default"
    source: "user_conversational"

  new_rule:
    rule: "Always use pytest for new projects"
    authority: "default"
    source: "user_explicit"

  resolution_strategy:
    action: "merge_conditional"
    result: "Use pytest for new projects, unittest for existing"
    conditions: ["project_age", "existing_test_framework"]
```

### 3.3 Dynamic Memory Updates and Token Management

**Immediate Activation**: Memory changes apply to current session instantly without restart
**Token Optimization**: `wqm memory tokens` shows usage, `wqm memory trim` provides interactive optimization
**Conflict Prevention**: Rule-based fast checks + LLM semantic analysis for thoroughness

## 4. Collection Architecture and Multi-Tenancy

### 4.1 Reserved Collection Naming System

**Memory Collection**: `${memory.collection_name}`
- **Type**: Pure knowledge graph storing behavioral rules and user preferences
- **Authority**: Global across all projects and sessions
- **Access**: Read/write via conversational updates and CLI management
- **Architectural Exception**: The ${memory.collection_name} collection is **writable from both MCP server and wqm CLI** because conversational memory updates require real-time write access during sessions for behavioral rule management

**Library Collections**: `_{name}` (hardcoded "_" prefix, non-configurable)
- **Pattern**: User-defined libraries automatically prefixed with underscore (`_technical-books`, `_reference-docs`)
- **Access**: Read-only from MCP server, read-write from daemon via CLI
- **Display**: Users see `library`, actual storage is `_library`
- **Conflict Prevention**: Cannot have both `_library` and `library` collections simultaneously
- **Creation**: Via `wqm library create {name}` command, not configuration

**Project Collections**: `${collections.root_name}-${collections.type}`
- **Root-name**: User selected root name (${collections.root_name}) for the multi-tenant collection
- **Types**: Configured in ${collections.types} 
- **Creation**: Automatic based on project detection when MCP starts in project directory (if no types is defined, no collection is created)
- **Access**: Full read/write via MCP tools for active development

**Project content**
- **Watching**: Project folders automatically monitored when MCP server active, when the daemon is idle for the given project, it continues working on its queue, until either a change of the current project or an instruction from the MCP Server is received, as these have priority over the queue.
- **Content**: Project code files and documentation files
- **Watching**: All identified projects, stored in the daemon state management, are watched at all times
- **Collection**: The ${collections.project_content.name} read-only multi-tenant collection contains all project contents

### 4.2 Multi-Tenant Architecture

**Collection Structure**:
```
Collections: (read-only or read-write accesses are given from the point of view of the MCP server)
├── ${memory.collection_name} (global behavioral rules and preferences) 
├── _technical-books (read-only library collection, example)
├── _reference-docs (read-only library collection, example)
├── _${collections.project_content.name} (read-only, multi-tenant by project metadata, hardcoded "_" prefix)
├── ${collections.root_name}-scratchbook (multi-tenant, read/write, example)
├── ${collections.root_name}-docs (multi-tenant, read/write, example)
```

**Multi-Tenancy Isolation**:
- Projects isolated by metadata filtering, not separate collections
- Library collections shared across projects for knowledge reuse
- Project-specific collections automatically created and managed
- Memory collection global across all contexts

### 4.3 Collection Name Restrictions and Validation

**Reserved Patterns**:
- Collections starting with `_` reserved for read-only libraries (hardcoded, non-configurable)
- `${memory.collection_name}` reserved for behavioral control knowledge graph
- `__` prefix reserved for system-internal collections (hardcoded, non-configurable)

**Conflict Prevention**:
- Server-level naming collision detection prevents duplicate patterns
- Clear error messages for unauthorized access attempts
- Automatic migration tools for existing collection conflicts

### 4.4 Architectural Constraints and Protocol Compliance

**Hard Constraints**:
- **Memory Collection Authority**: Absolute rules are non-negotiable across all sessions
- **Memory Collection Exception**: The `${memory.collection_name}` collection is writable from both MCP server (conversational updates) and wqm CLI (direct management) - the only collection with dual write access
- **Read-Only Libraries**: Collections prefixed with "_" cannot be modified via MCP interface (hardcoded prefix)
- **Project Isolation**: Multi-tenancy prevents cross-project content leakage, but can allow for cross project searches
- **LSP Dependency**: Code intelligence requires user-managed LSP servers
- **Transactional Safety**: All operations must be atomic with rollback capability
- **Standard Protocol Compliance**: Must use established protocols (LSP, MCP, gRPC) over custom implementations

**Graceful Degradation Requirements**:
- **Core functionality preserved**: System continues with reduced features when components fail
- **User transparency**: Clear communication about degraded functionality and recovery options
- **Automatic recovery**: Resume full functionality when failed components restart
- **State preservation**: No data loss during component failures or degraded operation

## 5. Rust Daemon - Heavy Processing Engine

### 5.1 Core Processing Responsibilities

**Document Conversion Pipeline**:
- **Text files**: Direct ingestion with metadata extraction
- **PDF files**: Text extraction
- **PDF files w/o text**: Stored in state database, user can query the files and manually handle the OCR for image-based content
- **EPUB/MOBI**: E-book parsing with metadata preservation
- **Code files**: LSP-enhanced parsing with symbol analysis and relationship mapping, if no LSP for the language, fallback to treesitter for symbol extraction, if not treesitter grammar only storage of the code
- **Wed page**: Single webpage scrapping
- **Web pages**: Recursive crawling from the starting URLs (i.e., the URL provided) with configurable rate limiting and depth

**File Watching and Auto-Ingestion**:
- **Project folders**: Automatic monitoring when MCP server active (zero user configuration) with state database update for new projects
- **Projects folders**: Stored in state database and are monitored as well
- **Library folders**: User-configured via `wqm watch` for specific library collections
- **Incremental updates**: Track file modification times and content hashes, process only changes, debounce in the case of projects with LSP, no debounce for treesitter only or no-treesitter.
- **Priority-based processing**: MCP active → current project → background libraries and projects

**LSP Integration and Code Intelligence**:
- **Auto-detection**: Discover available LSP servers in PATH (rust-analyzer, ruff, typescript-language-server, etc.)
- **User responsibility**: No auto-installation, user maintains control over LSP server versions
- **Symbol extraction**: Functions, classes, variables, imports, relationships, type information
- **Semantic tokens**: Syntax classification and identifier relationships
- **Documentation sync**: Docstrings, inline comments, API documentation

### 5.2 Metadata Workflow for Library Collections

**Incomplete Metadata Detection and Resolution**:
```yaml
# Generated by workspace-qdrant-mcp ingestion engine
# Complete metadata for the files below and re-run ingestion

pending_files:
  - path: /library/advanced-rust.pdf
    detected_metadata:
      title: "Advanced Rust Programming"
      format: pdf
      file_size: "15.2MB"
      content_preview: "Chapter 1: Ownership and Borrowing..."
    required_metadata:
      author: "?"
      year: "?"
      edition: "?"
      isbn: "?"
      tags: ["rust", "programming"]

  - path: /library/algorithms.epub
    detected_metadata:
      title: "Introduction to Algorithms"
      format: epub
      authors: ["Thomas H. Cormen"]  # Sometimes auto-detectable
    required_metadata:
      edition: "?"
      publisher: "?"
      year: "?"
      isbn: "?"

processing_workflow:
  1. Engine discovers files without complete metadata
  2. Creates/updates YAML file in collection root with detected + required fields
  3. User completes metadata in YAML file
  4. Engine processes files with complete metadata on next run
  5. Updates YAML with any remaining incomplete files
  6. Cycle continues until all files processed with rich metadata
```

### 5.3 Version Management and Document Precedence

**Document Type-Based Versioning**:
```yaml
document_types:
  book:
    primary_version: "edition"
    secondary_version: "publication_date"
    required: ["title", "author", "edition"]
    optional: ["isbn", "publisher", "draft_status"]
    retention_policy: "latest_only"

  scientific_article:
    primary_version: "publication_date"
    required: ["title", "authors", "journal", "publication_date"]
    optional: ["doi", "volume", "issue", "arxiv_id"]
    retention_policy: "latest_only"

  code_file:
    primary_version: "git_tag"
    secondary_version: "modification_date"
    auto_metadata: true  # From git/filesystem
    retention_policy: "current_state_only"  # Git handles history

  webpage:
    primary_version: "ingestion_date"
    required: ["title", "url", "ingestion_date", "content_hash"]
    optional: ["author", "publication_date", "tags"]
    retention_policy: "latest_with_archive_option"
```

**Version Conflict Resolution Strategy**:
- **Same content, different editions**: Latest edition wins automatically with de-prioritization of older versions
- **Code files**: Git tag precedence over modification date, only current working tree stored
- **Format precedence**: Research task created for PDF vs EPUB vs MOBI quality analysis
- **Metadata conflicts**: User responsibility with validation, engine doesn't override user decisions
- **Archive collections**: Optional `_{collection}_archive` for version history when needed (hardcoded "_" prefix)

### 5.4 Performance and Resource Management

**Resource Constraints**:
- **Memory**: <500MB RSS for large workspaces (100k+ documents)
- **Processing**: 1000+ documents/minute sustained throughput
- **Startup**: <2 seconds for engine initialization and gRPC connection
- **CPU**: Configurable priority management for background vs. interactive operations

**Intelligent File Filtering**:
```yaml
language_ecosystems:
  python:
    include_patterns: ["*.py", "*.pyi", "pyproject.toml", "requirements*.txt"]
    exclude_patterns: ["__pycache__/", ".venv/", "venv/", ".tox/", "build/", "dist/"]

  rust:
    include_patterns: ["*.rs", "Cargo.toml", "Cargo.lock"]
    exclude_patterns: ["target/", "Cargo.lock"]

  javascript:
    include_patterns: ["*.js", "*.ts", "*.jsx", "*.tsx", "package.json"]
    exclude_patterns: ["node_modules/", "dist/", "build/", ".next/"]

  global_exclusions:
    - ".git/"
    - ".DS_Store"
    - "*.log"
    - "*.tmp"
    - "thumbs.db"
```

### 5.5 Projects and Nested projects

A project is defined by the folder from which the LLM (Claude Code) is starting, unless the active folder is already part of an existing project which tree contain the current folder. The presence of an active .git folder (i.e., not just the folder but an initialized git repository) indicates the root of the project. The presence of an active .git folder is the preferred way to identify the presence of a project. It is critical, to prevent the unruly explosion of projects, to ensure that the current folder is or is not part of an already existing project, if no existing project is identified, a repo signature should be looked for in case the project root is defined in a parent folder.

A project can also be built with submodules. These submodules are considered as a relevant project if they are .git repository without remote or .git repository with remote belonging to the user (there is a configuration option to indicate the name of the github user). When such situation occurs, the submodule is treated as an independent project in the collection, i.e., it becomes a new tenant, while the main project is its own tenant which exclude the submodule. If the submodule does not belong to the user it is ignored and not ingested. By delimiting nested projects in this way, it becomes possible for the user to specifically work on a sub project, which has its own tenancy, or to work on the larger project with has its own tenancy as well but distinct from any subproject. It might however mean that there can be links between the two projects and those must be clearly configured in the collection (for instance function A in the main projects calls function B in a subproject, creates a situation where the symbol B is declared in the subproject, and used by function A in the main project).

Lastly, as projects evolve, the daemon responsibility is to ensure that the collection remains in sync with the user files, the submodule could be fully integrated or removed, a submodule belonging to another user might change ownership and become owned by the user (for instance in case of a fork).

## 6. Python MCP Server - Intelligent Interface

### 6.1 Research Modes - Four Search Contexts

**Hierarchical Search Strategy**:
```python
@mcp.tool()
async def research_workspace(
    query: str,
    mode: Literal["project", "collection", "global", "all"] = "project",
    target_collection: str = None,
    include_relationships: bool = False,
    version_preference: Literal["latest", "all", "specific"] = "latest",
    include_archived: bool = False,
    content_types: List[str] = ["all"]
):
    """Advanced semantic research with context control and version awareness"""
```

**Search Context Hierarchy**:

**1. Project Collections Only**
- Search within current project's collections (`${collections.root_name}-scratchbook`, `${collections.root_name}-docs`), types are given as examples
- Default mode for active development work
- Automatic project detection from current directory and git context
- Fast, focused results for immediate development needs

**2. Single Collection**
- Target-specific collection search (`_technical-books`, `${memory.collection_name}`, specific project), `_technical-books` is given as example
- High precision results within domain boundaries
- Library research and knowledge domain specialization
- User specifies target collection explicitly

**3. Global Collections**
- User-configured global collections in environment/config
- Cross-project knowledge search (standards, references, shared documentation)
- Broader context research across workspace boundaries
- Configurable collection list in user preferences

**4. All Collections** (Replaces qdrant-retrieve functionality)
- Comprehensive search across entire workspace
- Discovery mode for exploratory research across all content types
- Maximum recall for finding connections across projects and libraries
- Includes archived collections when specified

### 6.2 Memory System Integration

**Session Initialization with Memory Rule Injection**:
```python
async def claude_code_startup_hook():
    """Initialize session with memory-driven behavioral rules"""

    # Load memory rules and detect conflicts
    memory_rules = await load_memory_collection()
    conflicts = await detect_memory_conflicts(memory_rules)

    if conflicts:
        return {
            "type": "conflict_resolution",
            "message": format_conflict_prompt(conflicts),
            "conflicts": conflicts,
            "action_required": "resolve_before_session"
        }

    # Inject resolved rules into system context
    system_rules = format_system_rules_for_injection(memory_rules)
    await claude_code_sdk.inject_system_context(system_rules)

    # Initialize project context
    project_info = await detect_current_project()
    await ensure_project_collections(project_info)

    return {
        "type": "session_ready",
        "memory_rules_count": len(memory_rules),
        "project_collections": len(project_info.collections),
        "engine_status": "active"
    }
```
Note that the injection will rely on the official API of Claude Code, or other host tool.

**Conversational Memory Updates**:
```python
@mcp.tool()
async def update_memory_rule(
    rule_text: str,
    authority: Literal["absolute", "default"] = "default",
    scope: List[str] = ["all_sessions"],
    replace_existing: bool = False
):
    """Update behavioral memory through conversational input"""

    # Semantic conflict detection
    conflicts = await detect_rule_conflicts(rule_text)
    if conflicts and not replace_existing:
        return format_conflict_resolution_options(conflicts)

    # Store in memory collection with metadata
    memory_entry = {
        "rule": rule_text,
        "authority": authority,
        "scope": scope,
        "timestamp": datetime.utcnow(),
        "source": "conversational",
        "session_id": current_session_id()
    }

    await store_memory_rule(memory_entry)
    await apply_to_current_session(memory_entry)

    return f"Memory rule stored with {authority} authority"
```

### 6.3 Advanced Search Interface

**Code-Aware Search Tools**:
```python
@mcp.tool()
async def search_code_symbols(
    symbol_name: str,
    symbol_type: Literal["function", "class", "variable", "import"] = None,
    include_usage: bool = False,
    project_scope: bool = True
):
    """LSP-enhanced symbol definition and usage search"""

@mcp.tool()
async def search_by_type_signature(
    signature_pattern: str,
    language: str = None,
    return_examples: bool = True
):
    """Find functions/methods by type signature patterns"""

@mcp.tool()
async def find_related_documentation(
    code_element: str,
    include_external: bool = False,
    max_distance: float = 0.8
):
    """Find documentation related to code elements via semantic similarity"""
```

## 7. Unified CLI - Single Command Interface (wqm)

### 7.1 Complete CLI Structure

**Note**: This section defines the authoritative CLI command structure and requirements. User-configurable CLI behavior settings (output format, colors, etc.) are defined in Section 2.3 (Configuration Reference).

```bash
wqm                    # Single command to remember
├── memory             # Memory rules and LLM behavior management
│   ├── list           # Show all memory rules with authority levels
│   ├── add            # Add new rule (preference or behavior)
│   ├── edit           # Edit specific rule with conflict detection
│   ├── remove         # Remove rule with dependency checking
│   ├── tokens         # Show token usage and optimization suggestions
│   ├── trim           # Interactive token optimization workflow
│   ├── conflicts      # Check for rule conflicts and resolution options
│   └── export         # Export memory rules for backup/sharing
│
├── admin              # System administration and configuration
│   ├── status         # System and engine status with resource usage
│   ├── config         # Configuration management and validation
│   ├── start-engine   # Start Rust daemon with health checks
│   ├── stop-engine    # Graceful daemon shutdown with queue completion
│   ├── restart-engine # Restart daemon with new configuration
│   ├── logs           # View daemon and MCP server logs
│   ├── health         # Comprehensive system health diagnostics
│   ├── errors         # List of errors, for instance PDF files (full path) that do not contain text and need to be OCR'd
│   └── migrate        # Migration tools for version upgrades
│
├── ingest             # Manual document processing and bulk operations
                       # The manual ingestion is possible for a) a project collection (project must be specified) or a library collection
│   ├── file           # Ingest single file with metadata prompting
│   ├── folder         # Ingest folder contents with filtering
│   ├── yaml           # Process completed YAML metadata files
│   ├── webpage        # Ingest a single web page from URL
│   ├── website        # Crawl web pages from root URL with depth limits
│   ├── batch          # Batch processing with progress monitoring
│   └── resume         # Resume interrupted ingestion operations
│
├── search             # Command-line search interface across all modes
│   ├── project        # Search current project collections
│   ├── collection     # Search specific collection with targeting
│   ├── global         # Search user-configured global collections
│   ├── all            # Search all collections with relevance ranking
│   ├── memory         # Search memory/knowledge graph for rules
│   ├── symbols        # Search code symbols with LSP integration
│   └── related        # Find semantically related content across types
│
├── library            # Read-only library collection management
│   ├── list           # Show all library collections with statistics
│   ├── create         # Create new library collection with source folder
│   ├── watch          # Create new library collection with source folder, which will remain under watch
                       # Note: in the case of a folder watch, all subfolders are considered tenants (user can overrule)
                       # The tenant names are the folder name, if there is a multi-level structure the tenant names
                       # are in the form {parent}.{child} or more generally {level1}.{level2}.{level3}...
                       # Unlike a simple creation, which is static once the library has been ingested, a watched
                       # folder is continuously updated both in structure and in document version (conservatively removed files
                       # are not removed from the collection)
│   ├── unwatch        # Stop watching a library folder
│   ├── delete         # Delete library collection with its content, with confirmation
│   ├── remove         # Remove an element from a library, library collection with confirmation
│   ├── status         # Show library statistics and health
│   ├── validate       # Validate library metadata completeness
│   └── logs           # View library ingestion activity logs and errors
│
└── collections        # Collection management and state inspection
    ├── list           # List all collections with type and metadata
    ├── inspect        # Inspect collection contents and structure
    ├── stats          # Collection statistics and performance metrics
    ├── validate       # Validate collection integrity and metadata
    ├── backup         # Backup collection data and metadata
    ├── restore        # Restore collection from backup
    └── migrate        # Migrate collections between versions
```

### 7.2 CLI Integration Examples

**Memory Management Workflows**:
```bash
# Add behavioral rules with authority levels
wqm memory add "Always use uv for Python package management" --authority=default
wqm memory add "Never commit without atomic changes" --authority=absolute

# Check token usage and optimize
wqm memory tokens  # Shows: Memory rules using 1,247 tokens (8.3% of context)
wqm memory trim --max-tokens 2000 --interactive

# Handle rule conflicts
wqm memory conflicts --show-all --suggest-resolutions
```

**Library Management with Watching**:
```bash
# Create library collection and set up watching
wqm library watch technical-books  # Creates _technical-books collection (hardcoded "_" prefix)
wqm ingest yaml /home/user/library/pending_metadata.yaml

# Monitor library processing
wqm library status --collection=_technical-books
wqm collections stats --collection=_technical-books --show-recent
```

**Search Across Contexts**:
```bash
# Context-aware search with relationship inclusion
wqm search project "rust async patterns" --include-relationships
wqm search all "machine learning best practices" --content-types=code,docs
wqm search memory "python preferences" --format=structured

# Symbol-specific searches
wqm search symbols "init_client" --include-usage --show-relationships
wqm search related "authentication" --max-distance=0.8 --cross-content
```

**System Administration**:
```bash
# Health monitoring and diagnostics
wqm admin status  # Engine status, active tasks, resource usage
wqm admin health --comprehensive --check-lsp --validate-collections
wqm admin logs --component=daemon --tail=100 --filter=ERROR

# Configuration and lifecycle management
wqm admin config validate --check-lsp-paths --verify-collections
wqm admin restart-engine --wait-for-queue --health-check
```

## 8. LSP Injector - Code Intelligence Integration

### 8.1 LSP Integration Architecture

**Supported LSP Servers with Selection Criteria**:
```yaml
selection_criteria:
  1. speed: "Sub-second response times for symbol queries"
  2. project_scope: "Whole-project analysis, not single-file"
  3. feature_completeness: "Full LSP specification support"
  4. active_development: "Regular updates and community support"
  5. platform_compatibility: "Works on target OS or compilable"

selected_lsp_servers:
  python:
    primary: "ruff-lsp"
    rationale: "Fastest Python LSP, project-wide analysis, actively developed"
    features: ["symbols", "definitions", "references", "hover", "diagnostics"]

  rust:
    primary: "rust-analyzer"
    rationale: "Official Rust LSP, comprehensive analysis, excellent performance"
    features: ["symbols", "definitions", "references", "hover", "inlay_hints", "call_hierarchy"]

  javascript_typescript:
    primary: "typescript-language-server"
    rationale: "Official TypeScript LSP, works for JS/TS, project-wide intelligence"
    features: ["symbols", "definitions", "references", "hover", "refactoring"]

  java:
    primary: "eclipse.jdt.ls"
    rationale: "Most mature Java LSP, excellent project analysis"
    features: ["symbols", "definitions", "references", "hover", "workspace_symbols"]

  c_cpp:
    primary: "clangd"
    rationale: "LLVM-based, fast, comprehensive C/C++ support"
    features: ["symbols", "definitions", "references", "hover", "completion"]

  go:
    primary: "gopls"
    rationale: "Official Go LSP, excellent performance and features"
    features: ["symbols", "definitions", "references", "hover", "workspace_symbols"]
```

### 8.2 Code Intelligence Extraction

**LSP Data Collection Strategy - "Interface + Minimal Context"**:
```yaml
include_in_vectors:
  - complete_function_signatures
  - class_definitions_with_inheritance
  - import_statements_and_dependencies
  - documentation_strings_and_comments
  - type_annotations_and_signatures
  - small_context_snippets (1-3 lines around definitions)

exclude_from_vectors:
  - full_method_implementations (prevents storage duplication)
  - detailed_implementation_logic (available in file content)
  - large_code_blocks (rely on file content for implementation details)

metadata_extraction:
  symbols:
    - function_names_and_signatures
    - class_definitions_and_inheritance
    - variable_declarations_with_types
    - module_and_import_structure

  relationships:
    - import_dependencies_and_usage
    - inheritance_hierarchies
    - function_call_graphs
    - cross_file_references

  semantic_information:
    - type_information_and_annotations
    - documentation_and_docstrings
    - semantic_token_classification
    - syntax_highlighting_metadata
```

### 8.3 Real-Time Integration and Updates

**Incremental Update Strategy**:
```python
async def handle_file_change(file_path: str, change_type: str):
    """Handle real-time file changes with LSP integration"""

    if is_code_file(file_path):
        # Get LSP analysis for changed file
        lsp_metadata = await extract_lsp_metadata(file_path)

        # Update relationships for dependent files
        dependent_files = await get_dependent_files(file_path)
        for dep_file in dependent_files:
            await update_relationship_metadata(dep_file)

        # Update vector embeddings with new content + metadata
        await update_document_vectors(file_path, lsp_metadata)

    else:
        # Handle non-code files with standard processing
        await update_document_content(file_path)
```

**LSP Server Health and Systematic Degradation**:
- **Auto-detection**: Scan PATH for available LSP servers on daemon startup following standard protocol compliance
- **Health monitoring**: Periodic health checks with automatic recovery and state persistence
- **Systematic graceful degradation**:
  - **Level 1**: LSP server crash → continue with text-only processing → notify user of degraded mode
  - **Level 2**: LSP protocol errors → fall back to basic symbol extraction → queue advanced analysis for recovery
  - **Level 3**: Resource constraints → disable background analysis → prioritize user queries with reduced features
  - **Level 4**: Complete LSP failure → maintain all other functionality → clear user communication about unavailable features
- **Automatic recovery**: Resume full functionality when LSP servers become available again
- **User control**: No auto-installation, users manage LSP server versions following established tool principle
- **Configuration validation**: Verify LSP server capabilities and configuration with fallback strategies

## 9. Configuration Architecture Improvements

### 9.1 Multi-Tenancy Collection Architecture

**Migration from Suffix-Based to Multi-Tenant Collections**:
```yaml
memory:
  collection_name: "memory"

collections:
  root_name: "project"
  types:
    - "scratchbook"
    - "docs"
    - "notes"
  # No default for types, if none is given, no collection is created

  project_content:
    name: "project-content"
  # read-only collection

project_detection:
  custom_indicators: []
  # recursive_depth removed - no arbitrary limits
```

**Collection Architecture Benefits**:
- **Single read-only code collection**: Multi-tenant `_${collections.project_content.name}` with project isolation via metadata (hardcoded "_" prefix)
- **Simplified management**: No collection proliferation, clear naming conventions
- **Conflict prevention**: Server-level collision detection with clear error messages
- **State transparency**: New `wqm` domain for state database inspection

### 9.2 OS-Standard Directory Usage

**XDG Base Directory Specification (Linux/Unix)**:
```yaml
directories:
  cache: "$XDG_CACHE_HOME/workspace-qdrant-mcp"  # default: ~/.cache
  state: "$XDG_STATE_HOME/workspace-qdrant-mcp"  # default: ~/.local/state
  config: "$XDG_CONFIG_HOME/workspace-qdrant-mcp"  # default: ~/.config
  logs: "$XDG_STATE_HOME/workspace-qdrant-mcp/logs"
```

**Platform-Specific Directory Mapping**:
```yaml
macos:
  cache: "~/Library/Caches/workspace-qdrant-mcp"
  logs: "~/Library/Logs/workspace-qdrant-mcp"
  config: "~/Library/Application Support/workspace-qdrant-mcp"

windows:
  cache: "%LOCALAPPDATA%\\workspace-qdrant-mcp\\cache"
  logs: "%LOCALAPPDATA%\\workspace-qdrant-mcp\\logs"
  config: "%APPDATA%\\workspace-qdrant-mcp"

removal:
  - user_configurable_cache_dir: "removed - use OS standards"
  - user_configurable_log_paths: "removed - use OS standards"
```

### 9.3 Hardcoded Pattern System

**Research-Backed Project Indicators**:
```yaml
# Embedded at compile-time: patterns/project_indicators.yaml
project_indicators:
  version_control:
    - ".git"
    - ".hg"
    - ".svn"

  language_ecosystems:
    - "package.json"        # Node.js
    - "pyproject.toml"      # Python
    - "Cargo.toml"          # Rust
    - "pom.xml"             # Java Maven
    - "build.gradle"        # Java Gradle
    - "go.mod"              # Go
    - "composer.json"       # PHP
    - "Gemfile"             # Ruby
    - "mix.exs"             # Elixir
    - "dune-project"        # OCaml

  build_systems:
    - "Makefile"
    - "CMakeLists.txt"
    - "meson.build"
    - "BUILD.bazel"

  ci_cd:
    - ".github/"
    - ".gitlab-ci.yml"
    - ".travis.yml"
    - "azure-pipelines.yml"
    - "Jenkinsfile"
```

**LSP-Derived Language Patterns**:
```yaml
# Automatically generated from available LSP servers
# Embedded: patterns/language_extensions.yaml
language_patterns:
  python:
    extensions: [".py", ".pyi", ".pyx"]
    config_files: ["pyproject.toml", "setup.py", "requirements*.txt", "Pipfile"]

  rust:
    extensions: [".rs"]
    config_files: ["Cargo.toml", "Cargo.lock"]

  javascript:
    extensions: [".js", ".mjs", ".cjs"]
    config_files: ["package.json", "package-lock.json"]

  typescript:
    extensions: [".ts", ".tsx", ".d.ts"]
    config_files: ["tsconfig.json", "package.json"]
```

**Comprehensive Exclusion Patterns**:
```yaml
# Embedded: patterns/exclude_patterns.yaml
global_exclusions:
  version_control:
    - ".git/"
    - ".hg/"
    - ".svn/"

  build_artifacts:
    - "build/"
    - "dist/"
    - "target/"  # Rust
    - "__pycache__/"  # Python
    - "node_modules/"  # Node.js
    - ".next/"  # Next.js
    - ".nuxt/"  # Nuxt.js

  ide_files:
    - ".vscode/"
    - ".idea/"
    - "*.swp"
    - "*.swo"
    - ".DS_Store"
    - "thumbs.db"

  dependencies:
    - "venv/"
    - ".venv/"
    - "env/"
    - ".tox/"
    - "vendor/"  # Go, Ruby
    - "deps/"    # Elixir
```

## 10. Technical Specifications and Dependencies

### 10.1 Rust Daemon Dependencies

**Core Processing Libraries**:
```toml
[dependencies]
tokio = { version = "1.0", features = ["full"] }
tonic = "0.10"  # gRPC implementation
candle-core = "0.3"  # ML inference (evaluate vs ort)
tree-sitter = "0.20"  # Code parsing
tantivy = "0.21"  # Full-text search indexing
serde = { version = "1.0", features = ["derive"] }
clap = { version = "4.0", features = ["derive"] }
qdrant-client = "1.7"
sqlx = { version = "0.7", features = ["sqlite", "runtime-tokio-rustls"] }
notify = "6.0"  # File system watching
tower-lsp = "0.20"  # LSP client implementation
```

**Document Processing**:
```toml
pdf-extract = "0.6"
epub = "1.2"
html2text = "0.6"
reqwest = { version = "0.11", features = ["json", "stream"] }
scraper = "0.18"  # Web scraping
```

### 10.2 Python MCP Server Dependencies

**Core MCP and Communication**:
```toml
[dependencies]
fastmcp = "^0.4.0"
grpcio = "^1.60.0"
qdrant-client = "^1.7.0"
```

**Project Detection and Processing**:
```toml
GitPython = "^3.1.40"
pydantic = "^2.5.0"
PyYAML = "^6.0.1"
watchdog = "^3.0.0"
```

**Claude Code Integration**:
```toml
claude-code-sdk = "^0.1.0"  # When available
anthropic = "^0.7.0"  # For conflict detection
```

### 10.3 Performance Targets and Constraints

**Processing Performance**:
- **Document Ingestion**: 1000+ documents/minute (Rust daemon)
- **Search Response**: <100ms across all four search modes
- **Memory Usage**: <500MB RSS for workspaces with 100k+ documents
- **Startup Time**: <2 seconds for daemon initialization and gRPC connection
- **Memory Rules**: <2000 tokens for typical rule sets (user-configurable)

**Recovery and Resumption Performance**:
- **State Recovery**: <5 seconds to detect and present resumption options for interrupted operations
- **Transaction Rollback**: <1 second for atomic operation rollback on failure
- **Queue Persistence**: 100% preservation of unfinished work across system restarts
- **Graceful Degradation Response**: <500ms to switch to degraded mode when components fail
- **Automatic Recovery**: <10 seconds to resume full functionality when failed components restart

**LSP Integration Performance**:
- **Symbol Extraction**: <5 seconds per 1000 files
- **Symbol Lookup**: <100ms response time for definition queries
- **Incremental Updates**: <1 second for single file changes
- **Relationship Analysis**: <200ms for dependency graph queries

**Scalability Targets**:
- **Collections**: Support 100+ collections per workspace
- **Documents**: Handle 100k+ documents across all collections
- **Concurrent Users**: Support multiple MCP servers on same daemon
- **Cross-Platform**: Consistent performance across macOS, Linux, Windows

## 11. Implementation Phases and Timeline

The implementation uses the existing codebase and makes all necessary changes to achieve the objectives, addition, deletion of symbols, changes of implementation, and refactoring as required. The existing codebase, in its current form is not preserved.

The project has not been released to the public, there is no need to consider backward compatibility or data migration. The project won't be released to the public until version 0.4.0 which will have been thoroughly tested based on v0.3.x (itself based on v0.3.0dev3, but after testing and debugging).

### 11.1 Phase 1: Foundation and Architecture (v0.3.0dev0)

**Core Objectives**: Establish four-component architecture, multi-tenancy, and memory system foundation

**Deliverables**:
- [ ] Four-component architecture with clear separation of concerns
- [ ] Multi-tenant collection architecture replacing suffixes
- [ ] Reserved collection naming system (`${memory.collection_name}`, `_${collections.project_content.name}`, project patterns if any)
- [ ] Basic memory collection with conversational updates
- [ ] OS-standard directory usage (XDG/macOS/Windows)
- [ ] Hardcoded pattern system with comprehensive exclusions
- [ ] Basic CLI structure (`wqm admin`, `wqm memory`, `wqm ingest`)
- [ ] gRPC communication between MCP server and daemon
- [ ] SQLite state database for daemon configuration

**Technical Milestones**:
- [ ] Rust daemon with gRPC server and basic file processing
- [ ] Python MCP server with gRPC client and memory management
- [ ] Collection name validation and conflict prevention
- [ ] Memory rule storage and retrieval system
- [ ] Platform-specific directory detection and usage
- [ ] Embedded YAML pattern files with compile-time inclusion

### 11.2 Phase 2: LSP Integration and Code Intelligence (v0.3.0dev1)

**Core Objectives**: Complete LSP injector implementation and intelligent code processing

**Deliverables**:
- [ ] LSP server detection and communication system
- [ ] Symbol extraction, relationship mapping, and type information
- [ ] Code-aware search tools and symbol lookup functionality
- [ ] Incremental update system for code changes
- [ ] Smart ingestion differentiation (code vs. non-code files)
- [ ] Enhanced CLI (`wqm search symbols`, `wqm search related`)
- [ ] Real-time file watching with LSP integration
- [ ] Performance optimization for large codebases

**Technical Milestones**:
- [ ] LSP client implementation in Rust daemon
- [ ] "Interface + Minimal Context" extraction strategy
- [ ] Symbol metadata storage and vector embedding integration
- [ ] Cross-file relationship analysis and dependency tracking
- [ ] Code intelligence search interface in MCP server
- [ ] Health monitoring and graceful degradation for LSP servers
- [ ] Language-aware file filtering with comprehensive patterns

### 11.3 Phase 3: Library Management and Version Control (v0.3.0dev2)

**Core Objectives**: Complete library ecosystem with version-aware document management

**Deliverables**:
- [ ] Library folder watching system (`wqm watch` commands)
- [ ] Document type-based version management and precedence rules
- [ ] EPUB/MOBI conversion with metadata extraction
- [ ] Web crawling with recursive ingestion and rate limiting
- [ ] Advanced version conflict resolution and archive collections
- [ ] Complete CLI implementation (`wqm library`, `wqm watch`, advanced search)
- [ ] Metadata workflow for incomplete library information
- [ ] Performance optimization and large-scale testing

**Technical Milestones**:
- [ ] Document format detection and type-specific versioning
- [ ] Version precedence algorithms and conflict resolution
- [ ] YAML metadata workflow with user completion cycle
- [ ] Web crawling engine with depth limits and content extraction
- [ ] Archive collection system for version history
- [ ] Comprehensive library management and statistics
- [ ] Performance benchmarking with realistic workloads

### 11.4 Phase 4: Advanced Features and Memory Integration (v0.3.0dev3)

**Timeline**: 4 weeks
**Core Objectives**: Claude Code integration, advanced memory features, and production readiness

**Deliverables**:
- [ ] Claude Code SDK integration with session initialization
- [ ] Memory conflict detection and resolution system
- [ ] Agent library and deployment decision support
- [ ] Advanced research modes across all four search contexts
- [ ] Web interface for memory rule curation (`wqm memory --web`)
- [ ] Knowledge graph relationship extraction from documents
- [ ] Production deployment guides and migration tools
- [ ] Comprehensive documentation and user guides

**Technical Milestones**:
- [ ] Claude Code system context injection with memory rules
- [ ] Semantic conflict detection using Claude/Sonnet analysis
- [ ] Agent library metadata and deployment cost analysis
- [ ] Graph visualization for knowledge relationships
- [ ] Interactive web interface for rule management
- [ ] Advanced search with relationship traversal
- [ ] Migration tools for existing installations
- [ ] Performance monitoring and optimization tools

## 12. Success Criteria and Acceptance Tests

### 12.1 Functional Requirements

**Memory-Driven Behavior**:
- [ ] LLM follows user-defined rules consistently across all sessions
- [ ] Conversational memory updates work without manual configuration
- [ ] Rule conflicts are detected and resolved before session start
- [ ] Memory rules are automatically injected into Claude Code system context
- [ ] Authority levels (absolute vs default) are respected in all scenarios

**Multi-Modal Content Integration**:
- [ ] Seamless search across code, documents, books, web content
- [ ] Version management works automatically without user intervention
- [ ] LSP integration provides accurate symbol definitions and relationships
- [ ] Project detection and collection creation happens automatically
- [ ] Four-tier search hierarchy matches user mental models

**System Performance and Reliability**:
- [ ] 10x improvement in processing speed over Python-only implementation
- [ ] Sub-100ms search response times across all modes
- [ ] Graceful daemon lifecycle with queue completion before shutdown
- [ ] Automatic recovery from LSP server failures and restarts
- [ ] Resource usage remains under target limits (<500MB RSS)

### 12.2 User Experience Requirements

**Seamless Integration**:
- [ ] Memory rules are automatically active in every Claude Code session
- [ ] Project context is available immediately upon entering project directory
- [ ] Library collections are accessible from any project context
- [ ] System status and errors are clearly communicated to users
- [ ] Migration from previous versions is seamless with clear guidance

**Adult User Respect**:
- [ ] System provides information and tools, users make decisions
- [ ] No auto-installation of dependencies (LSP servers, etc.)
- [ ] Configuration is optional with intelligent defaults, based on a fully complete configuration file populated with default values and commentary to explain the role of each value
- [ ] Error messages provide actionable guidance without condescension
- [ ] Complex functionality is accessible through simple commands

**Operational Simplicity**:
- [ ] Single `wqm` command covers all functionality intuitively
- [ ] New installations work with minimal configuration
- [ ] Common workflows are discoverable and efficient
- [ ] System self-diagnoses and provides health information
- [ ] Backup and recovery procedures are straightforward

### 12.3 Technical Requirements

**Architecture and Maintainability**:
- [ ] Four-component architecture enables independent optimization
- [ ] Clean separation of concerns between daemon, server, utility, injector
- [ ] API contracts are stable and support future extensions
- [ ] Code is well-documented with comprehensive tests
- [ ] Performance metrics are built-in and observable

**Cross-Platform Compatibility**:
- [ ] Consistent behavior across macOS, Linux, Windows
- [ ] OS-standard directories are used correctly on each platform
- [ ] Platform-specific features are handled gracefully
- [ ] Installation and setup work reliably across environments
- [ ] Error handling accounts for platform differences

**Scalability and Performance**:
- [ ] Handles 100k+ documents across hundreds of collections
- [ ] Multi-tenant architecture prevents resource conflicts
- [ ] Concurrent access from multiple MCP servers works correctly
- [ ] Memory usage scales predictably with content volume
- [ ] Processing performance meets or exceeds target benchmarks

## 13. Risk Assessment and Mitigation Strategies

### 13.1 Technical Risks

**Multi-Process Architecture Complexity**:
- **Risk**: Coordination between Python MCP and Rust daemon creates reliability issues
- **Impact**: System instability, data loss, poor user experience
- **Mitigation**: Comprehensive integration testing, graceful failure modes, automatic recovery
- **Monitoring**: Health checks, process monitoring, automated restarts

**LSP Integration Reliability**:
- **Risk**: LSP servers are unreliable, crash frequently, or provide inconsistent data
- **Impact**: Code intelligence features become unusable, user frustration
- **Mitigation**: Graceful degradation, health monitoring, automatic recovery, fallback to text-only
- **Monitoring**: LSP server health checks, error rate tracking, performance metrics

**Platform Distribution Complexity**:
- **Risk**: Pre-built wheels for multiple architectures create maintenance burden
- **Impact**: Installation failures, platform-specific bugs, support complexity
- **Mitigation**: Tier 1/2 platform strategy, automated CI/CD, comprehensive testing matrix
- **Monitoring**: Installation success rates, platform-specific error tracking

### 13.2 User Experience Risks

**Memory System Complexity**:
- **Risk**: Rule conflicts and authority levels confuse users, leading to unexpected behavior
- **Impact**: Loss of trust in system, abandonment of memory features
- **Mitigation**: Clear conflict resolution UI, comprehensive documentation, sensible defaults
- **Monitoring**: User feedback, conflict resolution success rates, rule usage patterns

**Learning Curve for Advanced Features**:
- **Risk**: Rich feature set overwhelms users, especially those with simple use cases
- **Impact**: Feature abandonment, negative user experience, support burden
- **Mitigation**: Progressive disclosure, intelligent defaults, comprehensive onboarding
- **Monitoring**: Feature usage analytics, user feedback, support ticket patterns

**Migration and Compatibility**:
- **Risk**: Breaking changes alienate existing users, migration tools fail
- **Impact**: User churn, negative community feedback, adoption barriers
- **Mitigation**: Clear migration paths, backward compatibility where possible, user communication
- **Monitoring**: Migration success rates, user retention, community feedback

### 13.3 Operational Risks

**Development Scope and Timeline**:
- **Risk**: Ambitious feature set leads to delayed releases and incomplete functionality
- **Impact**: Missed deadlines, technical debt, user expectations not met
- **Mitigation**: Phased implementation, MVP focus, regular milestone reviews
- **Monitoring**: Development velocity, feature completeness, quality metrics

**Support and Maintenance Burden**:
- **Risk**: Multi-component system increases support complexity and maintenance overhead
- **Impact**: Increased support costs, slower development, user frustration
- **Mitigation**: Comprehensive diagnostics, clear error messages, automated health checks
- **Monitoring**: Support ticket volume and resolution time, system health metrics

**Community Adoption and Feedback**:
- **Risk**: Limited user base provides insufficient feedback for system validation
- **Impact**: Product-market fit issues, design decisions based on incomplete information
- **Mitigation**: Beta testing program, community engagement, iterative development
- **Monitoring**: User adoption rates, feature usage, community engagement metrics

### 13.4 Mitigation Implementation Plan

**Phase 1 Risk Mitigation**:
- [ ] Implement comprehensive health checks and monitoring
- [ ] Create automated testing for multi-component interactions
- [ ] Design graceful failure modes for all component interactions
- [ ] Establish clear error reporting and diagnostic capabilities

**Phase 2 Risk Mitigation**:
- [ ] Build LSP server health monitoring and automatic recovery
- [ ] Create fallback modes for when LSP servers are unavailable
- [ ] Implement comprehensive logging and performance metrics
- [ ] Design user-friendly error messages and recovery guidance

**Phase 3 Risk Mitigation**:
- [ ] Create migration tools and backward compatibility testing
- [ ] Build user onboarding flows and progressive feature disclosure
- [ ] Implement user feedback collection and analysis systems
- [ ] Create comprehensive documentation and troubleshooting guides

**Ongoing Risk Management**:
- [ ] Regular risk assessment reviews and mitigation strategy updates
- [ ] User feedback analysis and incorporation into development priorities
- [ ] Performance monitoring and optimization based on real-world usage
- [ ] Community engagement and support process optimization

This comprehensive PRD provides the complete specification for transforming workspace-qdrant-mcp into a sophisticated, memory-driven semantic workspace platform with intelligent code understanding and conversational behavioral control. The four-component architecture, phased implementation approach, and comprehensive risk mitigation ensure deliverable milestones while building toward an ambitious but achievable vision of natural LLM-agent workspace interaction.
