# workspace-qdrant-mcp PRD v2.0

**Version:** 2.0  
**Date:** 2025-08-30  
**Status:** Draft - Strategic Architectural Evolution

## Executive Summary

The workspace-qdrant-mcp evolves into a comprehensive semantic workspace platform with knowledge graph capabilities, automated ingestion, and version-aware document management. This major architectural redesign introduces a Rust-based ingestion engine, reserved collection naming conventions, and multi-modal content processing for professional AI-driven development workflows.

## Strategic Vision

### Core Philosophy
- **Semantic-first**: Every piece of content becomes searchable knowledge
- **Version-aware**: Track document evolution with intelligent precedence
- **Knowledge graph**: Automated relationship extraction and graph construction
- **Multi-modal**: Code, documents, books, web content unified
- **Performance-driven**: Rust engine for heavy processing, Python MCP for interface

## Architectural Overview

### Two-Process Architecture

**Python MCP Server** (Interface Layer):
- User-facing MCP tools and search interface
- Fast response times for queries
- Configuration and collection management
- Research mode orchestration

**Rust Ingestion Engine** (Processing Layer):
- Background daemon for heavy processing
- Document parsing, conversion, embedding
- File watching and auto-ingestion
- Knowledge graph construction
- LSP integration for code analysis

### Communication Protocol
- **gRPC**: High-performance binary protocol between Python MCP and Rust engine
- **Graceful lifecycle**: Engine cancels shutdown if new work arrives
- **Signal handling**: Controlled shutdown with task completion

## Collection Architecture

### Reserved Collection Names

**1. Memory Collection**: `memory`
- **Type**: Pure knowledge graph
- **Content**: LLM-augmented relationships, user-defined entities
- **Interface**: CLI YAML ingestion + LLM augmentation
- **Purpose**: Central knowledge hub for workspace

**2. Library Collections**: `_{name}`
- **Pattern**: User-defined libraries prefixed with `_`
- **Readonly**: MCP server cannot modify, only Rust engine writes
- **Display**: User sees `library`, actual collection is `_library`
- **Conflict Prevention**: `_library` exists â†’ `library` cannot be created
- **Examples**: `_technical-books`, `_reference-docs`, `_standards`

**3. Project Collections**: `{project-name}-{type}`
- **Types**: `-scratchbook`, `-docs`, `-code` (if not using memexd)
- **Dynamic**: Created based on project detection
- **Writable**: Full read/write access via MCP

### Collection Name Restrictions
- Collections starting with `_` cannot be created via MCP
- Reserved names: `memory` (global knowledge graph)
- Naming conflicts prevented at creation time

## Rust Ingestion Engine

### Core Responsibilities

**1. File Conversion**
- Text files: Direct ingestion with metadata
- PDF: Text extraction + OCR for image-based PDFs
- EPUB/MOBI: E-book parsing with metadata
- Code files: LSP-enhanced parsing with symbols
- Web pages: Recursive crawling from root URLs

**2. Folder Watching**
- Project folders: Auto-ingest code changes with LSP
- Library folders: Monitor for new books/documents
- Metadata completion: YAML file generation for incomplete metadata

**3. Auto-Ingestion Pipeline**
- File type detection and routing
- Metadata extraction and validation
- Embedding generation and vector storage
- Knowledge graph relationship extraction
- Version management and precedence handling

**4. On-Demand Processing**
- CLI-triggered batch operations
- MCP-requested document processing
- Manual YAML-based ingestion

### Metadata Workflow

**Incomplete Metadata Detection**:
1. Engine discovers files without complete metadata
2. Creates YAML file in root folder with file list
3. User completes metadata in YAML
4. Engine processes files with metadata
5. Updates YAML with remaining incomplete files

**YAML Structure Example**:
```yaml
# Generated by workspace-qdrant-mcp ingestion engine
# Complete metadata for the files below and re-run ingestion

pending_files:
  - path: /library/advanced-rust.pdf
    detected_metadata:
      title: "Advanced Rust Programming"
      format: pdf
    required_metadata:
      author: "?"
      year: "?"
      isbn: "?"
      tags: ["rust", "programming"]
      
  - path: /library/algorithms.epub
    detected_metadata:
      title: "Introduction to Algorithms"
      format: epub
    required_metadata:
      author: "?"
      edition: "?"
      publisher: "?"
```

## Knowledge Graph Implementation

### Memory Collection Structure
- **Entities**: People, concepts, projects, technologies
- **Relationships**: Semantic connections between entities
- **Augmentation**: LLM-enhanced relationship discovery
- **User Control**: CLI interface for manual entity/relationship addition

### Relationship Extraction
- **NER**: Named Entity Recognition from documents
- **Relation Extraction**: Transformer-based relationship identification
- **Coreference Resolution**: Entity linking and disambiguation
- **Vector Similarity**: Implicit relationship inference

## Version Management System

### Code Versioning
- **Git Integration**: Track by git tag, branch, file timestamp
- **LSP Enhancement**: Symbol-level change tracking
- **Precedence**: Latest tag > branch > timestamp

### Document Versioning
- **Library Content**: Version/revision + date precedence
- **Web Content**: Ingestion timestamp-based
- **Precedence Logic**: Configurable precedence rules

### Version Metadata Schema
```json
{
  "document_id": "rust-book-chapter-1",
  "version": "2.1.0",
  "timestamp": "2025-01-15T10:30:00Z",
  "version_type": "semantic|timestamp|revision",
  "is_latest": true,
  "supersedes": ["rust-book-chapter-1-v2.0.0"],
  "source_info": {
    "git_tag": "v2.1.0",
    "git_branch": "main",
    "file_hash": "sha256:...",
    "ingestion_date": "2025-01-15T10:30:00Z"
  }
}
```

## Research Modes

### Four Research Contexts

**1. Project Collections Only**
- Search within current project's collections
- Fast, focused results
- Default mode for development work

**2. Single Collection**
- Target-specific collection search
- Library research, specific knowledge domains
- High precision results

**3. Global Collections**
- User-configured global collections
- Cross-project knowledge search
- Broader context research

**4. All Collections** (replaces qdrant-retrieve functionality)
- Comprehensive workspace search
- Discovery across all content
- Maximum recall mode

### Search Interface Evolution
```python
@mcp.tool()
async def research_workspace(
    query: str,
    mode: Literal["project", "collection", "global", "all"] = "project",
    target_collection: str = None,
    include_relationships: bool = False,
    version_preference: Literal["latest", "all", "specific"] = "latest"
):
    """Advanced semantic research with context control"""
```

## CLI Command Redesign

### New Command Structure
- **wqadmin**: Administrative operations, configuration
- **wqingest**: Document and library ingestion
- **wqsearch**: Command-line search interface
- **wqmemory**: Knowledge graph management
- **wqwatch**: Folder watching setup and control

### Engine Lifecycle Commands
```bash
# Start background engine
wqadmin start-engine

# Graceful shutdown
wqadmin stop-engine

# Engine status
wqadmin engine-status

# Restart with new configuration  
wqadmin restart-engine
```

## Implementation Phases

### Phase 1: Foundation Architecture (Weeks 1-2)
- [ ] Design Rust ingestion engine architecture
- [ ] Implement gRPC communication protocol
- [ ] Create reserved collection name system
- [ ] Build basic file watching infrastructure
- [ ] Update CLI command structure with wq prefix

### Phase 2: Core Ingestion Pipeline (Weeks 3-4)
- [ ] File conversion system (PDF, EPUB, text, code)
- [ ] Metadata extraction and YAML workflow
- [ ] LSP integration for code analysis
- [ ] Basic version management system
- [ ] Folder watching with auto-ingestion

### Phase 3: Knowledge Graph Foundation (Weeks 5-6)
- [ ] Memory collection implementation
- [ ] Entity and relationship extraction
- [ ] LLM-augmented knowledge graph construction
- [ ] CLI interface for manual knowledge management
- [ ] Graph query and traversal capabilities

### Phase 4: Advanced Features (Weeks 7-8)
- [ ] Web crawling and recursive ingestion
- [ ] Version precedence and conflict resolution
- [ ] Research mode implementation
- [ ] Performance optimization and benchmarking
- [ ] Comprehensive testing and validation

### Phase 5: Integration and Polish (Weeks 9-10)
- [ ] MCP server integration with Rust engine
- [ ] Documentation and user guides
- [ ] Migration tools from v1 architecture
- [ ] Performance tuning and optimization
- [ ] Production readiness validation

## Technical Specifications

### Rust Engine Dependencies
- **tokio**: Async runtime
- **tonic**: gRPC implementation
- **candle**: ML inference
- **tree-sitter**: Code parsing
- **tantivy**: Full-text search
- **serde**: Serialization
- **clap**: CLI interface

### Performance Targets
- **Ingestion**: 1000+ documents/minute
- **Search**: Sub-100ms response time
- **Memory**: <500MB RSS for large workspaces
- **Startup**: <2 seconds for engine initialization

### Security Considerations
- **Sandboxing**: Rust engine runs with minimal privileges
- **Input validation**: All user inputs validated before processing
- **Resource limits**: Configurable memory and CPU limits
- **Audit logging**: All operations logged for security review

## Success Criteria

### Functional Requirements
1. **Multi-modal ingestion**: Handle code, documents, books, web content
2. **Knowledge graph**: Automated relationship extraction and storage
3. **Version management**: Intelligent precedence and conflict resolution
4. **Performance**: 10x improvement over Python-only implementation
5. **Usability**: Simplified CLI commands and automated workflows

### Integration Requirements
1. **Backward compatibility**: Existing collections continue working
2. **Migration path**: Clear upgrade path from v1 to v2
3. **Configuration**: Simple setup and configuration
4. **Monitoring**: Engine health and performance monitoring
5. **Documentation**: Comprehensive user and developer guides

## Risk Assessment and Mitigation

### Technical Risks
- **Complexity**: Multi-process architecture increases complexity
  - *Mitigation*: Comprehensive testing, gradual rollout
- **Performance**: Engine resource usage could impact system
  - *Mitigation*: Resource limits, performance monitoring
- **Compatibility**: Breaking changes to existing workflows
  - *Mitigation*: Backward compatibility, migration tools

### Operational Risks
- **Development time**: Ambitious scope could extend timeline
  - *Mitigation*: Phased approach, MVP focus
- **Learning curve**: Users need to understand new capabilities
  - *Mitigation*: Excellent documentation, examples
- **Support burden**: Complex system may increase support needs
  - *Mitigation*: Comprehensive error handling, diagnostic tools

## Questions for Clarification

### Architecture Questions
1. **gRPC vs alternatives**: Would message queues (Redis/RabbitMQ) be preferred for async communication?
2. **Engine deployment**: Should the Rust engine be a separate binary or embedded?
3. **Configuration sharing**: How should Python MCP and Rust engine share configuration?

### Feature Questions
1. **LSP implementation**: Which language servers should be prioritized?
2. **Web crawling scope**: Should we implement rate limiting and robots.txt respect?
3. **Knowledge graph schema**: Should we use existing ontologies (Dublin Core, Schema.org)?

### Migration Questions
1. **Existing data**: How should existing collections be migrated to new architecture?
2. **Breaking changes**: What level of backward compatibility is required?
3. **Rollback plan**: If v2 has issues, how do users revert to v1?

## Suggested Improvements and Challenges

### Architectural Suggestions
1. **Modular design**: Consider plugin architecture for file converters
2. **Caching strategy**: Implement intelligent caching for embeddings and relationships
3. **Monitoring**: Add comprehensive metrics and health checks
4. **Testing**: Include property-based testing for complex data flows

### User Experience Challenges
1. **Complexity**: The system may be overwhelming for simple use cases
   - *Suggestion*: Provide "simple" and "advanced" configuration modes
2. **Resource usage**: Background engine might consume significant resources
   - *Suggestion*: Implement dynamic resource scaling based on workload
3. **Learning curve**: Knowledge graph concepts may be unfamiliar
   - *Suggestion*: Interactive tutorials and examples

### Technical Challenges
1. **Cross-platform**: Rust engine needs to work across OSes consistently
2. **Version conflicts**: Managing different document versions could be complex
3. **Error recovery**: Engine crashes should not corrupt data or require manual intervention
4. **Performance scaling**: System needs to handle very large document collections

This PRD represents a significant evolution toward a professional-grade semantic workspace platform. The architecture is ambitious but technically sound, with clear benefits for power users while maintaining accessibility for simpler workflows.